

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CONVERT_AXISPARAMETER
VAR_INPUT
	xStart:BOOL;
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
END_VAR
VAR_OUTPUT
	xDone:BOOL;
	xBusy:BOOL;
	xError:BOOL;
	diErrorNr:DINT;
END_VAR
VAR
(* trigger *)
	RisingEdgeStart:R_TRIG;
(* variable *)
	i: INT;
	iPosCarStart,iPosCarStop:INT;
	iStepConvertValueString:INT;
(* tmp variable *)
	sTmp:STRING(255);
	jj: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock convert the axis parameter for the EcoStep drive                                       ************)
(****************************************************************************************************************************************************)
(* wait start *)
	RisingEdgeStart(CLK:=xStart);
	IF RisingEdgeStart.Q THEN
	(* init. varaible *)
		iStepConvertValueString:=1;
		xDone:=FALSE;
	(*activ busy flag*)
		xBusy:=TRUE;
		xError:=FALSE;
		diErrorNr:=0;
	END_IF

(* test if activ *)
	IF NOT(xBusy) THEN
	(* exit FB *)
		RETURN;
	END_IF

	(* conversion string to value *)
		i:=1;
		(* read string line-->Group or NodeId *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.udiNC_TaskIdxGrp:=0;
		T_Axis.T_Config_Gen.udiNodeId:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string line-->ADS NetID *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.sServoNetId:='';
		T_Axis.T_Config_Gen.sAmsNetId:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		(* read string line-->DeviceName *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.sDeviceFileName:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		(* read string line-->Scalefactor *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_CtrleSingle.lrScaleFactor:=STRING_TO_LREAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string line-->GearRatioFactor  *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_CtrleSingle.lrGearRatioFactor:=STRING_TO_LREAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string line-->GearRatioDivider *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_CtrleSingle.lrGearRatioDivider:=STRING_TO_LREAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		IF (T_Axis.T_CtrleSingle.lrGearRatioFactor <> 0) AND (T_Axis.T_CtrleSingle.lrGearRatioDivider <> 0) THEN
			T_Axis.T_CtrleSingle.lrGearRatio:=T_Axis.T_CtrleSingle.lrGearRatioFactor/T_Axis.T_CtrleSingle.lrGearRatioDivider;
		ELSE
			T_Axis.T_CtrleSingle.lrGearRatio:=1;
		END_IF;
		i:=i+1;
		jj:=1;
		(* read string lines *)
		WHILE T_Axis.T_FileObj.sData[i] <> '' DO
			sTmp:=T_Axis.T_FileObj.sData[i];
			(* index group *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIdxGroup:=	STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart))
											+ T_Axis.T_Config_Gen.udiNC_TaskIdxGrp;
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* index offset *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIndexOffset:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* length value *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiLength:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* value*)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].lrReal:=UDINT_TO_REAL(STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart)));
			(* init existing line, erase text *)
			iPosCarStop:=FIND(T_Axis.T_FileObj.sData[i],'(');
			T_Axis.T_FileObj.sData[i]:=MID(T_Axis.T_FileObj.sData[i],iPosCarStop-1,1);
			(* next line *)
			i:=i+1;
			jj:=jj+1;
		END_WHILE
		(* init. next *)
		T_Axis.T_ParamFileObj[jj].udiIdxGroup:=0;
		T_Axis.T_ParamFileObj[jj].udiIndexOffset:=0;
		T_Axis.T_ParamFileObj[jj].udiLength:=0;
		T_Axis.T_ParamFileObj[jj].lrReal:=0;

		(* set flag done *)
		xBusy:=FALSE;
		xDone:=TRUE;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CONVERT_PARA_AXIS
VAR_INPUT
	xStart:BOOL;
	iConversion:INT;
	sDeviceName:STRING(255);
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
END_VAR
VAR_OUTPUT
	xDone:BOOL;
	xBusy:BOOL;
	xError:BOOL;
	diErrorNr:DINT;
END_VAR
VAR
(* trigger *)
	RisingEdgeStart:R_TRIG;
(* variable *)
	i: INT;
	iPosCarStart,iPosCarStop:INT;
	iStepConvertValueString:INT;
(* tmp variable *)
	sTmp:STRING(255);
	jj: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock convert the axis parameter for the Beckhoff drive                                       ************)
(****************************************************************************************************************************************************)
(* wait start *)
	RisingEdgeStart(CLK:=xStart);
	IF RisingEdgeStart.Q THEN
	(* init. varaible *)
		iStepConvertValueString:=1;
		xDone:=FALSE;
	(*activ busy flag*)
		xBusy:=TRUE;
		xError:=FALSE;
		diErrorNr:=0;
	END_IF

(* test if activ *)
	IF NOT(xBusy) THEN
	(* exit FB *)
		RETURN;
	END_IF
	IF iConversion = 0 THEN
	(* conversion string to value *)
		i:=1;
		(* read string line-->Group or NodeId *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		IF sDeviceName = 'Beckhoff' THEN
			T_Axis.T_Config_Gen.udiNC_TaskIdxGrp:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			T_Axis.T_Config_Gen.udiNodeId:=0;
		END_IF;
		IF sDeviceName = 'Maxon' THEN
			T_Axis.T_Config_Gen.udiNC_TaskIdxGrp:=0;
			T_Axis.T_Config_Gen.udiNodeId:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		END_IF;
		i:=i+1;
		(* read string line-->ADS NetID *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		IF sDeviceName = 'Beckhoff' THEN
			T_Axis.T_Config_Gen.sServoNetId:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
			T_Axis.T_Config_Gen.sAmsNetId:='';
		END_IF;
		IF sDeviceName = 'Maxon' THEN
			T_Axis.T_Config_Gen.sServoNetId:='';
			T_Axis.T_Config_Gen.sAmsNetId:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		END_IF;
		i:=i+1;
		(* read string line-->DeviceName *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.sDeviceFileName:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		IF sDeviceName = 'Beckhoff' THEN
			(* read string line-->Quickstop ramp deceleration *)
			sTmp:=T_Axis.T_FileObj.sData[i];
			iPosCarStart:=FIND(sTmp,':=')+2;
	   		iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_Config_Setting.rHCRampDeceleration:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			i:=i+1;
			(* read string line-->Quickstop ramp jerk *)
			sTmp:=T_Axis.T_FileObj.sData[i];
			iPosCarStart:=FIND(sTmp,':=')+2;
	   		iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_Config_Setting.rHCRampJerk:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			i:=i+1;
		END_IF;
		jj:=1;
		(* read string lines *)
		WHILE T_Axis.T_FileObj.sData[i] <> '' DO
			sTmp:=T_Axis.T_FileObj.sData[i];
			(* index group *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIdxGroup:=	STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart))
											+ T_Axis.T_Config_Gen.udiNC_TaskIdxGrp;
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* index offset *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIndexOffset:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* length value *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiLength:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* value*)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].lrReal:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			(* init existing line, erase text *)
			iPosCarStop:=FIND(T_Axis.T_FileObj.sData[i],'(');
			T_Axis.T_FileObj.sData[i]:=MID(T_Axis.T_FileObj.sData[i],iPosCarStop-1,1);
			(* next line *)
			i:=i+1;
			jj:=jj+1;
		END_WHILE
		(* init. next *)
		T_Axis.T_ParamFileObj[jj].udiIdxGroup:=0;
		T_Axis.T_ParamFileObj[jj].udiIndexOffset:=0;
		T_Axis.T_ParamFileObj[jj].udiLength:=0;
		T_Axis.T_ParamFileObj[jj].lrReal:=0;

	(* Init. NC parameter *)
		i:=1;
		(* Beckhoff *)
		IF sDeviceName = 'Beckhoff' THEN
			(*copy parameter value *)
			WHILE T_Axis.T_ParamFileObj[i].udiIdxGroup <> 0 DO
				CASE (T_Axis.T_ParamFileObj[i].udiIdxGroup - T_Axis.T_Config_Gen.udiNC_TaskIdxGrp) OF
				16#4000:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Calibration velocity forward *)
						16#6:	T_Axis.T_Config_ObjFileValue.lrCalVelocityForward:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Calibration velocity backward *)
						16#7:	T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Maximum velocity *)
						16#27:	T_Axis.T_Config_ObjFileValue.lrMaxVelocity:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Acceleration *)
						16#101:	T_Axis.T_Config_ObjFileValue.lrAcceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Decceleration *)
						16#102:	T_Axis.T_Config_ObjFileValue.lrDecceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Jerk *)
						16#103:	T_Axis.T_Config_ObjFileValue.lrJerk:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				16#5000:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Encoder scaling factor *)
						16#6:	T_Axis.T_Config_ObjFileValue.lrScaleFactor:=T_Axis.T_ParamFileObj[i].lrReal;
						(* SW limit negativ On/Off *)
						16#B:	T_Axis.T_Config_ObjFileValue.xSWLimitNeg:=REAL_TO_BOOL(T_Axis.T_ParamFileObj[i].lrReal);
						(* SW limit positiv On/Off *)
						16#C:	T_Axis.T_Config_ObjFileValue.xSWLimitPos:=REAL_TO_BOOL(T_Axis.T_ParamFileObj[i].lrReal);
						(* SW limit negativ value *)
						16#D:	T_Axis.T_Config_ObjFileValue.lrSWLimitNeg:=T_Axis.T_ParamFileObj[i].lrReal;
						(* SW limit position value *)
						16#E:	T_Axis.T_Config_ObjFileValue.lrSWLimitPos:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				16#6000:;
				16#7000:;
				END_CASE
				(* next parameter *)
				i:=i+1;
			END_WHILE
		END_IF

		(* Maxon *)
		IF sDeviceName = 'Maxon' THEN
			(*copy parameter value *)
			WHILE T_Axis.T_ParamFileObj[i].udiIdxGroup <> 0 DO
				CASE T_Axis.T_ParamFileObj[i].udiIdxGroup  OF
				16#6083:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Acceleration *)
						16#0:	T_Axis.T_Config_ObjFileValue.lrAcceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				16#6084:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Decceleration *)
						16#0:	T_Axis.T_Config_ObjFileValue.lrDecceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				END_CASE
				(* next parameter *)
				i:=i+1;
			END_WHILE
		END_IF
		(* set flag done *)
		xBusy:=FALSE;
		xDone:=TRUE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CONVERT_PDOMAPPING
VAR_INPUT
	xStart:BOOL;
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
END_VAR
VAR_OUTPUT
	xDone:BOOL;
	xBusy:BOOL;
	xError:BOOL;
	diErrorNr:DINT;
END_VAR
VAR
(* trigger *)
	RisingEdgeStart:R_TRIG;
(* variable *)
	i: INT;
	iPosCarStart,iPosCarStop:INT;
	iStepConvertValueString:INT;
(* tmp variable *)
	sTmp:STRING(255);
	jj: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock convert the PDO parameter for the EcoStep drive                                     ************)
(****************************************************************************************************************************************************)
(* wait start *)
	RisingEdgeStart(CLK:=xStart);
	IF RisingEdgeStart.Q THEN
	(* init. varaible *)
		iStepConvertValueString:=1;
		xDone:=FALSE;
	(*activ busy flag*)
		xBusy:=TRUE;
		xError:=FALSE;
		diErrorNr:=0;
	END_IF

(* test if activ *)
	IF NOT(xBusy) THEN
	(* exit FB *)
		RETURN;
	END_IF

	(* conversion string to value *)
		i:=1;
		(* read string line-->Group or NodeId *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.udiNC_TaskIdxGrp:=0;
		T_Axis.T_Config_Gen.udiNodeId:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string line-->ADS NetID *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.sServoNetId:='';
		T_Axis.T_Config_Gen.sAmsNetId:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		(* read string line-->DeviceName *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.sFileNamePDOMapping:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		jj:=1;
		(* read string lines *)
		WHILE T_Axis.T_FileObj.sData[i] <> '' DO
			sTmp:=T_Axis.T_FileObj.sData[i];
			(* index group *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIdxGroup:=	STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart))
											+ T_Axis.T_Config_Gen.udiNC_TaskIdxGrp;
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* index offset *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIndexOffset:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* length value *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiLength:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* value*)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].lrReal:=UDINT_TO_REAL(STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart)));
			(* init existing line, erase text *)
			iPosCarStop:=FIND(T_Axis.T_FileObj.sData[i],'(');
			T_Axis.T_FileObj.sData[i]:=MID(T_Axis.T_FileObj.sData[i],iPosCarStop-1,1);
			(* next line *)
			i:=i+1;
			jj:=jj+1;
		END_WHILE
		(* init. next *)
		T_Axis.T_ParamFileObj[jj].udiIdxGroup:=0;
		T_Axis.T_ParamFileObj[jj].udiIndexOffset:=0;
		T_Axis.T_ParamFileObj[jj].udiLength:=0;
		T_Axis.T_ParamFileObj[jj].lrReal:=0;

		(* set flag done *)
		xBusy:=FALSE;
		xDone:=TRUE;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_DEFAULT_AXISVALUE
VAR_INPUT
	xDefaultValue:BOOL:=FALSE;
	sDeviceName:STRING(255);
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                      This Functionblock set the default axis value for the Beckhoff drive                                         ************)
(****************************************************************************************************************************************************)
IF xDefaultValue THEN
	IF sDeviceName = 'Beckhoff' THEN
		CASE T_Axis.T_Config_Gen.iTyp OF
		(* linear axis Beckhoff *)
		1:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#4000;idxOff:=16#27;LEN:=16#8;Value:=200.0';(* Max velocity *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#4000;idxOff:=16#6;Len:=16#8;Value:=20.0';(* Vel Ref forward *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#4000;idxOff:=16#7;LEN:=16#8;Value:=20.0';(* Vel Ref backward *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#4000;idxOff:=16#101;Len:=16#8;Value:=3800.0';(* Acc *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#4000;idxOff:=16#102;Len:=16#8;Value:=3800.0';(* Dec *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#4000;idxOff:=16#103;Len:=16#8;Value:=80222.0';(* Jerk *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#4000;idxOff:=16#A;Len:=16#8;Value:=200.0';(* Rapid traverse vel *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#5000;idxOff:=16#B;Len:=16#2;Value:=0';(* Enable min soft pos *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#5000;idxOff:=16#D;Len:=16#8;Value:=0';(* Min soft pos *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#5000;idxOff:=16#C;Len:=16#2;Value:=0';(* Enable max soft pos *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#5000;idxOff:=16#E;Len:=16#8;Value:=0';(* Max soft pos *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#6000;idxOff:=16#10;Len:=16#2;Value:=1';(* Enable pos lag *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6000;idxOff:=16#12;Len:=16#8;Value:=10.0';(* Max Pos lag *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#5000;idxOff:=16#8;Len:=16#2;Value:=0';(* Invert Enc counting *)
			T_Axis.T_FileObj.sData[15]:='15:idxGrp:=16#5000;idxOff:=16#6;Len:=16#8;Value:=3.81e-5';(* Enc scaling factor *)
			T_Axis.T_FileObj.sData[16]:='16:idxGrp:=16#5000;idxOff:=16#9;Len:=16#8;Value:=1';(* Enc modulo factor *)
			T_Axis.T_FileObj.sData[17]:='17:idxGrp:=16#5000;idxOff:=16#101;Len:=16#2;Value:=1';(* Enc dir for ref search *)
			T_Axis.T_FileObj.sData[18]:='18:idxGrp:=16#5000;idxOff:=16#102;Len:=16#2;Value:=0';(* Enc dir for sync impuls*)
			T_Axis.T_FileObj.sData[19]:='19:idxGrp:=16#5000;idxOff:=16#103;Len:=16#8;Value:=0';(* Enc ref value *)
			T_Axis.T_FileObj.sData[20]:='20:idxGrp:=16#5000;idxOff:=16#106;Len:=16#2;Value:=0';(* Enc Ext sync impuls *)
			T_Axis.T_FileObj.sData[21]:='21:idxGrp:=16#5000;idxOff:=16#107;Len:=16#4;Value:=5';(* Enc ref sequence *)
			T_Axis.T_FileObj.sData[22]:='22:idxGrp:=16#7000;idxOff:=16#6;Len:=16#2;Value:=0';(* Driver invert polarity *)
			T_Axis.T_FileObj.sData[23]:='23:idxGrp:=16#7000;idxOff:=16#101;Len:=16#8;Value:=220';(* Driver Max Ref vel *)
			T_Axis.T_FileObj.sData[24]:='24:idxGrp:=16#7000;idxOff:=16#102;Len:=16#8;Value:=0.75';(* Driver output ration *)
			T_Axis.T_FileObj.sData[25]:='25:idxGrp:=16#6000;idxOff:=16#B;Len:=16#8;Value:=1';(* Ctrler pre-ctrl weighting *)
			T_Axis.T_FileObj.sData[26]:='26:idxGrp:=16#6000;idxOff:=16#102;LEN:=16#8;Value:=50';(* Ctrler Kv factor *)
			T_Axis.T_FileObj.sData[27]:='';
		(* spindle axis Beckhoff *)
		2:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#4000;idxOff:=16#27;LEN:=16#8;Value:=24000.0';(* Max velocity *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#4000;idxOff:=16#6;Len:=16#8;Value:=60.0';(* Vel Ref forward *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#4000;idxOff:=16#7;LEN:=16#8;Value:=60.0';(* Vel Ref backward *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#4000;idxOff:=16#101;Len:=16#8;Value:=42000.0';(* Acc *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#4000;idxOff:=16#102;Len:=16#8;Value:=42000.0';(* Dec *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#4000;idxOff:=16#103;Len:=16#8;Value:=98000.0';(* Jerk *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#4000;idxOff:=16#A;Len:=16#8;Value:=24000.0';(* Rapid traverse vel *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#5000;idxOff:=16#B;Len:=16#2;Value:=0';(* Enable min soft pos *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#5000;idxOff:=16#D;Len:=16#8;Value:=0';(* Min soft pos *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#5000;idxOff:=16#C;Len:=16#2;Value:=0';(* Enable max soft pos *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#5000;idxOff:=16#E;Len:=16#8;Value:=0';(* Max soft pos *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#6000;idxOff:=16#10;Len:=16#2;Value:=1';(* Enable pos lag *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6000;idxOff:=16#12;Len:=16#8;Value:=90.0';(* Max Pos lag *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#5000;idxOff:=16#8;Len:=16#2;Value:=0';(* Invert Enc counting *)
			T_Axis.T_FileObj.sData[15]:='15:idxGrp:=16#5000;idxOff:=16#6;Len:=16#8;Value:=0.00549';(* Enc scaling factor *)
			T_Axis.T_FileObj.sData[16]:='16:idxGrp:=16#5000;idxOff:=16#9;Len:=16#8;Value:=360';(* Enc modulo factor *)
			T_Axis.T_FileObj.sData[17]:='17:idxGrp:=16#5000;idxOff:=16#101;Len:=16#2;Value:=1';(* Enc dir for ref search *)
			T_Axis.T_FileObj.sData[18]:='18:idxGrp:=16#5000;idxOff:=16#102;Len:=16#2;Value:=0';(* Enc dir for sync impuls*)
			T_Axis.T_FileObj.sData[19]:='19:idxGrp:=16#5000;idxOff:=16#103;Len:=16#8;Value:=0';(* Enc ref value *)
			T_Axis.T_FileObj.sData[20]:='20:idxGrp:=16#5000;idxOff:=16#106;Len:=16#2;Value:=0';(* Enc Ext sync impuls *)
			T_Axis.T_FileObj.sData[21]:='21:idxGrp:=16#5000;idxOff:=16#107;Len:=16#4;Value:=5';(* Enc ref sequence *)
			T_Axis.T_FileObj.sData[22]:='22:idxGrp:=16#7000;idxOff:=16#6;Len:=16#2;Value:=0';(* Driver invert polarity *)
			T_Axis.T_FileObj.sData[23]:='23:idxGrp:=16#7000;idxOff:=16#101;Len:=16#8;Value:=26000';(* Driver Max Ref vel *)
			T_Axis.T_FileObj.sData[24]:='24:idxGrp:=16#7000;idxOff:=16#102;Len:=16#8;Value:=1';(* Driver output ration *)
			T_Axis.T_FileObj.sData[25]:='25:idxGrp:=16#6000;idxOff:=16#B;Len:=16#8;Value:=1';(* Ctrler pre-ctrl weighting *)
			T_Axis.T_FileObj.sData[26]:='26:idxGrp:=16#6000;idxOff:=16#102;LEN:=16#8;Value:=0.5';(* Ctrler Kv factor *)
			T_Axis.T_FileObj.sData[27]:='';
		(* spindle axis Beckhoff *)
		3:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#4000;idxOff:=16#27;LEN:=16#8;Value:=24000.0';(* Max velocity *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#4000;idxOff:=16#6;Len:=16#8;Value:=60.0';(* Vel Ref forward *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#4000;idxOff:=16#7;LEN:=16#8;Value:=60.0';(* Vel Ref backward *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#4000;idxOff:=16#101;Len:=16#8;Value:=42000.0';(* Acc *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#4000;idxOff:=16#102;Len:=16#8;Value:=42000.0';(* Dec *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#4000;idxOff:=16#103;Len:=16#8;Value:=98000.0';(* Jerk *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#4000;idxOff:=16#A;Len:=16#8;Value:=24000.0';(* Rapid traverse vel *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#5000;idxOff:=16#B;Len:=16#2;Value:=0';(* Enable min soft pos *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#5000;idxOff:=16#D;Len:=16#8;Value:=0';(* Min soft pos *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#5000;idxOff:=16#C;Len:=16#2;Value:=0';(* Enable max soft pos *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#5000;idxOff:=16#E;Len:=16#8;Value:=0';(* Max soft pos *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#6000;idxOff:=16#10;Len:=16#2;Value:=1';(* Enable pos lag *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6000;idxOff:=16#12;Len:=16#8;Value:=90.0';(* Max Pos lag *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#5000;idxOff:=16#8;Len:=16#2;Value:=0';(* Invert Enc counting *)
			T_Axis.T_FileObj.sData[15]:='15:idxGrp:=16#5000;idxOff:=16#6;Len:=16#8;Value:=0.00549';(* Enc scaling factor *)
			T_Axis.T_FileObj.sData[16]:='16:idxGrp:=16#5000;idxOff:=16#9;Len:=16#8;Value:=360';(* Enc modulo factor *)
			T_Axis.T_FileObj.sData[17]:='17:idxGrp:=16#5000;idxOff:=16#101;Len:=16#2;Value:=1';(* Enc dir for ref search *)
			T_Axis.T_FileObj.sData[18]:='18:idxGrp:=16#5000;idxOff:=16#102;Len:=16#2;Value:=0';(* Enc dir for sync impuls*)
			T_Axis.T_FileObj.sData[19]:='19:idxGrp:=16#5000;idxOff:=16#103;Len:=16#8;Value:=0';(* Enc ref value *)
			T_Axis.T_FileObj.sData[20]:='20:idxGrp:=16#5000;idxOff:=16#106;Len:=16#2;Value:=0';(* Enc Ext sync impuls *)
			T_Axis.T_FileObj.sData[21]:='21:idxGrp:=16#5000;idxOff:=16#107;Len:=16#4;Value:=5';(* Enc ref sequence *)
			T_Axis.T_FileObj.sData[22]:='22:idxGrp:=16#7000;idxOff:=16#6;Len:=16#2;Value:=1';(* Driver invert polarity *)
			T_Axis.T_FileObj.sData[23]:='23:idxGrp:=16#7000;idxOff:=16#101;Len:=16#8;Value:=26000';(* Driver Max Ref vel *)
			T_Axis.T_FileObj.sData[24]:='24:idxGrp:=16#7000;idxOff:=16#102;Len:=16#8;Value:=1';(* Driver output ration *)
			T_Axis.T_FileObj.sData[25]:='25:idxGrp:=16#6000;idxOff:=16#B;Len:=16#8;Value:=1';(* Ctrler pre-ctrl weighting *)
			T_Axis.T_FileObj.sData[26]:='26:idxGrp:=16#6000;idxOff:=16#102;LEN:=16#8;Value:=0.5';(* Ctrler Kv factor *)
			T_Axis.T_FileObj.sData[27]:='';
		END_CASE
	END_IF
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_LIVEVALUES_BECKHOFF
VAR_INPUT
	uiActualTorque: UINT;
	arxDigitalInput: ARRAY[1..8] OF BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
	T_AxisRefIn:NCTOPLC_AXLESTRUCT;
END_VAR
VAR
	i:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock read the actual value from the Beckhoff drive                                               ************)
(****************************************************************************************************************************************************)
(* return actual axis state *)
T_Axis.T_LiveValue.dwState:=T_AxisRefIn.nStateDWord;
(* return actual torque value *)
T_Axis.T_LiveValue.uiActualTorque:=uiActualTorque;
IF T_Axis.T_LiveValue.uiActualTorque > 16#7FFF THEN
	(* negativ value *)
	T_Axis.T_LiveValue.diActualTorqueCalc:=UINT_TO_DINT(T_Axis.T_LiveValue.uiActualTorque) - 65535;
ELSE
	(* positiv value *)
	T_Axis.T_LiveValue.diActualTorqueCalc:=UINT_TO_DINT(T_Axis.T_LiveValue.uiActualTorque);
END_IF
(* return actual velocity *)
T_Axis.T_LiveValue.lrActualVelocity:=T_AxisRefIn.fVeloIst;
(* ??? modif 06092005 *)
(* return actual position *)
IF T_Axis.T_Config_Gen.iTyp <>1 THEN
(* modulo position for rotativ axis*)
	T_Axis.T_LiveValue.lrActualPosition:=T_AxisRefIn.fModuloPosIst;
	T_Axis.T_LiveValue.lrActualPositionNotModulo:=T_AxisRefIn.fPosIst;
ELSE
(* counter value *)
	T_Axis.T_LiveValue.lrActualPosition:=T_AxisRefIn.fPosIst;
END_IF
T_Axis.T_LiveValue.lrSollPosition:=T_AxisRefIn.fPosSoll;
(* return actual position *)
(*T_Axis.T_LiveValue.lrActualPosition:=T_AxisRefIn.fPosIst;*)
(* ??? modif 06092005 *)
(* return the actual digital input state *)
T_Axis.T_LiveValue.bDigitalInput:=0;
FOR i := 0 TO 7 DO
	IF arxDigitalInput[i+1] THEN
		T_Axis.T_LiveValue.bDigitalInput:=T_Axis.T_LiveValue.bDigitalInput + MUX(i,1,2,4,8,16,32,64,128);
	END_IF
END_FOR;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_LIVEVALUES_ECOSTEP
VAR_INPUT
	iTypAxis:INT;	(* 1:ToolRotation, 2:ToolFeed, 3:GrindFeed *)
	rPrismaFactor:REAL;
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	rActualCurrent: REAL;
	rMultiplier: REAL;
	TONCheckTime: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock read the actual value from the EcoStep drive                                               ************)
(****************************************************************************************************************************************************)
(* Monitoring of the Internal Limit is Active *)
(* IF ((iTypAxis = 4) OR (iTypAxis = 5)) AND (T_Axis.T_Config_ObjFileValue.xSWLimitPos OR T_Axis.T_Config_ObjFileValue.xSWLimitNeg) THEN*)
IF (	T_Axis.T_Config_ObjFileValue.xSWLimitPos OR T_Axis.T_Config_ObjFileValue.xSWLimitNeg OR T_Axis.T_Config_ObjFileValue.xSWLimitPos OR	T_Axis.T_Config_ObjFileValue.xHWLimitNeg ) THEN	(* Only for ToolFeeder and GrindFeeder *)
	TONCheckTime(IN:=GETBIT32(T_Axis.T_TxPdoParameter.uiStatusWord,11),PT:=T#1000ms);
	IF TONCheckTime.Q  THEN			(* check if the internal limit bit for the statusword is set *)
		IF GETBIT32(T_Axis.T_TxPdoParameter.udiDigitalInput,21) THEN	(* DIN 6 form Ecostep Drive *)
			T_Axis.T_CtrleSingle.xHWLimitPos:=TRUE;
			T_Axis.T_CtrleSingle.xSWLimitPos:=FALSE;
		ELSE
			T_Axis.T_CtrleSingle.xHWLimitPos:=FALSE;
			T_Axis.T_CtrleSingle.xSWLimitPos:=TRUE;
		END_IF;
		IF GETBIT32(T_Axis.T_TxPdoParameter.udiDigitalInput,22) THEN	(* DIN 7 from Ecostep Drive *)
			T_Axis.T_CtrleSingle.xHWLimitNeg:=TRUE;
			T_Axis.T_CtrleSingle.xSWLimitNeg:=FALSE;
		ELSE
			T_Axis.T_CtrleSingle.xHWLimitNeg:=FALSE;
			T_Axis.T_CtrleSingle.xSWLimitNeg:=TRUE;
		END_IF;
	ELSE
		IF GETBIT32(T_Axis.T_TxPdoParameter.udiDigitalInput,21) THEN	(* DIN 6 form Ecostep Drive *)
			T_Axis.T_CtrleSingle.xHWLimitPos:=TRUE;
		ELSE
			T_Axis.T_CtrleSingle.xHWLimitPos:=FALSE;
		END_IF;
		IF GETBIT32(T_Axis.T_TxPdoParameter.udiDigitalInput,22) THEN	(* DIN 7 from Ecostep Drive *)
			T_Axis.T_CtrleSingle.xHWLimitNeg:=TRUE;
		ELSE
			T_Axis.T_CtrleSingle.xHWLimitNeg:=FALSE;
		END_IF;
		T_Axis.T_CtrleSingle.xSWLimitPos:=FALSE;
		T_Axis.T_CtrleSingle.xSWLimitNeg:=FALSE;
	END_IF;
ELSE
	T_Axis.T_CtrleSingle.xHWLimitPos:=FALSE;
	T_Axis.T_CtrleSingle.xSWLimitPos:=FALSE;
	T_Axis.T_CtrleSingle.xHWLimitNeg:=FALSE;
	T_Axis.T_CtrleSingle.xSWLimitNeg:=FALSE;
	TONCheckTime(IN:=FALSE);
END_IF;

(* Monitoring of the actual position of the Ecostep Drive in technical unit *)
IF xMicroRodActive THEN
	IF (T_Axis.T_CtrleSingle.lrScaleFactor <> 0.0) THEN
		IF (iTypAxis <> 5) THEN	(* No GrindFeed Axis *)
			T_Axis.T_LiveValue.lrActualPosition:=DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualPosition) / T_Axis.T_CtrleSingle.lrScaleFactor;
			T_Axis.T_LiveValue.lrActualPositionRelativ:=LMOD ( DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualPosition) / T_Axis.T_CtrleSingle.lrScaleFactor, 360.0);
		ELSE
			IF (rPrismaFactor <> 0.0) THEN
				T_Axis.T_LiveValue.lrActualPosition:=DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualPosition) / T_Axis.T_CtrleSingle.lrScaleFactor / rPrismaFactor;
			END_IF;
		END_IF;
	END_IF;
ELSE
	IF (T_Axis.T_CtrleSingle.lrScaleFactor <> 0.0) THEN
		IF (iTypAxis <> 5) THEN	(* No GrindFeed Axis *)
			T_Axis.T_LiveValue.lrActualPosition:=DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualPosition) / T_Axis.T_CtrleSingle.lrScaleFactor;
		ELSE
			IF (rPrismaFactor <> 0.0) THEN
				T_Axis.T_LiveValue.lrActualPosition:=DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualPosition) / T_Axis.T_CtrleSingle.lrScaleFactor / rPrismaFactor;
			END_IF;
		END_IF;
	END_IF;
END_IF
(* Monitoring of the actual position of the Ecostep Drive in increments *)
T_Axis.T_LiveValue.lrActualPositionNotModulo:=DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualPosition);

(* Monitoring of the actual speed of the Ecostep Drive *)
IF (iTypAxis = 1) OR (iTypAxis = 2) OR (iTypAxis = 3) THEN	(* rotative motion *)
	IF (T_Axis.T_CtrleSingle.lrScaleFactor <> 0.0) THEN
		T_Axis.T_LiveValue.lrActualVelocity:=((DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualVelocity) * 60.0)/(T_Axis.T_CtrleSingle.lrScaleFactor*64.0))/360.0;
	END_IF;
END_IF;
IF (iTypAxis = 4) OR (iTypAxis = 5) THEN	(* linear motion *)
	IF (T_Axis.T_CtrleSingle.lrScaleFactor <> 0.0) THEN
		T_Axis.T_LiveValue.lrActualVelocity:=ABS(DINT_TO_LREAL(T_Axis.T_TxPdoParameter.diActualVelocity)/(T_Axis.T_CtrleSingle.lrScaleFactor*64.0));
	END_IF;
END_IF;

(* Monitoring of the actual torque, 23S21 Motor constant of the Motortorque: 0.16Nm/A, max servodrive current 12A *)
IF (T_Axis.T_TxPdoParameter.iActualCurrent < 0) THEN
	rActualCurrent:=ABS(T_Axis.T_TxPdoParameter.iActualCurrent);
	rMultiplier:=-1.0;
ELSE
	rActualCurrent:=T_Axis.T_TxPdoParameter.iActualCurrent;
	rMultiplier:=1.0;
END_IF;
T_Axis.T_LiveValue.uiActualTorque:=REAL_TO_UINT(((12.0/2047.0) * rActualCurrent * 0.16) * 1000.0);	(* convert from Nm in mNm-->Absolut value *)
T_Axis.T_LiveValue.diActualTorqueCalc:=REAL_TO_DINT(((12.0/2047.0) * rActualCurrent * rMultiplier * 0.16) * 1000.0);	(* convert from Nm in mNm, positive and negative value *)

(* Monitoring of the statusword *)
T_Axis.T_LiveValue.dwState:=UINT_TO_DWORD(T_Axis.T_TxPdoParameter.uiStatusWord);


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_MULTI_BECKHOFF
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_AxisMaster:ST_AXIS;
	T_AxisSlave:ST_AXIS;
	T_AxisMasterRefIn:NCTOPLC_AXLESTRUCT;
	T_AxisSlaveRefIn:NCTOPLC_AXLESTRUCT;
END_VAR
VAR
(* block function *)
	fbAxisMasterSlaveOn:MC_GearIn;
	fbAxisMasterSlaveOff:MC_GearOut;
(* variable *)
	xGearIn:BOOL:=FALSE;
	xGearOut:BOOL:=FALSE;
	xConfirmResetFB:BOOL:=FALSE;
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                   This Functionblock is the driver for the Beckhoff Axis for Master/Slave                                      ************)
(****************************************************************************************************************************************************)
(* Reset block function *)
	RisingEdgeResetFB(CLK:=T_AxisMaster.T_CtrleMulti.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* Init. block function *)
		fbAxisMasterSlaveOn(	Execute:=FALSE,
							Master:=T_AxisMasterRefIn,
							Slave:=T_AxisSlaveRefIn);
		fbAxisMasterSlaveOff(	Execute:=FALSE,
							Slave:=T_AxisSlaveRefIn);
	(* Init. variable *)
		xGearIn:=FALSE;
		xGearOut:=FALSE;
	(* init. structure *)
		T_AxisMaster.T_CtrleMulti.iFunction:=0;
		T_AxisMaster.T_CtrleMulti.iNumerator:=1;
		T_AxisMaster.T_CtrleMulti.uiDenominator:=1;
		T_AxisMaster.T_CtrleMulti.xDone:=FALSE;
		T_AxisMaster.T_CtrleMulti.xErr:=FALSE;
		T_AxisMaster.T_CtrleMulti.udiErrorID:=0;
		(* set done flag *)
		xConfirmResetFB:=TRUE;
		(* exit function bloc *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_AxisMaster.T_CtrleMulti.xDone:=TRUE;
			T_AxisMaster.T_CtrleMulti.xErr:=FALSE;
			T_AxisMaster.T_CtrleMulti.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* Execute *)
	RisingEdgeExecute(CLK:=T_AxisMaster.T_CtrleMulti.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_AxisMaster.T_CtrleMulti.iFunction OF
		(* activ master-slave *)
		1:	xGearIn:=TRUE;
		(* desactiv master-slave *)
		2: 	xGearOut:=TRUE;
		ELSE
		(* function not implemented *)
			T_AxisMaster.T_CtrleMulti.xDone:=FALSE;
			T_AxisMaster.T_CtrleMulti.xErr:=TRUE;
			T_AxisMaster.T_CtrleMulti.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_AxisMaster.T_CtrleMulti.xDone:=FALSE;
		T_AxisMaster.T_CtrleMulti.xErr:=FALSE;
		T_AxisMaster.T_CtrleMulti.udiErrorID:=0;
	END_IF

(* GearIn *)
	IF xGearIn THEN
		fbAxisMasterSlaveOn(	Execute:=TRUE,
							RatioNumerator:=T_AxisMaster.T_CtrleMulti.iNumerator,
							RatioDenominator:=T_AxisMaster.T_CtrleMulti.uiDenominator,
							Acceleration:=T_AxisMaster.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_AxisMaster.T_CtrleSingle.lrDecceleration,
							Jerk:=T_AxisMaster.T_CtrleSingle.lrJerk,
							Master:=T_AxisMasterRefIn,
							Slave:=T_AxisSlaveRefIn);
		IF fbAxisMasterSlaveOn.InGear OR fbAxisMasterSlaveOn.Error THEN
			T_AxisMaster.T_CtrleMulti.xDone:= fbAxisMasterSlaveOn.InGear;
			T_AxisMaster.T_CtrleMulti.xErr:=fbAxisMasterSlaveOn.Error;
			T_AxisMaster.T_CtrleMulti.udiErrorID:=fbAxisMasterSlaveOn.ErrorID;
			(* set flag gearin off *)
			xGearIn:=FALSE;
		END_IF
	ELSE
		fbAxisMasterSlaveOn(	Execute:=FALSE,
							Master:=T_AxisMasterRefIn,
							Slave:=T_AxisSlaveRefIn);
	END_IF

(* GearOut *)
	IF xGearOut THEN
		fbAxisMasterSlaveOff(	Execute:=TRUE,
							Slave:=T_AxisSlaveRefIn);
		IF fbAxisMasterSlaveOff.Done OR fbAxisMasterSlaveOff.Error THEN
			T_AxisMaster.T_CtrleMulti.xDone:= fbAxisMasterSlaveOff.Done;
			T_AxisMaster.T_CtrleMulti.xErr:=fbAxisMasterSlaveOff.Error;
			T_AxisMaster.T_CtrleMulti.udiErrorID:=fbAxisMasterSlaveOff.ErrorID;
			(* set flag gearout off *)
			xGearOut:=FALSE;
		END_IF
	ELSE
		fbAxisMasterSlaveOff(	Execute:=FALSE,
							Slave:=T_AxisSlaveRefIn);
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_SINGLE_BECKHOFF
VAR_INPUT
	xHWLimitPos:BOOL:=FALSE;
	xHWLimitNeg:BOOL:=FALSE;
	xRefHoming:BOOL:=FALSE;
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
	T_AxisRefIn:NCTOPLC_AXLESTRUCT;
	T_AxisRefOut:PLCTONC_AXLESTRUCT;
	T_HDD:ST_HDD;
END_VAR
VAR
(* Axis function block *)
	fbAxisReset:MC_Reset;
	fbAxisPower:MC_Power;
	fbAxisStop:MC_Stop;
	fbAxisMoveVelocity:MC_MoveVelocity;
	fbAxisMoveAbsolute:MC_MoveAbsolute;
	fbAxisMoveRelative:MC_MoveRelative;
	fbAxisMoveModulo:MC_MoveModulo;
	fbAxisHoming:MC_Home;
	fbAxisSetOverride:MC_SetOverride;
	fbAxisSetPosition:MC_SetActualPosition;
	fbAxisNewPosAndVel:MC_NewPosAndVelo;
	fbAxisSetReferenceFlag:MC_SetReferenceFlag;
	fbDefaultAxisPara:FB_DEFAULT_AXISVALUE;
	fbAdsWrite:ADSWRITE;
	fbADS_ReadWriteString:ADSRDWRTEX;
	fb_ConvertParaAxis:FB_CONVERT_PARA_AXIS;
	fbExtSetPointGenDisable:MC_ExtSetPointGenDisable;
	fbExtSetPointGenEnable:MC_ExtSetPointGenEnable;

(* variable *)
	xConfirmResetFB:BOOL:=FALSE;
	xResetAxis:BOOL:=FALSE;
	xReadFile:BOOL:=FALSE;
	xPowerOn:BOOL:=FALSE;
	xPowerOff:BOOL:=FALSE;
	xStop:BOOL:=FALSE;
	xMoveVel:BOOL:=FALSE;
	iDirectionVel:INT:=1;
	rVelocity:REAL:=0;
	xMoveAbs:BOOL:=FALSE;
	xMoveRel:BOOL:=FALSE;
	xMoveModulo:BOOL:=FALSE;
	xHoming:BOOL:=FALSE;
	xOverride:BOOL:=FALSE;
	xSetPosition:BOOL:=FALSE;
	xNewVelocity:BOOL:=FALSE;
	xNewPosition:BOOL:=FALSE;
	xCalcAngleRefIndex: BOOL:=FALSE;
	xSetReferenceFlag:BOOL:=FALSE;
	xResetReferenceFlag:BOOL:=FALSE;
	xDefaultAxisParameter:BOOL:=FALSE;
	xSendAxisParameter:BOOL:=FALSE;
	iPtrAxisParameter:INT:=0;
	xSendAxisString:BOOL:=FALSE;
	sSendAxis:STRING:='';
	sReturnAxis:STRING:='';
	iStepSendPara:INT:=0;
	xRestoreAxisPower:BOOL:=FALSE;
	iStepFile:INT:=0;
	xWriteFile: BOOL:=FALSE;
	xCtrlePositionOn:BOOL:=FALSE;
	xCtrlePositionOff:BOOL:=FALSE;
	xOscillation:BOOL:=FALSE;
	iStepOsc:INT:=0;
	iOscCounter:INT:=0;
	iStepResetFB:INT:=0;
	dwOldOverride:DWORD:=100;
	lrOverrideVel:LREAL;
(* timer *)
	TimerOutSendPara:TON;
	TimerFileLocked:TON;

(* trigger *)
	RisingEdgeStop:R_TRIG;
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	RisingEdgePowerOn:R_TRIG;
	RisingEdgePowerOff:R_TRIG;

(* Temp variable *)
	xTmp:BOOL:=FALSE;
	i:INT;
	wTmp:WORD:=0;
	dwTmp:DWORD:=0;
	dwAdrVar:DWORD:=0;
	sTmp:STRING(255);
	rTmpFrequence:REAL;
	lrTmpVelocity:LREAL;
	TimerCommTimeLeft:TON;
	xStartTimerComm:BOOL:=FALSE;
	tTimeCommLeft:TIME;
	TimerCommTimeLeft1:TON;
	xStartTimerComm1:BOOL:=FALSE;
	tTimeCommLeft1:TIME;
	sDeleteData: ARRAY[1..csiMaxAxisFileObj] OF STRING(120);
	xMovement: BOOL;
	xNoHWError: BOOL;
	iStepCalcRefIndex: INT;
	xCheckRefState: BOOL;
	iTmpFctNr: INT;
	lrTechUnitPerMotorTurn: LREAL;	(* Gilt nur für das Aufsuchen des Reference Index-->Die Technische Einheit muss angegeben werden, damit eine Motorrotation durchgeführt werden kann z.B. 2.5mm/U_Motor  oder 30Grad/U_Motor*)
	xSendBlock: BOOL;
	lrCapturePosition: LREAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                               This Functionblock is the driver for the Beckhoff Axis                                                           ************)
(****************************************************************************************************************************************************)
(* Test Timer PUM *)
TimerCommTimeLeft(IN:=xStartTimerComm,PT:=T#99999s);
TimerCommTimeLeft1(IN:=xStartTimerComm1,PT:=T#99999s);
(* reset block function *)
	RisingEdgeResetFB(CLK:=T_Axis.T_CtrleSingle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* Init. block function *)
		fbAxisReset(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisPower(	Enable:=FALSE,
					AxisRefIn:=T_AxisRefIn,
					AxisRefOut:=T_AxisRefOut);
		fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveVelocity(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveAbsolute(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveModulo(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisHoming(	Execute:=FALSE,
						Axis:=T_AxisRefIn,
						AxisOut:=T_AxisRefOut);
		fbAxisSetOverride(Execute:=FALSE,
						AxisRefIn:=T_AxisRefIn,
						AxisRefOut:=T_AxisRefOut);
		fbAxisSetPosition(	Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisNewPosAndVel(	Execute:=FALSE,
							Axis:=T_AxisRefIn);
		fbAdsWrite(WRITE:=FALSE);
		fbADS_ReadWriteString(WRTRD:=FALSE);
	(* timer *)
		TimerOutSendPara(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		xResetAxis:=FALSE;
		xReadFile:=FALSE;
		xPowerOn:=FALSE;
		xPowerOff:=FALSE;
		xStop:=FALSE;
		xMoveVel:=FALSE;
		iDirectionVel:=1;
		rVelocity:=0;
		xMoveAbs:=FALSE;
		xMoveRel:=FALSE;
		xMoveModulo:=FALSE;
		xHoming:=FALSE;
		xOverride:=FALSE;
		xSetPosition:=FALSE;
		xNewVelocity:=FALSE;
		xNewPosition:=FALSE;
		xCalcAngleRefIndex:=FALSE;
		xSetReferenceFlag:=FALSE;
		xResetReferenceFlag:=FALSE;
		xDefaultAxisParameter:=FALSE;
		xSendAxisParameter:=FALSE;
		iPtrAxisParameter:=1;
		xSendAxisString:=FALSE;
		iStepSendPara:=0;
		xRestoreAxisPower:=FALSE;
		xWriteFile:=FALSE;
		iStepFile:=0;
		xCtrlePositionOn:=FALSE;
		xCtrlePositionOff:=FALSE;
		xOscillation:=FALSE;
		iStepOsc:=0;
		iOscCounter:=0;
		iStepCalcRefIndex:=0;
	(* int. structure *)
		T_Axis.T_CtrleSingle.dwOverride:=100;
		T_Axis.T_CtrleSingle.iFunction:=0;
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		T_Axis.T_CtrleSingle.xPower:=FALSE;
		T_Axis.T_CtrleSingle.xReady:=FALSE;
		T_Axis.T_CtrleSingle.xNotMoving:=FALSE;
		T_Axis.T_CtrleSingle.xRef:=FALSE;
		T_Axis.T_CtrleSingle.xSlave:=FALSE;
		T_Axis.T_CtrleSingle.xConstantVel:=FALSE;
		T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
		T_Axis.T_CtrleSingle.xDriveTorque:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* disable status flag *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		(* exit function bloc *)
		(* Test Timer PUM *)
		xStartTimerComm:=FALSE;
		xStartTimerComm1:=FALSE;
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* return axis state *)
	T_Axis.T_CtrleSingle.xReady:=GETBIT32(T_AxisRefIn.nStateDWord,0);
	T_Axis.T_CtrleSingle.xRef:=GETBIT32(T_AxisRefIn.nStateDWord,1);
	T_Axis.T_CtrleSingle.xNotMoving:=GETBIT32(T_AxisRefIn.nStateDWord,2);
	T_Axis.T_CtrleSingle.xSlave:=GETBIT32(T_AxisRefIn.nStateDWord,5);
	T_Axis.T_CtrleSingle.xConstantVel:=GETBIT32(T_AxisRefIn.nStateDWord,12);
	T_Axis.T_CtrleSingle.xSpindleBlocked:=NOT(T_Axis.T_CtrleSingle.xNotMoving) AND (ABS(T_Axis.T_LiveValue.lrActualVelocity) = 0);
	IF GETBIT32(T_AxisRefIn.nStateDWord,31) THEN
	(* error servo *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=TRUE;
		T_Axis.T_CtrleSingle.udiErrorID:=T_AxisRefIn.nErrorCode;
	END_IF

(* Timer *)
	TimerOutSendPara(IN:=TRUE, PT:=T#10S);
	TimerFileLocked(IN:=TRUE, PT:=T#10S);

(* determin if SW limit detection is activ *)
	(* positiv limit *)
	T_Axis.T_CtrleSingle.xSWLimitPos:=FALSE;
	IF (T_AxisRefIn.nOpModeDWord AND 16#80000) = 16#80000 THEN
		IF T_Axis.T_LiveValue.lrActualPosition >= T_Axis.T_Config_ObjFileValue.lrSWLimitPos THEN
			T_Axis.T_CtrleSingle.xSWLimitPos:=TRUE;
		END_IF
	END_IF
	(* negativ limit *)
	T_Axis.T_CtrleSingle.xSWLimitNeg:=FALSE;
	IF (T_AxisRefIn.nOpModeDWord AND 16#40000) = 16#40000 THEN
		IF T_Axis.T_LiveValue.lrActualPosition <= T_Axis.T_Config_ObjFileValue.lrSWLimitNeg THEN
			T_Axis.T_CtrleSingle.xSWLimitNeg:=TRUE;
		END_IF
	END_IF

(* detection hardware limit *)
	(* positiv limit *)
	IF T_Axis.T_Config_Setting.xHardwareLimitPos THEN T_Axis.T_CtrleSingle.xHWLimitPos:=NOT(xHWLimitPos);
	ELSE T_Axis.T_CtrleSingle.xHWLimitPos:=FALSE; END_IF
	(* negativ limit *)
	IF T_Axis.T_Config_Setting.xHardwareLimitNeg THEN T_Axis.T_CtrleSingle.xHWLimitNeg:=NOT(xHWLimitNeg);
	ELSE T_Axis.T_CtrleSingle.xHWLimitNeg:=FALSE; END_IF

	(* monitor hardware limit *)
	RisingEdgeStop(CLK:=T_Axis.T_CtrleSingle.xHWLimitPos OR T_Axis.T_CtrleSingle.xHWLimitNeg);
	IF NOT(T_Axis.T_CtrleSingle.xNotMoving) THEN
		IF RisingEdgeStop.Q THEN
		(* set decceleration ramp and make a stop *)
			xStop:=TRUE;
			IF T_Axis.T_Config_Setting.lrHWLimitDecceleration <> 0 THEN
				T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_Setting.lrHWLimitDecceleration;
			END_IF
		END_IF
	END_IF

(* detection start *)
	RisingEdgeExecute(CLK:=T_Axis.T_CtrleSingle.xExecute);
	IF RisingEdgeExecute.Q THEN
		RisingEdgeExecute(CLK:=FALSE);
		IF xStop AND (T_Axis.T_CtrleSingle.iFunction <> 1) THEN
		(* can not execute a function when 'Stop' activ, except 'Reset' *)
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:=TRUE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F100;
			RETURN;
		END_IF
		CASE T_Axis.T_CtrleSingle.iFunction OF
		(* Reset *)
		1:	xResetAxis:=TRUE;
			iStepResetFB:=1;
			iTmpFctNr:=1;
		(* Init *)
		2:	xReadFile:=TRUE;
			iStepFile:=1;
			iTmpFctNr:=2;
		(* Power ON *)
		3:	IF NOT(xPowerOn) THEN
				xPowerOn:=TRUE;
				xPowerOff:=NOT(xPowerOn);
				iTmpFctNr:=3;
			ELSE
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				iTmpFctNr:=3;
				RETURN;
			END_IF;
		(* Power Off *)
		4:	IF xPowerOn THEN
				xPowerOff:=TRUE;
				xPowerOn:=NOT(xPowerOff);
				iTmpFctNr:=4;
			ELSE
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				iTmpFctNr:=4;
				RETURN;
			END_IF;
		(* Stop *)
		5: 	xStop:=TRUE;
			fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn);
			xStartTimerComm1:=TRUE;
			iTmpFctNr:=5;
		(* Velocity *)
		6:	xMoveVel:=TRUE;
			iTmpFctNr:=6;
		(* Absolute *)
		7:	xMoveAbs:=TRUE;
			iTmpFctNr:=7;
		(* Relative *)
		8:	xMoveRel:=TRUE;
			iTmpFctNr:=8;
		(* homing *)
		9:	xHoming:=TRUE;
			iTmpFctNr:=9;
		(* override *)
		10:	xOverride:=TRUE;
			iTmpFctNr:=10;
		(* set position *)
		11:	xSetPosition:=TRUE;
			iTmpFctNr:=11;
		(* change current speed *)
		12:	xNewVelocity:=TRUE;
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=TRUE;
			IF xMoveAbs OR xMoveRel OR xMoveModulo OR xOscillation THEN	(* Muss unterschieden werden können, ob Positionsfahrt oder Velocitymode ausgeführt wird *)
				xMovement:=TRUE;
			ELSE
				xMovement:=FALSE;
			END_IF;
			xStartTimerComm:=TRUE;
		(* Set reference flag *)
		13:	xSetReferenceFlag:=TRUE;
			iTmpFctNr:=13;
		(* reset reference flag *)
		14:	xResetReferenceFlag:=TRUE;
			iTmpFctNr:=14;
		(* control position On *)
		15:	xCtrlePositionOn:=TRUE;
			iTmpFctNr:=15;
		(* control position off *)
		16:	xCtrlePositionOff:=TRUE;
			iTmpFctNr:=16;
		(* oscillation *)
		17:	xOscillation:=TRUE;
			iTmpFctNr:=17;
		(* change position *)
		18:	xNewPosition:=TRUE;
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=TRUE;
		(* calcultate angle between Reference Index and Reference Sensor *)
		19:	xCalcAngleRefIndex:=TRUE;
			iTmpFctNr:=19;
		(* Default parameter value *)
		20:	xDefaultAxisParameter:=TRUE;
			iTmpFctNr:=20;
		(* Send Parameter *)
		21: 	xSendAxisParameter:=TRUE;
			iPtrAxisParameter:=1;
			iStepSendPara:=1;
			(* copy parameter value *)
			fbDefaultAxisPara(xDefaultValue:=FALSE,T_Axis:=T_Axis);
			iTmpFctNr:=21;
		(* send string *)
		22: 	xSendAxisString:=TRUE;
			sSendAxis:='';
			sReturnAxis:='';
			iTmpFctNr:=22;
		(* save parameter to file *)
		23:	xWriteFile:=TRUE;
			iStepFile:=11;
			iTmpFctNr:=23;
		(* Move Modulo *)
		24:	xMoveModulo:=TRUE;
			iTmpFctNr:=24;
		ELSE
		(* function not implemented *)
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:=TRUE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F000;
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		(* init variable *)
		dwOldOverride:=16#FFFF;
		(* Exit FB *)
		RETURN;
	END_IF

(* Override *)
	IF dwOldOverride <>T_Axis.T_CtrleSingle.dwOverride THEN
		lrOverrideVel:=T_Axis.T_CtrleSingle.lrVelocity * T_Axis.T_CtrleSingle.dwOverride / 100;
		(* confirm velocity setting *)
		dwOldOverride:=T_Axis.T_CtrleSingle.dwOverride;
	END_IF

(* Reset function *)
	IF xResetAxis THEN
		CASE iStepResetFB OF
		(* check state *)
		1:	xRestoreAxisPower:=FALSE;
			IF xPowerOn THEN iStepResetFB:=10; ELSE iStepResetFB:=20; END_IF
		(* power off *)
		10:	xPowerOff:=TRUE;
			xPowerOn:=NOT(xPowerOff);
			xRestoreAxisPower:=TRUE;
			(* next step *)
			iStepResetFB:=20;
		(* wait power off flag *)
		20:	IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
				fbAxisReset(Execute:=TRUE, Axis:=T_AxisRefIn);
				IF fbAxisReset.Done OR fbAxisReset.Error THEN
					 IF fbAxisReset.Error THEN
						T_Axis.T_CtrleSingle.xDone:=fbAxisReset.Done;
						T_Axis.T_CtrleSingle.xErr:= fbAxisReset.Error;
						T_Axis.T_CtrleSingle.udiErrorID:=fbAxisReset.ErrorID;
					ELSE
					(* activ stop *)
						xStop:=TRUE;
						(* flag reset off only if the power has not to be recovered *)
						IF NOT(xRestoreAxisPower) THEN xResetAxis:=FALSE; END_IF
					END_IF
					(* reset flag busy *)
					T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
					(* init. FB reset *)
					fbAxisReset(Execute:=FALSE, Axis:=T_AxisRefIn);
					(* next step *)
					iStepResetFB:=30;
				END_IF
			END_IF
		(* wait stop done *)
		30:	IF NOT(xStop) THEN iStepResetFB:=40; END_IF
		(* set power on *)
		40:	xPowerOff:=FALSE;
			xPowerOn:=NOT(xPowerOff);
			(* next step *)
			iStepResetFB:=50;
		(* wait power on flag *)
		50:	IF T_Axis.T_CtrleSingle.xPower THEN
			(* confirm reset *)
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				(* init. variable *)
				xResetAxis:=FALSE;
			END_IF
		END_CASE
	ELSE fbAxisReset(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Initialisation function *)
	IF xReadFile OR xWriteFile THEN
		CASE iStepFile OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			T_Axis.T_FileObj.sData:=sDeleteData;
			(* next step *)
			iStepFile:=iStepFile+1;
		(* start read *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xLocked) THEN
			(* activ read axis nc parameter *)
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_HDD.T_Ctrle.xLocked :=TRUE;
				T_HDD.T_Ctrle.iFunction:=1;
				sTmp:=CONCAT(cssRootPLC,'\Hard Disk\Bore800\Axis\File\');
				sTmp:=CONCAT(sTmp, T_Axis.T_Config_Gen.sDeviceFileName);
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				(* next step *)
				iStepFile:=iStepFile+1;
			ELSE
			(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFile:=91;
				END_IF
			END_IF
		(* wait done or error *)
		3:	IF T_HDD.T_Ctrle.xDone OR T_HDD.T_Ctrle.xErr THEN
				IF T_HDD.T_Ctrle.xErr  THEN
				(* active step error *)
					iStepFile:=93;
				ELSE
				(* next step, init convert value *)
					iStepFile:=iStepFile+1;
					(* copy data from file *)
					i:=1;
					WHILE T_HDD.T_Data.sData[i] <> '' AND i <=csiMaxAxisFileObj AND i <= csiMaxFileLine DO
						T_Axis.T_FileObj.sData[i]:=T_HDD.T_Data.sData[i];
						i:=i+1;
					END_WHILE
					(* erase last line +1 *)
					IF i < csiMaxAxisFileObj THEN T_Axis.T_FileObj.sData[i+1]:=''; END_IF
				END_IF
			END_IF
		(* init. convert *)
		4:	fb_ConvertParaAxis(	xStart:=FALSE,
								T_Axis:=T_Axis);
			(* next step, convert value *)
			iStepFile:=iStepFile+1;
		(* convert value *)
		5:	fb_ConvertParaAxis(	xStart:=TRUE,
								iConversion:=0,
									sDeviceName:='Beckhoff',
									T_Axis:=T_Axis);
			IF fb_ConvertParaAxis.xDone OR fb_ConvertParaAxis.xError THEN
				IF (T_Axis.T_Config_Setting.rHCRampDeceleration = 0) THEN T_Axis.T_Config_Setting.rHCRampDeceleration:=20000.0; END_IF;
				IF (T_Axis.T_Config_Setting.rHCRampJerk = 0) THEN T_Axis.T_Config_Setting.rHCRampJerk:=7000.0; END_IF;
				IF fb_ConvertParaAxis.xError THEN
					fb_ConvertParaAxis(	xStart:=FALSE,
										T_Axis:=T_Axis);
					(* active step error *)
					iStepFile:=94;
				ELSE
					(* activ state read successfull *)
					iStepFile:=98;
				END_IF;
			END_IF;
		(* start time out *)
		11:	TimerFileLocked(IN:=FALSE);
			(* next step *)
			iStepFile:=iStepFile+1;
		(* prepare data *)
		12:	(* copy data *)
			i:=1;
			WHILE T_Axis.T_FileObj.sData[i] <> '' AND i <= csiMaxAxisFileObj AND i <= csiMaxFileLine DO
				T_HDD.T_Data.sData[i]:=T_Axis.T_FileObj.sData[i];
				(* next line *)
				i:=i+1;
			END_WHILE
			(* next step *)
			iStepFile:=iStepFile+1;
		(* start write file *)
		13:	IF T_HDD.T_Ctrle.xDone  AND NOT(T_HDD.T_Ctrle.xLocked) THEN
			(* activ write axis parameter *)
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_HDD.T_Ctrle.xLocked :=TRUE;
				T_HDD.T_Ctrle.iFunction:=3;
				sTmp:=CONCAT(cssRootPLC,'\Hard Disk\Bore800\Axis\File\');
				sTmp:=CONCAT(sTmp, T_Axis.T_Config_Gen.sDeviceFileName);
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				(* next step *)
				iStepFile:=iStepFile+1;
			ELSE
			(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					iStepFile:=92;
				END_IF
			END_IF
		(* wait done or error *)
		14:	IF T_HDD.T_Ctrle.xDone OR T_HDD.T_Ctrle.xErr THEN
				IF T_HDD.T_Ctrle.xErr  THEN
				(* active step error *)
					iStepFile:=93;
				ELSE
				(* activ state write successfull *)
					iStepFile:=98;
				END_IF
			END_IF
		(* start read error *)
		91:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F104;
			(* last step *)
			iStepFile:=99;
		(* start write error *)
		92:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F105;
			(* last step *)
			iStepFile:=99;
		(* block function error *)
		93:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=T_HDD.T_Ctrle.udiErrorID;
			(* last step *)
			iStepFile:=99;
		(* Config File Error *)
		94:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F202;
			(* last step *)
			iStepFile:=99;
		(* init. successfully ended *)
		98:	T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			(* last step *)
			iStepFile:=99;
		(* init. done *)
		99:	IF T_HDD.T_Ctrle.xErr AND NOT(T_HDD.T_Ctrle.xReset)THEN
				IF (T_Axis.T_CtrleSingle.udiErrorID = 1804) THEN
					T_Axis.T_CtrleSingle.udiErrorID:=16#F201;		(* File not Found *)
				END_IF;
				T_HDD.T_Ctrle.xReset:=TRUE;
				RETURN;
			END_IF;
			IF NOT(T_HDD.T_Ctrle.xDone) THEN
				RETURN;
			END_IF;
			IF NOT(T_Axis.T_CtrleSingle.xDone) THEN
				T_Axis.T_CtrleSingle.xErr:= TRUE;
			END_IF;
			xReadFile:=FALSE;
			xWriteFile:=FALSE;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			(* locked off *)
			T_HDD.T_Ctrle.xLocked:=FALSE;
		ELSE
;
		END_CASE
	END_IF

(* Power function *)
	RisingEdgePowerOn(CLK:=xPowerOn);
	RisingEdgePowerOff(CLK:=xPowerOff);
	IF xPowerOn THEN
		fbAxisPower(	Enable:=TRUE,
					Enable_Positive:=TRUE,
					Enable_Negative:=TRUE,
					AxisRefIn:=T_AxisRefIn,
					AxisRefOut:=T_AxisRefOut);
		T_Axis.T_CtrleSingle.xPower:=fbAxisPower.Status;
		(* desactiv control flag during sending axis parameter and during reset  *)
		IF NOT(xSendAxisParameter) AND NOT(xResetAxis) THEN
			IF RisingEdgePowerOn.Q AND  NOT(fbAxisPower.Error) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
			END_IF
			IF  fbAxisPower.Error THEN
				T_Axis.T_CtrleSingle.xErr:= fbAxisPower.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisPower.ErrorID;
			END_IF
		END_IF
	END_IF
	IF xPowerOff THEN
		fbAxisPower(	Enable:=FALSE,
					AxisRefIn:=T_AxisRefIn,
					AxisRefOut:=T_AxisRefOut);
		T_Axis.T_CtrleSingle.xPower:=fbAxisPower.Status;
		(* desactiv control flag during sending axis parameter and during reset *)
		IF NOT(xSendAxisParameter) AND NOT(xResetAxis) THEN
			IF RisingEdgePowerOff.Q AND NOT( fbAxisPower.Error) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
			END_IF
			IF  fbAxisPower.Error THEN
				T_Axis.T_CtrleSingle.xErr:= fbAxisPower.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisPower.ErrorID;
			END_IF
		END_IF
	END_IF

(* Stop *)
	IF xStop THEN
		(* init. FB vel / abs / rel *)
		xMoveVel:=FALSE;
		xMoveRel:=FALSE;
		xMoveAbs:=FALSE;
		xMoveModulo:=FALSE;
		xNewVelocity:=FALSE;
		xNewPosition:=FALSE;
		xStartTimerComm:=FALSE;
		xHoming:=FALSE;
		IF (iTmpFctNr <> 19) THEN
			xCalcAngleRefIndex:=FALSE;
		END_IF;
		(* flag oscillation off *)
		xOscillation:=FALSE;
		(* FB stop *)
		fbAxisStop(	Execute:=TRUE,
					Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
					Jerk:=T_Axis.T_CtrleSingle.lrJerk,
					Axis:=T_AxisRefIn);
		(* select bit not moving *)
		dwTmp:=T_Axis.T_LiveValue.dwState AND 16#4;
		IF (fbAxisStop.Done AND dwTmp = 16#4) OR fbAxisStop.Error THEN
			IF fbAxisStop.Error OR (NOT(xResetAxis) AND NOT(xCalcAngleRefIndex) )THEN
				xResetAxis:=xCalcAngleRefIndex:=FALSE;
			(* confirm reset if error activ or if reset is not activ *)
				T_Axis.T_CtrleSingle.xDone:=fbAxisStop.Done;
				T_Axis.T_CtrleSingle.xErr:= fbAxisStop.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisStop.ErrorID;
				(* desactiv reset axis *)
				IF xResetAxis THEN xResetAxis:=FALSE; END_IF
			END_IF
			(* flag stop off *)
			xStop:=FALSE;
			tTimeCommLeft1:=TimerCommTimeLeft1.ET;
			xStartTimerComm1:=FALSE;
			(* reset flag busy *)
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
			(* Init. Stop FB *)
			fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Velocity *)
	IF xMoveVel AND NOT(fbAxisMoveVelocity.InVelocity) THEN
		IF T_Axis.T_CtrleSingle.lrVelocity >= 0 THEN
		(* positiv direction =1*)
			iDirectionVel:=MC_Positive_Direction;
		ELSE
		(* negativ direction =3*)
			iDirectionVel:=MC_Negative_Direction;
		END_IF
		rVelocity:=ABS(lrOverrideVel);
		fbAxisMoveVelocity(	Execute:=TRUE,
							Velocity:=rVelocity,
							Acceleration:=T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Direction:=iDirectionVel,
							Axis:=T_AxisRefIn);
		IF fbAxisMoveVelocity.InVelocity OR fbAxisMoveVelocity.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisMoveVelocity.InVelocity;
			T_Axis.T_CtrleSingle.xErr:= fbAxisMoveVelocity.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveVelocity.ErrorID;
			(* flag velocity off *)
			xMoveVel:=FALSE;
			(* Init. FB Move *)
			fbAxisMoveVelocity(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveVelocity(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Move absolute *)
	IF xMoveAbs THEN
		fbAxisMoveAbsolute(	Execute:=TRUE,
							Position:=T_Axis.T_CtrleSingle.lrPosition,
							Velocity:=ABS(lrOverrideVel),
							Acceleration:=T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Axis:=T_AxisRefIn);
		IF fbAxisMoveAbsolute.Done OR fbAxisMoveAbsolute.Error THEN
			IF NOT(xCalcAngleRefIndex) OR fbAxisMoveAbsolute.Error THEN
				xCalcAngleRefIndex:=FALSE;
				T_Axis.T_CtrleSingle.xDone:=fbAxisMoveAbsolute.Done;
				T_Axis.T_CtrleSingle.xErr:= fbAxisMoveAbsolute.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveAbsolute.ErrorID;
				(* test if move has been stopped *)
				IF fbAxisMoveAbsolute.ErrorID = 16#4B00 THEN
				(* clear error *)
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				END_IF
			END_IF;
			(* flag move absolute off *)
			xMoveAbs:=FALSE;
			(* init. FB *)
			fbAxisMoveAbsolute(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveAbsolute(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Move relative *)
	IF xMoveRel THEN
		fbAxisMoveRelative(	Execute:=TRUE,
							Distance:=T_Axis.T_CtrleSingle.lrDistance,
							Velocity:=lrOverrideVel,
							Acceleration:=T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Axis:=T_AxisRefIn);
		IF fbAxisMoveRelative.Done OR fbAxisMoveRelative.Error THEN
			IF (NOT(xOscillation) AND NOT(xCalcAngleRefIndex)) OR fbAxisMoveRelative.Error THEN
				xOscillation:=xCalcAngleRefIndex:=FALSE;
			(* normal control variable settings if oscillation disable *)
				T_Axis.T_CtrleSingle.xDone:=fbAxisMoveRelative.Done;
				T_Axis.T_CtrleSingle.xErr:= fbAxisMoveRelative.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveRelative.ErrorID;
				(* test if move has been stopped *)
				IF fbAxisMoveRelative.ErrorID = 16#4B00 THEN
				(* clear error *)
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				END_IF
			END_IF
			(* flag move relative off *)
			xMoveRel:=FALSE;
			(* init. FB *)
			fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Move modulo *)
	IF xMoveModulo THEN
		fbAxisMoveModulo(	Execute:= TRUE,
							Position:= T_Axis.T_CtrleSingle.lrPosition,
							Velocity:= ABS(lrOverrideVel),
							Acceleration:= T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:= T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:= T_Axis.T_CtrleSingle.lrJerk,
							Direction:= T_Axis.T_CtrleSingle.iModuloDirection,
							Axis:= T_AxisRefIn);
		IF fbAxisMoveModulo.Done OR fbAxisMoveModulo.Error THEN
			xCalcAngleRefIndex:=FALSE;
			T_Axis.T_CtrleSingle.xDone:=fbAxisMoveModulo.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisMoveModulo.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveModulo.ErrorID;
			(* test if move has been stopped *)
			IF fbAxisMoveModulo.ErrorID = 16#4B00 THEN
			(* clear error *)
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF
			(* flag move absolute off *)
			xMoveModulo:=FALSE;
			(* init. FB *)
			fbAxisMoveModulo(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveModulo(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Homing *)
	IF xHoming THEN
		fbAxisHoming(	Execute:=TRUE,
						Position:=T_Axis.T_CtrleSingle.rSetPosition,
						bCalibrationCam:=xRefHoming,
						Axis:=T_AxisRefIn,
						AxisOut:=T_AxisRefOut);
		IF fbAxisHoming.Done OR fbAxisHoming.Error THEN
			IF NOT(xCalcAngleRefIndex) OR fbAxisHoming.Error THEN
				xCalcAngleRefIndex:=FALSE;
				T_Axis.T_CtrleSingle.xDone:=fbAxisHoming.Done;
				T_Axis.T_CtrleSingle.xErr:= fbAxisHoming.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisHoming.ErrorID;
			END_IF;
			(* flag homing off *)
			xHoming:=FALSE;
			(* Init. FB Homing *)
			fbAxisHoming(	Execute:=FALSE,
							Axis:=T_AxisRefIn,
							AxisOut:=T_AxisRefOut);
		END_IF
	ELSE
		fbAxisHoming(	Execute:=FALSE,
						Axis:=T_AxisRefIn,
						AxisOut:=T_AxisRefOut);
	END_IF

(* Set override *)
	IF xOverride THEN
		fbAxisSetOverride(Execute:=TRUE,
						Override:=T_Axis.T_CtrleSingle.dwOverride,
						AxisRefIn:=T_AxisRefIn,
						AxisRefOut:=T_AxisRefOut);
		IF fbAxisSetOverride.Done OR fbAxisSetOverride.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisSetOverride.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisSetOverride.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisSetOverride.ErrorID;
			(* flag override off *)
			xOverride:=FALSE;
			(* Init. FB Override *)
			fbAxisSetOverride(Execute:=FALSE,
							AxisRefIn:=T_AxisRefIn,
							AxisRefOut:=T_AxisRefOut);
		END_IF
	ELSE
		fbAxisSetOverride(Execute:=FALSE,
						AxisRefIn:=T_AxisRefIn,
						AxisRefOut:=T_AxisRefOut);
	END_IF

(* Set new position *)
	IF xSetPosition THEN
		fbAxisSetPosition(	Execute:=TRUE, Position:=T_Axis.T_CtrleSingle.rSetPosition, Axis:=T_AxisRefIn);
		IF fbAxisSetPosition.Done OR fbAxisSetPosition.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisSetPosition.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisSetPosition.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisSetPosition.ErrorID;
			(* flag set position off *)
			xSetPosition:=FALSE;
			(* Init. FB set position *)
			fbAxisSetPosition(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisSetPosition(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* set new velocity or new position *)
	IF xNewVelocity OR xNewPosition THEN
		IF NOT(xOscillation) OR xNewPosition THEN
			IF NOT(T_Axis.T_CtrleSingle.xNotMoving) THEN
				xNoHWError:=FALSE;
				IF xNewVelocity THEN
				(* new velocity *)
					fbAxisNewPosAndVel(	Execute:=TRUE,
										Mode:=2,
										NewVelo:=ABS(lrOverrideVel),
										Axis:=T_AxisRefIn);
				ELSE
				(* new position *)
					fbAxisNewPosAndVel(	Execute:=TRUE,
										Mode:=3,
										NewPos:=T_Axis.T_CtrleSingle.lrPosition,
										NewVelo:=lrOverrideVel,
										Axis:=T_AxisRefIn);
				END_IF
			ELSE
				xNoHWError:=TRUE;
			END_IF;
			IF fbAxisNewPosAndVel.Done OR fbAxisNewPosAndVel.Error OR xNoHWError THEN
			(* confirm end function *)
				IF xMovement THEN
					IF NOT(xNoHWError) THEN
						T_Axis.T_CtrleSingle.xDone:=FALSE;
					ELSE
						IF xMoveAbs OR xMoveRel OR xMoveModulo THEN
							T_Axis.T_CtrleSingle.xDone:=FALSE;
						ELSE
							T_Axis.T_CtrleSingle.xDone:=TRUE;
						END_IF;
					END_IF;
				ELSE
					IF NOT(xNoHWError) THEN
						T_Axis.T_CtrleSingle.xDone:=fbAxisNewPosAndVel.Done;
					ELSE
						T_Axis.T_CtrleSingle.xDone:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xNoHWError) THEN
					T_Axis.T_CtrleSingle.xErr:= fbAxisNewPosAndVel.Error;
					T_Axis.T_CtrleSingle.udiErrorID:=fbAxisNewPosAndVel.ErrorID;
				ELSE
					xNoHWError:=FALSE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=0;
				END_IF;
				(* flag new velocity off and new position off *)
				xNewVelocity:=FALSE;
				xNewPosition:=FALSE;
				T_Axis.T_CtrleSingle.iFunction:=iTmpFctNr;
				(* Init. flag busy *)
				T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
				(* Init. FB New pos and vel *)
				fbAxisNewPosAndVel(	Execute:=FALSE, Axis:=T_AxisRefIn);
				tTimeCommLeft:=TimerCommTimeLeft.ET;
				xStartTimerComm:=FALSE;
			END_IF
		ELSE
			(* velocity calculation *)
			IF T_Axis.T_Oscillation.rFrequence >= 0 AND T_Axis.T_Oscillation.rFrequence <= 1 THEN
				rTmpFrequence:=1.05 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >=1 AND T_Axis.T_Oscillation.rFrequence <= 2 THEN
				rTmpFrequence:=1.25 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 2 AND T_Axis.T_Oscillation.rFrequence <= 3 THEN
				rTmpFrequence:=2.5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 3 AND T_Axis.T_Oscillation.rFrequence <= 4 THEN
				rTmpFrequence:=5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 4 AND T_Axis.T_Oscillation.rFrequence <= 5 THEN
				rTmpFrequence:=10 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence > 5 THEN rTmpFrequence:=20; END_IF
			lrTmpVelocity:=(rTmpFrequence * 2 + 1 / rTmpFrequence) * ABS(T_Axis.T_Oscillation.rOffset);
			IF lrTmpVelocity > 250 THEN T_Axis.T_CtrleSingle.lrVelocity:=250;
				ELSE T_Axis.T_CtrleSingle.lrVelocity:=lrTmpVelocity; END_IF
			IF xMovement THEN
				T_Axis.T_CtrleSingle.xDone:=FALSE;
			ELSE
				T_Axis.T_CtrleSingle.xDone:=TRUE;
			END_IF;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			xNewVelocity:=FALSE;
			T_Axis.T_CtrleSingle.iFunction:=iTmpFctNr;
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
			tTimeCommLeft:=TimerCommTimeLeft.ET;
			xStartTimerComm:=FALSE;
		END_IF;
	ELSE IF NOT(xNewVelocity) AND NOT( xNewPosition) THEN fbAxisNewPosAndVel(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF
	END_IF

(* Set or reset reference flag *)
	IF xSetReferenceFlag OR xResetReferenceFlag THEN
		IF xSetReferenceFlag THEN
		(* set reference flag *)
			xTmp:=TRUE;
		ELSE xTmp:=FALSE;
		END_IF
		fbAxisSetReferenceFlag(Execute:=TRUE, ReferenceFlag:=xTmp, Axis:=T_AxisRefIn);
		IF fbAxisSetReferenceFlag.Done OR fbAxisSetReferenceFlag.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisSetReferenceFlag.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisSetReferenceFlag.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisSetReferenceFlag.ErrorID;
			(* set flag 'reference flag' off *)
			xSetReferenceFlag:=FALSE;
			xResetReferenceFlag:=FALSE;
			(* Init. FB set reference *)
			fbAxisSetReferenceFlag(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisSetReferenceFlag(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* set/reset control position *)
	IF xCtrlePositionOn THEN
		fbExtSetPointGenEnable(	Execute:=TRUE,
								Axis:=T_AxisRefIn);
		IF fbExtSetPointGenEnable.Done OR fbExtSetPointGenEnable.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbExtSetPointGenEnable.Done;
			T_Axis.T_CtrleSingle.xErr:= fbExtSetPointGenEnable.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbExtSetPointGenEnable.ErrorID;
			(* reset flag *)
			xCtrlePositionOn:=FALSE;
		END_IF
	ELSE
		fbExtSetPointGenEnable(	Execute:=FALSE,
								Axis:=T_AxisRefIn);
	END_IF
	IF xCtrlePositionOff THEN
		fbExtSetPointGenDisable(	Execute:=TRUE,
								Axis:=T_AxisRefIn);
		IF fbExtSetPointGenDisable.Done OR fbExtSetPointGenDisable.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbExtSetPointGenDisable.Done;
			T_Axis.T_CtrleSingle.xErr:= fbExtSetPointGenDisable.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbExtSetPointGenDisable.ErrorID;
			(* reset flag *)
			xCtrlePositionOff:=FALSE;
		END_IF
	ELSE
		fbExtSetPointGenDisable(	Execute:=FALSE,
								Axis:=T_AxisRefIn);
	END_IF

(* calcultate angle between Reference Index and Reference Sensor *)
	IF xCalcAngleRefIndex THEN
		(* error or stop => stop oscillation *)
		IF T_Axis.T_CtrleSingle.xErr OR (xStop AND (iTmpFctNr <> 19)) THEN iStepOsc:=99; END_IF
		CASE iStepCalcRefIndex OF
		(* Drive referencing and search the Ref. Index *)
		1:	T_Axis.T_CtrleSingle.rSetPosition:=0.0;
			xHoming:=TRUE;
			iStepCalcRefIndex:=10;
			T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=0;
			lrTechUnitPerMotorTurn:=65536.0 * T_Axis.T_Config_ObjFileValue.lrScaleFactor;	(*65536 = inc pro Motorumdrehung-->so kann dann mit dem Skalierungsfaktor ermittelt werden, wieviel Tech.Einheit für eine Motorumdrehung*)
			IF lrTechUnitPerMotorTurn = 0.0 THEN
				IF (T_Axis.T_Config_Gen.iTyp = 1) THEN
					lrTechUnitPerMotorTurn:=2.5;	(* 2.5mm entsprechen einer Motorumdrehung *)
				END_IF;
				IF (T_Axis.T_Config_Gen.iTyp = 4) THEN
					lrTechUnitPerMotorTurn:=30.0;	(* 30 Grad entsprechen einer Motorumdrehung *)
				END_IF;
			END_IF;
		10:	IF NOT(xHoming) THEN
				(* Go Absolut to the Reference Index *)
				T_Axis.T_CtrleSingle.lrPosition:=0.0;
				T_Axis.T_CtrleSingle.lrVelocity:=1.0;(*T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward;*)
				T_Axis.T_CtrleSingle.lrAcceleration:=T_Axis.T_Config_ObjFileValue.lrAcceleration;
				T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_ObjFileValue.lrDecceleration;
				T_Axis.T_CtrleSingle.lrJerk:=T_Axis.T_Config_ObjFileValue.lrJerk;
				xMoveAbs:=TRUE;
				iStepCalcRefIndex:=20;
			END_IF;
		20:	IF NOT(xMoveAbs) THEN
				(* Turn the Motor for 360 degrees relativ*)
				xCheckRefState:=xRefHoming;
				T_Axis.T_CtrleSingle.lrDistance:=lrTechUnitPerMotorTurn * -1.0;	(* Der eingesetzte Wert entscheidet ob links oder rechtsdrehend, daher ist es wichtig zu wissen dass der entsprechende Wert, Positiv oder Negativ, die Bewegung zum Ref.Sensor führt *)
				T_Axis.T_CtrleSingle.lrVelocity:=1.0;(*T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward;*)
				T_Axis.T_CtrleSingle.lrAcceleration:=T_Axis.T_Config_ObjFileValue.lrAcceleration;
				T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_ObjFileValue.lrDecceleration;
				T_Axis.T_CtrleSingle.lrJerk:=T_Axis.T_Config_ObjFileValue.lrJerk;
				xMoveRel:=TRUE;
				iStepCalcRefIndex:=30;
			END_IF;
		30:	T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=ABS(LREAL_TO_INT((360.0 / lrTechUnitPerMotorTurn) * T_Axis.T_LiveValue.lrActualPosition));	(* Zeiger bewegt sich so dynamisch während der Fahrt auf der Suche des RefSensors *)
			IF xCheckRefState XOR xRefHoming THEN
				lrCapturePosition:=T_Axis.T_LiveValue.lrActualPosition;
				IF (ABS(lrCapturePosition) > ABS(lrTechUnitPerMotorTurn)) THEN
					lrCapturePosition:=360.0 - ABS(lrCapturePosition);
				END_IF;
				xStop:=TRUE;
				iStepCalcRefIndex:=40;
			END_IF;
			IF NOT(xMoveRel) AND NOT(xStop) THEN
				T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=0;
				iStepCalcRefIndex:=50;
			END_IF;
		40:	IF NOT(xStop) THEN
				T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=LREAL_TO_INT((360.0 / lrTechUnitPerMotorTurn) * lrCapturePosition);	(* Berechnung der Winkellage des RefIndex zum RefSensor *)
				IF (T_Axis.T_CtrleSingle.iStrokeAngleRefIndex < 0) THEN
					T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=T_Axis.T_CtrleSingle.iStrokeAngleRefIndex * -1;
				END_IF;
				IF (T_Axis.T_CtrleSingle.iStrokeAngleRefIndex > 360) THEN
					T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=360;
				END_IF;
				iStepCalcRefIndex:=50;
			END_IF;
		(* End of calc of the ref index position *)
		50:	T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			xCalcAngleRefIndex:=FALSE;
		END_CASE;
	ELSE
		iStepCalcRefIndex:=1;
	END_IF;

(* Oscillation *)
	IF xOscillation THEN
		(* error or stop => stop oscillation *)
		IF T_Axis.T_CtrleSingle.xErr OR xStop THEN iStepOsc:=99; END_IF
		CASE iStepOsc OF
		(* init. oscillation + start move*)
		1:	(* init. variable *)
			iOscCounter:=0;
			(* velocity calculation *)
			IF T_Axis.T_Oscillation.rFrequence >= 0 AND T_Axis.T_Oscillation.rFrequence <= 1 THEN
				rTmpFrequence:=1.05 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >=1 AND T_Axis.T_Oscillation.rFrequence <= 2 THEN
				rTmpFrequence:=1.25 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 2 AND T_Axis.T_Oscillation.rFrequence <= 3 THEN
				rTmpFrequence:=2.5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 3 AND T_Axis.T_Oscillation.rFrequence <= 4 THEN
				rTmpFrequence:=5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 4 AND T_Axis.T_Oscillation.rFrequence <= 5 THEN
				rTmpFrequence:=10 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence > 5 THEN rTmpFrequence:=20; END_IF
			lrTmpVelocity:=(rTmpFrequence * 2 + 1 / rTmpFrequence) * ABS(T_Axis.T_Oscillation.rOffset);
			IF lrTmpVelocity > 250 THEN T_Axis.T_CtrleSingle.lrVelocity:=250;
				ELSE T_Axis.T_CtrleSingle.lrVelocity:=lrTmpVelocity; END_IF
			(*
			(* velocity := frequence * (offset * 2) *)
			T_Axis.T_CtrleSingle.lrVelocity:=T_Axis.T_Oscillation.rFrequence * ABS(T_Axis.T_Oscillation.rOffset) * 2;
			*)
			(* set move *)
			T_Axis.T_CtrleSingle.lrDistance:=T_Axis.T_Oscillation.rOffset;
			xMoveRel:=TRUE;
			(* next step *)
			iStepOsc:=10;
		(* move *)
		10:	IF NOT(xMoveRel) THEN
				(* move *-1 *)
				T_Axis.T_CtrleSingle.lrDistance:=T_Axis.T_Oscillation.rOffset * -1;
				xMoveRel:=TRUE;
				(* next step *)
				iStepOsc:=20;
			END_IF
		(* osc +1 *)
		20:	IF NOT(xMoveRel) THEN
				iOscCounter:=iOscCounter+1;
				IF iOscCounter < T_Axis.T_Oscillation.iCycle THEN
				(* move *)
					T_Axis.T_CtrleSingle.lrDistance:=T_Axis.T_Oscillation.rOffset;
					xMoveRel:=TRUE;
					(* next step *)
					iStepOsc:=10;
				ELSE
				(* oscillation done *)
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
					(* init FB *)
					fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn);
					(* reset flag *)
					xOscillation:=FALSE;
				END_IF
			END_IF
		(* end oscillation *)
		99:	xOscillation:=FALSE;
		END_CASE
	ELSE
	(* init. variable *)
		iStepOsc:=1;
	END_IF

(* Default parameter value *)
	IF xDefaultAxisParameter THEN
		fbDefaultAxisPara(xDefaultValue:=TRUE,T_Axis:=T_Axis);
		T_Axis.T_CtrleSingle.xDone:=TRUE;
		T_Axis.T_CtrleSingle.xErr:= FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		(* flag DefaultParameter off *)
		xDefaultAxisParameter:=FALSE;
	END_IF

(* Send parameter *)
	IF xSendAxisParameter THEN
		CASE iStepSendPara OF
		(* control flag *)
		1:	(* init. next step *)
			iStepSendPara:=2;
			IF T_Axis.T_CtrleSingle.xPower THEN
			(* axis power on, control axis flag *)
				IF (T_AxisRefIn.nStateDWord AND 16#4) = 16#0 THEN
				(* axis is moving, activ error *)
					iStepSendPara:=912;
				END_IF
				IF (T_AxisRefIn.nStateDWord AND 16#20) = 16#20 THEN
				(* axis is in slave mode, activ error *)
					iStepSendPara:=913;
				END_IF
			END_IF
		(* set power off *)
		2:	xRestoreAxisPower:=FALSE;
			IF T_Axis.T_CtrleSingle.xPower THEN
			(* set power off *)
				xPowerOff:=TRUE;
				xPowerOn:=NOT(xPowerOff);
				(* set flag restore *)
				xRestoreAxisPower:=TRUE;
				(* start time out *)
				TimerOutSendPara(IN:=FALSE);
				(* next step *)
				iStepSendPara:=3;
			ELSE
			(* already power off, activ send parameter *)
				iStepSendPara:=11;
			END_IF
		(* wait flag power off *)
		3:	IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
			(* activ send parameter *)
				iStepSendPara:=11;
				xSendBlock:=FALSE;
			END_IF
			IF TimerOutSendPara.Q THEN
			(* time out activ, set error *)
				iStepSendPara:=911;
			END_IF
		(* loop sending parameter *)
		11:	IF NOT (fbAdsWrite.BUSY )  AND NOT(xSendBlock) THEN
			(* send axis parameter *)
				fbAdsWrite(WRITE:=FALSE);
				CASE T_Axis.T_ParamFileObj[iPtrAxisParameter].udiLength OF
				(* True/False, 2 bytes*)
				2:	wTmp:=LREAL_TO_WORD(T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal);
					dwAdrVar:=ADR(wTmp);
				(* dword value, 4 bytes *)
				4:	dwTmp:=LREAL_TO_DWORD(T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal);
					dwAdrVar:=ADR(dwTmp);
				(* else, 8 bytes *)
				8:	dwAdrVar:=ADR(T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal);
				END_CASE
				fbAdsWrite(	NETID:='',
							PORT:=501,
							IDXGRP:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup,
							IDXOFFS:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIndexOffset,
							LEN:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiLength,
							SRCADDR:=dwAdrVar,
							WRITE:=TRUE,
							TMOUT:=T#2s);
				(* next parameter *)
				iPtrAxisParameter:=iPtrAxisParameter+1;
				IF T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup = 0 THEN
				(* parameter list empty *)
					xSendBlock:=TRUE;
				END_IF
			ELSE
				fbAdsWrite(WRITE:=FALSE);
			END_IF
			IF NOT(fbAdsWrite.BUSY) AND NOT(fbAdsWrite.ERR) AND T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup = 0 THEN
			(* determin the next step *)
				IF xRestoreAxisPower THEN
				(* Restore axis power *)
					iStepSendPara:=101;
				ELSE
				(* set flag end function *)
					iStepSendPara:=998;
				END_IF
			END_IF
			IF fbAdsWrite.ERR THEN
			(* set next step  *)
				iStepSendPara:=901;
			END_IF
		(* set power on *)
		101:	xPowerOn:=TRUE;
			xPowerOff:=NOT(xPowerOn);
			(* start time out *)
			TimerOutSendPara(IN:=FALSE);
			(*  next step *)
			iStepSendPara:=102;
		(* wait flag power on *)
		102:	IF T_Axis.T_CtrleSingle.xPower THEN
			(* set flag end function *)
				iStepSendPara:=998;
			END_IF
			IF TimerOutSendPara.Q THEN
			(* time out activ, set error *)
				iStepSendPara:=911;
			END_IF
		(* ads communication error *)
		901:	T_Axis.T_CtrleSingle.udiErrorID:=fbAdsWrite.ERRID;
			(* set next step *)
			iStepSendPara:=991;
		(* time out after setting axis power on/off *)
		911:	T_Axis.T_CtrleSingle.udiErrorID:=16#F101;
			(* set next step *)
			iStepSendPara:=991;
		(* error the axis is moving *)
		912:	T_Axis.T_CtrleSingle.udiErrorID:=16#F102;
			(* set next step *)
			iStepSendPara:=991;
		(* error the axis is in slave mode *)
		913:	T_Axis.T_CtrleSingle.udiErrorID:=16#F103;
			(* set next step *)
			iStepSendPara:=991;
		(* set flag error *)
		991:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:= TRUE;
			(* set last step *)
			iStepSendPara:=999;
		(* set flag end function *)
		998:	T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			(* set last step *)
			iStepSendPara:=999;
		(* reset variable *)
		999:	xSendAxisParameter:=FALSE;
		END_CASE
	ELSE
		fbAdsWrite(WRITE:=FALSE);
	END_IF

(* send axis string *)
	IF xSendAxisString THEN
		(*IF NOT(fbADS_ReadWriteString.BUSY)   AND sReturnAxis = '' THEN
			fbADS_ReadWriteString(WRTRD:=FALSE);*)
			(* add carriage return and line feed *)
			sSendAxis:=CONCAT(T_Axis.T_CtrleSingle.sSend, '$R$L$00');
			fbADS_ReadWriteString(	NETID:=T_Axis.T_Config_Gen.sServoNetId,
									PORT:=200,
									IDXGRP:=1,
									IDXOFFS:=1,
									WRITELEN:=LEN(sSendAxis)-1,
									READLEN:=LEN(sReturnAxis)-1,
									SRCADDR:=ADR(sSendAxis),
									DESTADDR:=ADR(sReturnAxis),
									WRTRD:=TRUE,
									TMOUT:=T#3s);
		(*ELSE
			fbADS_ReadWriteString(WRTRD:=FALSE);
		END_IF*)
		IF NOT(fbADS_ReadWriteString.BUSY) AND NOT(fbADS_ReadWriteString.ERR) AND sReturnAxis <> '' THEN
			IF sSendAxis = sReturnAxis THEN
			(* received string correct *)
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
			ELSE
			(* received string incorrect, active error *)
				T_Axis.T_CtrleSingle.xDone:=FALSE;
				T_Axis.T_CtrleSingle.xErr:= TRUE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#F106;
			END_IF
			(* set flag xsendaxisstring off *)
			xSendAxisString:=FALSE;
		END_IF
		IF fbADS_ReadWriteString.ERR THEN
		(* set flag error *)
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:= TRUE;
			T_Axis.T_CtrleSingle.udiErrorID:=fbADS_ReadWriteString.ERRID;
			(* set flag xsendaxisstring off *)
			xSendAxisString:=FALSE;
		END_IF
	ELSE
		fbADS_ReadWriteString(WRTRD:=FALSE);
	END_IF

(* save parameter NC axis to file *)
	IF xWriteFile THEN
;
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_SINGLE_ECOSTEP
VAR_INPUT
	xCircuitPowerOn:BOOL;
	rPrismaFactor:REAL;
END_VAR
VAR_OUTPUT
	xResetController:BOOL;
	xSetEnableAxis:BOOL;
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
	T_HDD:ST_HDD;
END_VAR
VAR
	siOpMode:SINT;
	uiStatusWord:UINT;
	FBConvertPdoMapping:FB_CONVERT_PDOMAPPING;
	FBConvertAxisParameter:FB_CONVERT_AXISPARAMETER;
(*	fbDefaultAxisPara:FBDefaultAxisValue; *)
	FBGetObjectSDO:FB_GetObject;
	FBSetObjectSDO:FB_SetObject;
(* timer *)
	TimerFileLocked:TON;
(* trigger *)
	RisingEdgeStop:R_TRIG;
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	RisingEdgePowerOn:R_TRIG;
	RisingEdgePowerOff:R_TRIG;
(* variable *)
	xConfirmResetFB:BOOL;
	xReadFault:BOOL;
	xResetAxis:BOOL;
	xPowerOn:BOOL;
	xPowerOff:BOOL;
	xStop:BOOL;
	xMoveVel:BOOL;
	xMoveAbs:BOOL;
	xMoveRel:BOOL;
	xHoming:BOOL;
	xCalcAngleRefIndex:BOOL;
	xSetPosition:BOOL;
	xNewVelocity:BOOL;
	xNewPosition:BOOL;
	xSetOperationMode:BOOL;
	xReadFile:BOOL;
	xWriteFile:BOOL;
	xSendAxisParameter:BOOL;
	xRestoreAxisPower:BOOL;
	xConfirmRequest:BOOL;
	xDriveTorqueIn:BOOL;
	xDriveTorqueOut:BOOL;
	xSetTorqueValue:BOOL;
	iStepSendPara:INT:=0;
	iPtrAxisParameter:INT:=0;
	iStepResetFB:INT;
	iStepFile:INT;
	iStepDriveTorque:INT;
	xConfirmDone:BOOL;
	xConfirmErr:BOOL;
	udiConfirmErrorID:UDINT;
(* temporary variable *)
	i:INT;
	sTmp:STRING(255);
	sDeleteDataAxis: ARRAY[1..csiMaxAxisFileObj] OF STRING(120);
	sDeleteDataHDD: ARRAY[1..csiMaxFileLine] OF STRING(255);
	xSendPDOMappingPara: BOOL;
	xReadFilePDOMappingPara: BOOL;
	SetObjectSDO: BOOL;
	GetObjectSDO: BOOL;
	udiIdxGroup: UDINT;
	udiIndexOffset: UDINT;
	udiLength: UDINT;
	lrReal: LREAL;
	iStepMoveVel: INT;
	iStepStop: INT;
	iStepPowerOn: INT;
	iStepPowerOff: INT;
	iStepMovePos: INT;
	iStepResetAxis: INT;
	iStepSetPosition: INT;
	xMasterSlave: BOOL;
	iStepMasterSlave: INT;
	iStepHoming: INT;
	iStepReadFile: INT;
	lrSettledControlword:LREAL;
	xReadError: BOOL;
	xBlockReadError: BOOL;
	WaitSwitchReady: TON;
	iStepCalcAngleRefIndex: INT;
	xSaveParaEcoDrive: BOOL;
	iStepSaveParaEcoDrive: INT;
	xGetSoftwareVersion: BOOL;
	iStepGetSoftwareVersion: INT;
	sTmpDateCode: STRING(16);
	sCopyDateCode: STRING(16);
	xADSErrorActive: BOOL;
	udiADSErrorID: UDINT;
	xFBErrorActive: BOOL;
	udiFBErrorID: UDINT;
	TimerFunctionTimeOut: TON;
	tTimeOutFunction: TIME;
	lrCapturePosition: LREAL;
	xTmp: BOOL;
	xBlockFBFunction: BOOL;
	iStepBlockFunction: INT;
	xFirstRead: BOOL;
	xNotMoving: BOOL;
	sTmp1: STRING;
	xSetSWLimitSwitch: BOOL;
	iStepSetSWLimitSwitch: INT;
	xResetSWLimitSwitch: BOOL;
	iStepResetSWLimitSwitch: INT;
	xTmp1: BOOL;
	xTmp2: BOOL;
	lrForceSpeed: LREAL;
	TONWaitSetValue: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                               This Functionblock is the driver for the EcoStep Axis                                                           ************)
(****************************************************************************************************************************************************)
(* First read *)
	IF NOT(xFirstRead) THEN
		xFirstRead:=TRUE;
		TimerFunctionTimeOut(IN:=FALSE);
		tTimeOutFunction:=T#999999s;
	END_IF;
(* reset block function *)
	RisingEdgeResetFB(CLK:=T_Axis.T_CtrleSingle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* Init. block function *)
		(* Init. variable *)
		IF T_Axis.T_CtrleSingle.xErr THEN
			xSetEnableAxis:=FALSE;
		END_IF;
		xNotMoving:=TRUE;
		xReadFault:=FALSE;
		xNewVelocity:=FALSE;
		xNewPosition:=FALSE;
		xSetOperationMode:=FALSE;
		xWriteFile:=FALSE;
		xRestoreAxisPower:=FALSE;
		xConfirmRequest:=FALSE;
		xDriveTorqueIn:=FALSE;
		xDriveTorqueOut:=FALSE;
		xSetTorqueValue:=FALSE;
		xResetAxis:=xReadFile:=xPowerOn:=xPowerOff:=xStop:=	xMoveVel:=xMoveAbs:=xMoveRel:=xHoming:=	xSetPosition:=xCalcAngleRefIndex:=FALSE;
		xSendAxisParameter:=xReadFilePDOMappingPara:=xSendPDOMappingPara:=xMasterSlave:=xSaveParaEcoDrive:=xGetSoftwareVersion:=FALSE;
		xSetSWLimitSwitch:=xResetSWLimitSwitch:=FALSE;
		xBlockFBFunction:=FALSE;
		iStepResetFB:=0;
		iStepFile:=0;
		iStepDriveTorque:=0;
		xConfirmDone:=FALSE;
		xConfirmErr:=FALSE;
		udiConfirmErrorID:=0;
		TimerFunctionTimeOut(IN:=FALSE);
		tTimeOutFunction:=T#999999s;
		(* int. structure *)
		T_Axis.T_CtrleSingle.dwOverride:=100;
		T_Axis.T_CtrleSingle.iFunction:=0;
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		T_Axis.T_CtrleSingle.xPower:=FALSE;
		T_Axis.T_CtrleSingle.xReady:=FALSE;
		T_Axis.T_CtrleSingle.xNotMoving:=FALSE;
		T_Axis.T_CtrleSingle.xRef:=FALSE;
		T_Axis.T_CtrleSingle.xSlave:=FALSE;
		T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
		T_Axis.T_CtrleSingle.xDriveTorque:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function bloc *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* return axis state *)
	siOpMode:=T_Axis.T_TxPdoParameter.siOperationModesDisplay;
	uiStatusWord:=T_Axis.T_TxPdoParameter.uiStatusWord;
	T_Axis.T_CtrleSingle.xReady:=		TRUE;
	T_Axis.T_CtrleSingle.xPower:=		GETBIT32(uiStatusWord,0) AND GETBIT32(uiStatusWord,1) AND GETBIT32(uiStatusWord,2) AND NOT(GETBIT32(uiStatusWord,3)) AND
									GETBIT32(uiStatusWord,4) AND GETBIT32(uiStatusWord,5) AND GETBIT32(uiStatusWord,14) AND xSetEnableAxis AND xCircuitPowerOn;
	T_Axis.T_CtrleSingle.xRef:=			GETBIT32(uiStatusWord,15);
	T_Axis.T_CtrleSingle.xSlave:=		(siOpMode = -4);
	T_Axis.T_CtrleSingle.xNotMoving:=	xNotMoving;

(* check HW Axis Error and read it *)
	IF ((UINT_TO_WORD(uiStatusWord) AND 16#8) = 16#8) AND NOT(xReadError) THEN
		IF NOT(GetObjectSDO) THEN
			udiIdxGroup:=16#2600;	(* Error Object *)
			udiIndexOffset:=16#2;
			udiLength:=16#4;
			GetObjectSDO:=TRUE;
			xReadError:=TRUE;
			xResetAxis:=xReadFile:=xPowerOn:=xPowerOff:=xStop:=	xMoveVel:=xMoveAbs:=xMoveRel:=xHoming:=	xSetPosition:=xCalcAngleRefIndex:=FALSE;
			xSendAxisParameter:=xReadFilePDOMappingPara:=xSendPDOMappingPara:=xMasterSlave:=xSaveParaEcoDrive:=xGetSoftwareVersion:=FALSE;
			xSetSWLimitSwitch:=xResetSWLimitSwitch:=FALSE;
		END_IF;
	ELSE
		IF ((UINT_TO_WORD(uiStatusWord) AND 16#8) = 16#8) AND NOT(GetObjectSDO) AND NOT(xBlockReadError) AND xReadError THEN
			T_Axis.T_CtrleSingle.udiErrorID:=FCT_GET_AXIS_ERROR(LREAL_TO_DWORD(lrReal));
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:=TRUE;
			xBlockReadError:=TRUE;
			xNotMoving:=TRUE;
		END_IF;
		IF ((UINT_TO_WORD(uiStatusWord) AND 16#8) = 16#0) THEN
			xReadError:=FALSE;
			xBlockReadError:=FALSE;
		END_IF;
	END_IF;

(* check ADS communication Error *)
	IF xADSErrorActive THEN
		xResetAxis:=xReadFile:=xPowerOn:=xPowerOff:=xStop:=	xMoveVel:=xMoveAbs:=xMoveRel:=xHoming:=	xSetPosition:=xCalcAngleRefIndex:=FALSE;
		xSendAxisParameter:=xReadFilePDOMappingPara:=xSendPDOMappingPara:=xMasterSlave:=xSaveParaEcoDrive:=xGetSoftwareVersion:=FALSE;
		xSetSWLimitSwitch:=xResetSWLimitSwitch:=FALSE;
		(* T_Axis.T_CtrleSingle.udiErrorID:=udiADSErrorID + 16#10000000;	(* With the Value 16#10000000 it can detect an error from the ADS communication *) *)
		T_Axis.T_CtrleSingle.udiErrorID:=16#F214;
		T_Axis.T_CtrleSingle.xErr:=TRUE;
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		xADSErrorActive:=FALSE;
		FBSetObjectSDO(Write:=FALSE);
		FBGetObjectSDO(Read:=FALSE);
		xNotMoving:=TRUE;
	END_IF;

(* check FB Error *)
	IF xFBErrorActive THEN
		xResetAxis:=xReadFile:=xPowerOn:=xPowerOff:=xStop:=	xMoveVel:=xMoveAbs:=xMoveRel:=xHoming:=	xSetPosition:=xCalcAngleRefIndex:=FALSE;
		xSendAxisParameter:=xReadFilePDOMappingPara:=xSendPDOMappingPara:=xMasterSlave:=xSaveParaEcoDrive:=xGetSoftwareVersion:=FALSE;
		xSetSWLimitSwitch:=xResetSWLimitSwitch:=FALSE;
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=TRUE;
		T_Axis.T_CtrleSingle.udiErrorID:=udiFBErrorID;	(* FB Error can detect with prefix 16#2... *)
		xFBErrorActive:=FALSE;
		xNotMoving:=TRUE;
		xResetController:=FALSE;
	END_IF;
	IF TimerFunctionTimeOut.Q AND NOT(T_Axis.T_CtrleSingle.xDone) AND NOT(T_Axis.T_CtrleSingle.xErr) THEN
		xResetAxis:=xReadFile:=xPowerOn:=xPowerOff:=xStop:=	xMoveVel:=xMoveAbs:=xMoveRel:=xHoming:=	xSetPosition:=xCalcAngleRefIndex:=FALSE;
		xSendAxisParameter:=xReadFilePDOMappingPara:=xSendPDOMappingPara:=xMasterSlave:=xSaveParaEcoDrive:=xGetSoftwareVersion:=FALSE;
		xSetSWLimitSwitch:=xResetSWLimitSwitch:=FALSE;
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=TRUE;
		T_Axis.T_CtrleSingle.udiErrorID:=16#F206;	(* Axis Function time out error *)
		xNotMoving:=TRUE;
		xResetController:=FALSE;
	END_IF;

(* check while movement the SW and HW limitswitch *)
	xTmp:= T_Axis.T_CtrleSingle.xHWLimitNeg OR T_Axis.T_CtrleSingle.xHWLimitPos OR T_Axis.T_CtrleSingle.xSWLimitNeg OR T_Axis.T_CtrleSingle.xSWLimitPos;

	xTmp1:= NOT(xMoveAbs) AND NOT(xMoveRel) AND NOT(xMoveVel) AND NOT(T_Axis.T_CtrleSingle.xNotMoving) AND NOT(T_Axis.T_CtrleSingle.xErr);

	xTmp1:= xTmp1 AND ( (T_Axis.T_CtrleSingle.lrSWNegLimitSwitch <> 0.0) OR (T_Axis.T_CtrleSingle.lrSWPosLimitSwitch <> 0.0) );

	IF xTmp1 THEN
		IF ( (T_Axis.T_LiveValue.lrActualPosition < T_Axis.T_CtrleSingle.lrSWNegLimitSwitch) OR
		      (T_Axis.T_LiveValue.lrActualPosition > T_Axis.T_CtrleSingle.lrSWPosLimitSwitch)      ) THEN
			xTmp2:=TRUE;
		ELSE
			xTmp2:=FALSE;
		END_IF;
	ELSE
		xTmp2:=FALSE;
	END_IF;

	IF ( xTmp OR xTmp2 OR xBlockFBFunction ) AND NOT(T_Axis.T_CtrleSingle.xErr) THEN
		IF ( xMoveAbs OR xMoveRel OR xMoveVel OR xTmp2 OR NOT(T_Axis.T_CtrleSingle.xNotMoving) ) AND NOT(xStop) AND NOT(xBlockFBFunction) THEN
			xBlockFBFunction:=TRUE;
			IF xMoveAbs THEN
				IF ( (T_Axis.T_CtrleSingle.lrPosition >= T_Axis.T_CtrleSingle.lrSWNegLimitSwitch) AND (T_Axis.T_CtrleSingle.lrPosition <= T_Axis.T_CtrleSingle.lrSWPosLimitSwitch)) THEN
					xBlockFBFunction:=FALSE;
				END_IF;
			      IF T_Axis.T_LiveValue.lrActualPosition - T_Axis.T_CtrleSingle.lrPosition  < 0 AND T_Axis.T_CtrleSingle.xHWLimitNeg THEN
					xBlockFBFunction:=FALSE;
				END_IF
				IF  T_Axis.T_LiveValue.lrActualPosition - T_Axis.T_CtrleSingle.lrPosition > 0 AND T_Axis.T_CtrleSingle.xHWLimitPos THEN
					xBlockFBFunction:=FALSE;
				END_IF;
			END_IF;
			IF xMoveRel THEN
				IF ( (T_Axis.T_LiveValue.lrActualPosition + T_Axis.T_CtrleSingle.lrDistance) >= T_Axis.T_CtrleSingle.lrSWNegLimitSwitch ) AND
				    ( (T_Axis.T_LiveValue.lrActualPosition + T_Axis.T_CtrleSingle.lrDistance) <= T_Axis.T_CtrleSingle.lrSWPosLimitSwitch ) THEN
					xBlockFBFunction:=FALSE;
				END_IF
				IF T_Axis.T_CtrleSingle.lrDistance > 0 AND T_Axis.T_CtrleSingle.xHWLimitNeg THEN
					xBlockFBFunction:=FALSE;
				END_IF
				IF  T_Axis.T_CtrleSingle.lrDistance < 0 AND T_Axis.T_CtrleSingle.xHWLimitPos THEN
					xBlockFBFunction:=FALSE;
				END_IF;
			END_IF;
			IF xMoveVel OR (NOT(T_Axis.T_CtrleSingle.xNotMoving) AND NOT(xMoveAbs) AND NOT(xMoveRel))THEN
				IF ( (T_Axis.T_LiveValue.lrActualPosition >= T_Axis.T_CtrleSingle.lrSWNegLimitSwitch) AND (T_Axis.T_CtrleSingle.lrVelocity < 0) ) OR
				    ( (T_Axis.T_LiveValue.lrActualPosition <= T_Axis.T_CtrleSingle.lrSWPosLimitSwitch) AND (T_Axis.T_CtrleSingle.lrVelocity > 0) ) THEN
					xBlockFBFunction:=FALSE;
				END_IF;
			      IF T_Axis.T_CtrleSingle.lrVelocity > 0 AND T_Axis.T_CtrleSingle.xHWLimitNeg THEN
					xBlockFBFunction:=FALSE;
				END_IF
				IF  T_Axis.T_CtrleSingle.lrVelocity < 0 AND T_Axis.T_CtrleSingle.xHWLimitPos THEN
					xBlockFBFunction:=FALSE;
				END_IF;
			END_IF;
			IF xBlockFBFunction THEN
				xResetAxis:=xReadFile:=xPowerOn:=xPowerOff:=xStop:=	xMoveVel:=xMoveAbs:=xMoveRel:=xHoming:=	xSetPosition:=xCalcAngleRefIndex:=FALSE;
				xSendAxisParameter:=xReadFilePDOMappingPara:=xSendPDOMappingPara:=xMasterSlave:=xSaveParaEcoDrive:=xGetSoftwareVersion:=FALSE;
				xSetSWLimitSwitch:=xResetSWLimitSwitch:=FALSE;
				iStepBlockFunction:=1;
			END_IF;
		END_IF;
		IF xBlockFBFunction THEN
			CASE iStepBlockFunction OF
			1:	IF NOT(SetObjectSDO) THEN
					udiIdxGroup:=16#60FF;	(* Target velocity *)
					udiIndexOffset:=16#0;
					udiLength:=16#4;
					lrReal:=0;
					SetObjectSDO:=TRUE;
					iStepBlockFunction:=iStepBlockFunction+1;
				END_IF;
			2:	IF NOT(SetObjectSDO) THEN
					udiIdxGroup:=16#6081;	(* Profile velocity *)
					udiIndexOffset:=16#0;
					udiLength:=16#4;
					lrReal:=0;
					SetObjectSDO:=TRUE;
					iStepBlockFunction:=iStepBlockFunction+1;
				END_IF;
			3:	IF NOT(SetObjectSDO) THEN
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=1;
					SetObjectSDO:=TRUE;
					iStepBlockFunction:=iStepBlockFunction+1;
				END_IF;
			4:	IF NOT(SetObjectSDO) THEN
					udiIdxGroup:=16#6040;	(* controlword *)
					udiIndexOffset:=16#0;
					udiLength:=16#2;
					lrReal:=16#F;
					SetObjectSDO:=TRUE;
					iStepBlockFunction:=iStepBlockFunction+1;
				END_IF;
			5:	IF NOT(SetObjectSDO) THEN
					xFBErrorActive:=TRUE;
					udiFBErrorID:=16#F213;	(* Limit End Switch Active *)
					xBlockFBFunction:=FALSE;
				END_IF;
			END_CASE;
		END_IF;
	END_IF;

(* Timer *)
	TimerFileLocked(IN:=TRUE, PT:=T#10S);
	TimerFunctionTimeOut(IN:=TRUE,PT:=tTimeOutFunction);

(* detection start *)
	RisingEdgeExecute(CLK:=T_Axis.T_CtrleSingle.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_Axis.T_CtrleSingle.iFunction OF
		(* Reset *)
		1:	xResetAxis:=TRUE;
			iStepResetAxis:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#6s;
			xResetController:=FALSE;
		(* Init *)
		2:	xReadFile:=TRUE;
			iStepReadFile:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#5s;
		(* Power ON *)
		3:	xPowerOn:=TRUE;
			iStepPowerOn:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#6s;
		(* PowerOff *)
		4:	xPowerOff:=TRUE;
			iStepPowerOff:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		(* Stop *)
		5:	xStop:=TRUE;
			iStepStop:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#5s;
			xCalcAngleRefIndex:=FALSE;
		(* Move velocity *)
		6:	xMoveVel:=TRUE;
			iStepMoveVel:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#999999s;
		(* Absolute *)
		7:	xMoveAbs:=TRUE;
			iStepMovePos:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#999999s;
		(* Relative *)
		8:	xMoveRel:=TRUE;
			iStepMovePos:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#999999s;
		(* homing *)
		9:	xHoming:=TRUE;
			iStepHoming:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#999999s;
		(* set position *)
		11:	xSetPosition:=TRUE;
			iStepSetPosition:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		(* calcultate angle between Reference Index and Reference Sensor *)
		19:	xCalcAngleRefIndex:=TRUE;
			iStepCalcAngleRefIndex:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#999999s;
		(* Send Axis Parameter *)
		21:	xSendAxisParameter:=TRUE;
			iStepSendPara:=1;
			iPtrAxisParameter:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#5s;
		(* Read Pdo Mapping Parameter *)
		22:	xReadFilePDOMappingPara:=TRUE;
			iStepFile:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#5s;
		(* Send PDO Mapping Parameter *)
		23: 	xSendPDOMappingPara:=TRUE;
			iStepSendPara:=1;
			iPtrAxisParameter:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#5s;
		(* Switch Master/Slave *)
		25:	xMasterSlave:=TRUE;
			iStepMasterSlave:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		(* Save Parameter of Servo Drive *)
		26:	xSaveParaEcoDrive:=TRUE;
			iStepSaveParaEcoDrive:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		(* Get Software Version EcoStep *)
		27:	xGetSoftwareVersion:=TRUE;
			iStepGetSoftwareVersion:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		(* Set Software limit switch *)
		28:	xSetSWLimitSwitch:=TRUE;
			iStepSetSWLimitSwitch:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		(* Reset Software limit switch *)
		29:	xResetSWLimitSwitch:=TRUE;
			iStepResetSWLimitSwitch:=1;
			TimerFunctionTimeOut(IN:=FALSE);
			tTimeOutFunction:=T#3s;
		ELSE
		(* function not implemented *)
			xFBErrorActive:=TRUE;
			udiFBErrorID:=16#F201;	(* Function not implemented *)
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=16#0;
		xConfirmDone:=FALSE;
		xConfirmErr:= FALSE;
		udiConfirmErrorID:=16#0;
		(* Exit FB *)
		RETURN;
	END_IF

(* Reset function *)
	IF xResetAxis THEN
		CASE iStepResetAxis OF
		1:	xResetController:=TRUE;
			xSetEnableAxis:=TRUE;
			iStepResetAxis:=iStepResetAxis+1;
		2:	IF NOT((UINT_TO_WORD(uiStatusWord) AND 16#8) = 16#8) THEN
				xResetController:=FALSE;
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#6;
				SetObjectSDO:=TRUE;
				iStepResetAxis:=iStepResetAxis+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#31) = 16#31) THEN
				IF NOT(SetObjectSDO) THEN
					udiIdxGroup:=16#60FF;	(* Target velocity *)
					udiIndexOffset:=16#0;
					udiLength:=16#4;
					lrReal:=0;
					SetObjectSDO:=TRUE;
					iStepResetAxis:=iStepResetAxis+1;
				END_IF;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6081;	(* Profile velocity *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=0;
				SetObjectSDO:=TRUE;
				iStepResetAxis:=iStepResetAxis+1;
			END_IF;
		5:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6060;	(* mode of operation *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=1;
				SetObjectSDO:=TRUE;
				iStepResetAxis:=iStepResetAxis+1;
			END_IF;
		6:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#2509;	(* Mapping of the speed *)
				udiIndexOffset:=16#2;
				udiLength:=16#4;
				lrReal:=16#0;
				SetObjectSDO:=TRUE;
				iStepResetAxis:=iStepResetAxis+1;
			END_IF;
		7:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> 1) THEN
					IF xSetEnableAxis AND xCircuitPowerOn THEN
						udiIdxGroup:=16#6040;	(* controlword *)
						udiIndexOffset:=16#0;
						udiLength:=16#2;
						lrReal:=16#F;
						SetObjectSDO:=TRUE;
						iStepResetAxis:=iStepResetAxis+1;
					ELSE
						iStepResetAxis:=10;
					END_IF;
				ELSE
					iStepResetAxis:=10;
				END_IF;
			END_IF;
		8:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#4037) = 16#4037) THEN
				IF xSetEnableAxis AND xCircuitPowerOn THEN
					udiIdxGroup:=16#6040;	(* controlword *)
					udiIndexOffset:=16#0;
					udiLength:=16#2;
					lrReal:=16#6;
					SetObjectSDO:=TRUE;
					iStepResetAxis:=iStepResetAxis+1;
				ELSE
					iStepResetAxis:=10;
				END_IF;
			END_IF;
		9:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#31) = 16#31) THEN
				iStepResetAxis:=iStepResetAxis+1;
			END_IF;
		10:	IF NOT(SetObjectSDO) THEN
				xSetEnableAxis:=TRUE;
				xNotMoving:=TRUE;
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xResetAxis:=FALSE;
			END_IF;
		END_CASE;
	END_IF;

(* Init. *)
	IF xReadFile AND NOT(xBlockFBFunction) THEN
		CASE iStepReadFile OF
				(* start timeout *)
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (T_Axis.T_Config_Gen.sDeviceFileName = '') THEN
				iStepReadFile:=94;
				RETURN;
			END_IF;
			TimerFileLocked(IN:=FALSE);
			T_Axis.T_FileObj.sData:=sDeleteDataAxis;
			(* next step *)
			iStepReadFile:=iStepReadFile+1;
		(* start read *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xLocked) THEN
			(* activ read axis nc parameter *)
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_HDD.T_Ctrle.xLocked :=TRUE;
				T_HDD.T_Ctrle.iFunction:=1;
				sTmp1:='';
				IF (T_Axis.T_Config_Gen.iMachineType = 1) THEN
					sTmp1:='MicroWire\';
				END_IF;
				IF (T_Axis.T_Config_Gen.iMachineType = 2) THEN
					sTmp1:='MicroRod\';
				END_IF;
				sTmp:='\Hard Disk\Machine450\AxisFile\AxisParameter\';
				sTmp:=CONCAT(sTmp,sTmp1);
				sTmp:=CONCAT(sTmp,T_Axis.T_Config_Gen.sDeviceFileName);
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				T_HDD.T_Data.sData:=sDeleteDataHDD;
				(* next step *)
				iStepReadFile:=iStepReadFile+1;
			ELSE
			(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepReadFile:=91;
				END_IF
			END_IF
		(* wait done or error *)
		3:	IF T_HDD.T_Ctrle.xDone OR T_HDD.T_Ctrle.xErr THEN
				IF T_HDD.T_Ctrle.xErr  THEN
				(* active step error *)
					iStepReadFile:=92;
				ELSE
				(* next step, init convert value *)
					iStepReadFile:=iStepReadFile+1;
					(* copy data from file *)
					i:=1;
					WHILE T_HDD.T_Data.sData[i] <> '' DO
						T_Axis.T_FileObj.sData[i]:=T_HDD.T_Data.sData[i];
						i:=i+1;
					END_WHILE
					(* erase last line +1 *)
					T_Axis.T_FileObj.sData[i+1]:='';
				END_IF
			END_IF
		(* init. convert *)
		4:	FBConvertAxisParameter(	xStart:=FALSE,
									T_Axis:=T_Axis);
			(* next step, convert value *)
			iStepReadFile:=iStepReadFile+1;
		(* convert value *)
		5:	FBConvertAxisParameter(	xStart:=TRUE,
									T_Axis:=T_Axis);
			IF FBConvertAxisParameter.xDone OR FBConvertAxisParameter.xError THEN
				IF FBConvertAxisParameter.xError THEN
					FBConvertAxisParameter(	xStart:=FALSE,
											T_Axis:=T_Axis);
					(* active step error *)
					iStepReadFile:=93;
				ELSE
					(* activ state read successfull *)
					iStepReadFile:=99;
				END_IF;
			END_IF;
		(* start read error *)
		91:	udiFBErrorID:=16#F202;	(* No HDD free resource, time out *)
			iStepReadFile:=99;
		(* block function error *)
		92:	udiFBErrorID:=16#F203;	(* HDD error, no file found *)
			(* last step *)
			iStepReadFile:=99;
		(* Config File Error *)
		93:	udiFBErrorID:=16#F204;	(* Axis Parameter File, wrong syntax *)
			(* last step *)
			iStepReadFile:=99;
		(* Wrong paramter for this function *)
		94:	udiFBErrorID:=16#F208;	(* Wrong Parameter for Function: Read Axis Parameter *)
			(* last step *)
			iStepReadFile:=99;
		(* init. done *)
		99:	IF T_HDD.T_Ctrle.xErr AND NOT(T_HDD.T_Ctrle.xReset)THEN
				T_HDD.T_Ctrle.xReset:=TRUE;
			END_IF;
			IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			xReadFile:=FALSE;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
		END_CASE;
	END_IF;

(* Initialisation function *)
	IF xReadFilePDOMappingPara AND NOT(xBlockFBFunction) THEN
		CASE iStepFile OF
		(* start timeout *)
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (T_Axis.T_Config_Gen.sFileNamePDOMapping = '') THEN
				iStepFile:=94;
				RETURN;
			END_IF;
			TimerFileLocked(IN:=FALSE);
			T_Axis.T_FileObj.sData:=sDeleteDataAxis;
			(* next step *)
			iStepFile:=iStepFile+1;
		(* start read *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xLocked) THEN
			(* activ read axis nc parameter *)
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_HDD.T_Ctrle.xLocked :=TRUE;
				T_HDD.T_Ctrle.iFunction:=1;
				sTmp:='\Hard Disk\Machine450\AxisFile\PDOMapping\';
				sTmp:=CONCAT(sTmp,T_Axis.T_Config_Gen.sFileNamePDOMapping);
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				T_HDD.T_Data.sData:=sDeleteDataHDD;
				(* next step *)
				iStepFile:=iStepFile+1;
			ELSE
			(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFile:=91;
				END_IF
			END_IF
		(* wait done or error *)
		3:	IF T_HDD.T_Ctrle.xDone OR T_HDD.T_Ctrle.xErr THEN
				IF T_HDD.T_Ctrle.xErr  THEN
				(* active step error *)
					iStepFile:=92;
				ELSE
				(* next step, init convert value *)
					iStepFile:=iStepFile+1;
					(* copy data from file *)
					i:=1;
					WHILE T_HDD.T_Data.sData[i] <> '' DO
						T_Axis.T_FileObj.sData[i]:=T_HDD.T_Data.sData[i];
						i:=i+1;
					END_WHILE
					(* erase last line +1 *)
					T_Axis.T_FileObj.sData[i+1]:='';
				END_IF
			END_IF
		(* init. convert *)
		4:	FBConvertPdoMapping(	xStart:=FALSE,
								T_Axis:=T_Axis);
			(* next step, convert value *)
			iStepFile:=iStepFile+1;
		(* convert value *)
		5:	FBConvertPdoMapping(	xStart:=TRUE,
									T_Axis:=T_Axis);
			IF FBConvertPdoMapping.xDone OR FBConvertPdoMapping.xError THEN
				IF FBConvertPdoMapping.xError THEN
					FBConvertPdoMapping(	xStart:=FALSE,
											T_Axis:=T_Axis);
					(* active step error *)
					iStepFile:=93;
				ELSE
					(* activ state read successfull *)
					iStepFile:=99;
				END_IF;
			END_IF;
		(* start read error *)
		91:	udiFBErrorID:=16#F202;	(* No HDD free resource, time out *)
			iStepFile:=99;
		(* block function error *)
		92:	udiFBErrorID:=16#F203;	(* HDD error, no file found *)
			(* last step *)
			iStepFile:=99;
		(* Config File Error *)
		93:	udiFBErrorID:=16#F205;	(* PDOMapping Parameter File, wrong syntax *)
			(* last step *)
			iStepFile:=99;
		(* Wrong paramter for this function *)
		94:	udiFBErrorID:=16#F209;	(* Wrong Parameter for Function: Read PDOMapping Parameter *)
			(* last step *)
			iStepFile:=99;
		(* init. done *)
		99:	IF T_HDD.T_Ctrle.xErr AND NOT(T_HDD.T_Ctrle.xReset)THEN
				T_HDD.T_Ctrle.xReset:=TRUE;
			END_IF;
			IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			xReadFilePDOMappingPara:=FALSE;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
		END_CASE
	END_IF

(* Power function On/Off *)
	RisingEdgePowerOn(CLK:=xPowerOn);
	RisingEdgePowerOff(CLK:=xPowerOff);
	IF xPowerOn AND NOT(xBlockFBFunction) THEN
		CASE iStepPowerOn OF
		1:	IF xSetEnableAxis AND xCircuitPowerOn THEN
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#F;
				SetObjectSDO:=TRUE;
				iStepPowerOn:=iStepPowerOn+1;
			ELSE
				xFBErrorActive:=TRUE;
				udiFBErrorID:=16#F207;	(* No Axis Power Supply *)
			END_IF;
		2:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#4037) = 16#4037) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xPowerOn:=FALSE;
				xNotMoving:=TRUE;
			END_IF;
		END_CASE;
	END_IF
	IF xPowerOff AND NOT(xBlockFBFunction) THEN
		CASE iStepPowerOff OF
		1:	IF xSetEnableAxis AND xCircuitPowerOn THEN
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#6;
				SetObjectSDO:=TRUE;
				iStepPowerOff:=iStepPowerOff+1;
			ELSE
				xFBErrorActive:=TRUE;
				udiFBErrorID:=16#F207;	(* No Axis Power Supply *)
			END_IF;
		2:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#31) = 16#31) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xPowerOff:=FALSE;
				xNotMoving:=TRUE;
			END_IF;
		END_CASE;
	END_IF

(* Stop function *)
	RisingEdgeStop(CLK:=xStop);
	IF xStop AND NOT(xBlockFBFunction) THEN
		CASE iStepStop OF
		1:	IF xNotMoving AND NOT(xMoveAbs) AND NOT(xMoveRel) AND NOT(xMoveVel) AND NOT(xHoming) THEN
				iStepStop:=9;
				xMoveAbs:=xMoveRel:=xMoveVel:=xHoming:=FALSE;
				RETURN;
			END_IF;
			IF (siOpMode = 3) THEN
				IF NOT(SetObjectSDO) AND NOT(GetObjectSDO) THEN
					udiIdxGroup:=16#60FF;	(* Target velocity *)
					udiIndexOffset:=16#0;
					udiLength:=16#4;
					lrReal:=0;
					SetObjectSDO:=TRUE;
					iStepStop:=2;
					xMoveAbs:=xMoveRel:=xMoveVel:=xHoming:=FALSE;
				END_IF;
			END_IF;
			IF (siOpMode = 1) AND (xMoveAbs OR xMoveRel) THEN
				IF NOT(SetObjectSDO) AND NOT(GetObjectSDO) THEN
					udiIdxGroup:=16#6081;	(* Profile velocity *)
					udiIndexOffset:=16#0;
					udiLength:=16#4;
					lrReal:=0;
					SetObjectSDO:=TRUE;
					iStepStop:=3;
					xMoveAbs:=xMoveRel:=xMoveVel:=xHoming:=FALSE;
				END_IF;
			END_IF;
			IF (siOpMode = 6) AND xHoming THEN
				IF NOT(SetObjectSDO) AND NOT(GetObjectSDO) THEN
					udiIdxGroup:=16#6040;	(* controlword *)
					udiIndexOffset:=16#0;
					udiLength:=16#2;
					lrReal:=16#F;
					SetObjectSDO:=TRUE;
					iStepStop:=7;
					WaitSwitchReady(IN:=FALSE);
					xMoveAbs:=xMoveRel:=xMoveVel:=xHoming:=FALSE;
				END_IF;
			END_IF;
(*
			IF (xMoveAbs OR xMoveRel) AND (iStepStop = 1) THEN
				iStepStop:=9;
				RETURN;
			END_IF;
*)
		2:	IF NOT(SetObjectSDO) AND GETBIT32(uiStatusWord,12) THEN
				udiIdxGroup:=16#6060;	(* mode of operation *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=1;
				SetObjectSDO:=TRUE;
				iStepStop:=10;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#60FF;	(* Target velocity *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=0;
				SetObjectSDO:=TRUE;
				iStepStop:=4;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6060;	(* mode of operation *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=3;
				SetObjectSDO:=TRUE;
				iStepStop:=5;
			END_IF;
		5:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#1400) = 16#1400) THEN
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#F;
				SetObjectSDO:=TRUE;
				iStepStop:=6;
			END_IF;
		6:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6060;	(* mode of operation *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=1;
				SetObjectSDO:=TRUE;
				iStepStop:=9;
			END_IF;
		7:	WaitSwitchReady(IN:=TRUE,PT:=T#1000ms);
			IF WaitSwitchReady.Q THEN
				IF NOT(SetObjectSDO) THEN
					WaitSwitchReady(IN:=FALSE);
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=3;
					SetObjectSDO:=TRUE;
					iStepStop:=8;
				END_IF;
			END_IF;
		8:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#1400) = 16#1400) THEN
				udiIdxGroup:=16#6060;	(* mode of operation *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=1;
				SetObjectSDO:=TRUE;
				iStepStop:=9;
			END_IF;
		9:	IF NOT(SetObjectSDO) THEN
				IF NOT(xCalcAngleRefIndex) THEN
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=0;
				END_IF;
				(* init. variable *)
				xStop:=FALSE;
				xNotMoving:=TRUE;
			END_IF;
		10:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#1000) = 16#1000) THEN
				IF NOT(xCalcAngleRefIndex) THEN
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=0;
				END_IF;
				(* init. variable *)
				xStop:=FALSE;
				xNotMoving:=TRUE;
			END_IF;
		END_CASE;
	END_IF;

(* Move velocity *)
	IF xMoveVel AND NOT(xBlockFBFunction) THEN
		CASE iStepMoveVel OF
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (T_Axis.T_CtrleSingle.lrAcceleration = 0) OR (T_Axis.T_CtrleSingle.lrDecceleration = 0) OR (T_Axis.T_CtrleSingle.lrVelocity = 0) THEN
				iStepMoveVel:=91;
				RETURN;
			END_IF;
			(* Check if the power supply of the Axis is on *)
			IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
				iStepMoveVel:=92;
				RETURN;
			END_IF;
			udiIdxGroup:=16#6083;	(* Acceleration *)
			udiIndexOffset:=16#0;
			udiLength:=16#4;
			lrReal:=T_Axis.T_CtrleSingle.lrAcceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
			SetObjectSDO:=TRUE;
			iStepMoveVel:=iStepMoveVel+1;
			xNotMoving:=TRUE;
		2:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6084;	(* Deceleration *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrDecceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepMoveVel:=iStepMoveVel+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> 3) THEN
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=3;
					SetObjectSDO:=TRUE;
				END_IF;
				iStepMoveVel:=iStepMoveVel+1;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#60FF;	(* Target velocity *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				IF (T_Axis.T_Config_Gen.iTyp = 1) OR (T_Axis.T_Config_Gen.iTyp = 2) OR (T_Axis.T_Config_Gen.iTyp = 3) THEN
					lrReal:=((T_Axis.T_CtrleSingle.lrVelocity/60.0) * 64.0) * (360.0 * T_Axis.T_CtrleSingle.lrScaleFactor);
				ELSE
					lrReal:=T_Axis.T_CtrleSingle.lrVelocity * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepMoveVel:=iStepMoveVel+1;
			END_IF;
		5:	IF NOT(SetObjectSDO) AND NOT(GETBIT32(uiStatusWord,12)) THEN
				iStepMoveVel:=99;
			END_IF;
		(* Wrong paramter for this function *)
		91:	udiFBErrorID:=16#F20A;	(* Wrong Parameter for Function: Move velocity *)
			(* last step *)
			iStepMoveVel:=99;
		(* No power supply of the Axis *)
		92:	udiFBErrorID:=16#F212;	(* Can't move, no power supply *)
			(* last step *)
			iStepMoveVel:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xMoveVel:=FALSE;
			xNotMoving:=FALSE;
		END_CASE;
	END_IF

(* Move to position ABS/Rel *)
	IF (xMoveAbs OR xMoveRel) AND NOT(xBlockFBFunction) THEN
		CASE iStepMovePos OF
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (T_Axis.T_CtrleSingle.lrAcceleration = 0) OR (T_Axis.T_CtrleSingle.lrDecceleration = 0) OR (T_Axis.T_CtrleSingle.lrVelocity = 0) (*OR
			     ((T_Axis.T_CtrleSingle.lrDistance = 0) AND xMoveRel) *)THEN
				iStepMovePos:=91;
				RETURN;
			END_IF;
			(* Check if the power supply of the Axis is on *)
			IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
				iStepMovePos:=92;
				RETURN;
			END_IF;
			udiIdxGroup:=16#6040;	(* Controlword *)
			udiIndexOffset:=16#0;
			udiLength:=16#2;
			lrReal:=16#F;
			SetObjectSDO:=TRUE;
			IF T_Axis.T_CtrleSingle.xBlockAcclDeclParameter THEN
				T_Axis.T_CtrleSingle.xBlockAcclDeclParameter:=FALSE;
				IF (siOpMode = 1) THEN
					iStepMovePos:=iStepMovePos+4;
				ELSE
					iStepMovePos:=iStepMovePos+3;
				END_IF;
			ELSE
				iStepMovePos:=iStepMovePos+1;
			END_IF;
			xNotMoving:=TRUE;
		2:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6083;	(* Acceleration *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrAcceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepMovePos:=iStepMovePos+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6084;	(* Deceleration *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrDecceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepMovePos:=iStepMovePos+1;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> 1) THEN
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=1;
					SetObjectSDO:=TRUE;
				END_IF;
				iStepMovePos:=iStepMovePos+1;
			END_IF;
		5:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607A;	(* Target position *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				IF xMoveAbs THEN
					IF (T_Axis.T_Config_Gen.iTyp <> 5) THEN
						lrReal:=T_Axis.T_CtrleSingle.lrPosition * T_Axis.T_CtrleSingle.lrScaleFactor;
					ELSE
						lrReal:=T_Axis.T_CtrleSingle.lrPosition * T_Axis.T_CtrleSingle.lrScaleFactor * rPrismaFactor;
					END_IF;
				END_IF;
				IF xMoveRel THEN
					IF (T_Axis.T_Config_Gen.iTyp <> 5) THEN
						lrReal:=T_Axis.T_CtrleSingle.lrDistance * T_Axis.T_CtrleSingle.lrScaleFactor;
					ELSE
						lrReal:=T_Axis.T_CtrleSingle.lrDistance * T_Axis.T_CtrleSingle.lrScaleFactor * rPrismaFactor;
					END_IF;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepMovePos:=iStepMovePos+1;
			END_IF;
		6:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6081;	(* Profile velocity *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				IF (T_Axis.T_Config_Gen.iTyp = 1) OR (T_Axis.T_Config_Gen.iTyp = 2) OR (T_Axis.T_Config_Gen.iTyp = 3) THEN
					lrReal:=((ABS(T_Axis.T_CtrleSingle.lrVelocity)/60.0) * 64.0) * (360.0 * T_Axis.T_CtrleSingle.lrScaleFactor);
				ELSE
					IF (T_Axis.T_Config_Gen.iTyp = 5) THEN
						lrReal:=ABS(T_Axis.T_CtrleSingle.lrVelocity) * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0 * rPrismaFactor;
					ELSE
						lrReal:=ABS(T_Axis.T_CtrleSingle.lrVelocity) * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
					END_IF;
				END_IF;
				lrForceSpeed:=lrReal;
				SetObjectSDO:=TRUE;
				iStepMovePos:=iStepMovePos+1;
			END_IF;
		7:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				IF xMoveAbs THEN
					lrReal:=16#3F;
				END_IF;
				IF xMoveRel THEN
					lrReal:=16#7F;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepMovePos:=iStepMovePos+1;
				xNotMoving:=FALSE;
			END_IF;
		8:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#1400) = 16#1400) THEN
				udiIdxGroup:=16#6040;	(* Controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#F;
				SetObjectSDO:=TRUE;
				iStepMovePos:=iStepMovePos+1;
				xNotMoving:=FALSE;
			END_IF;
		9:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#4037) = 16#4037) THEN
				iStepMovePos:=99;
			END_IF;
		(* Wrong paramter for this function *)
		91:	IF xMoveAbs THEN
				udiFBErrorID:=16#F20B;	(* Wrong Parameter for Function: Move position absolute *)
			END_IF;
			IF xMoveRel THEN
				udiFBErrorID:=16#F20C;	(* Wrong Parameter for Function: Move position relative *)
			END_IF;
			(* last step *)
			iStepMovePos:=99;
		(* No power supply of the Axis *)
		92:	udiFBErrorID:=16#F212;	(* Can't move, no power supply *)
			(* last step *)
			iStepMovePos:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0)  THEN
				xFBErrorActive:=TRUE;
				xCalcAngleRefIndex:=FALSE;
			END_IF;
			IF NOT(xFBErrorActive) AND NOT(xCalcAngleRefIndex) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xMoveAbs:=xMoveRel:=FALSE;
			xNotMoving:=TRUE;
		END_CASE;
	END_IF;

(* Homing *)
	IF xHoming AND NOT(xBlockFBFunction) THEN
		CASE iStepHoming OF
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (T_Axis.T_CtrleSingle.lrHomingMethode <= 0) OR (T_Axis.T_CtrleSingle.lrHomingMethode > 34) OR (T_Axis.T_CtrleSingle.lrHomeSpeedSwitch = 0) OR
			     (T_Axis.T_CtrleSingle.lrHomeSpeedZero = 0) OR (T_Axis.T_CtrleSingle.lrHomeAcceleration = 0) THEN
				iStepHoming:=91;
				RETURN;
			END_IF;
			(* Check if the power supply of the Axis is on *)
			IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
				iStepHoming:=92;
				RETURN;
			END_IF;
			udiIdxGroup:=16#6040;	(* Controlword *)
			udiIndexOffset:=16#0;
			udiLength:=16#2;
			lrReal:=16#F;
			SetObjectSDO:=TRUE;
			iStepHoming:=iStepHoming+1;
			xNotMoving:=TRUE;
		2:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> 1) THEN
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=1;
					SetObjectSDO:=TRUE;
					iStepHoming:=iStepHoming+1;
					TONWaitSetValue(IN:=FALSE);
				ELSE
					iStepHoming:=iStepHoming+2;
				END_IF;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				TONWaitSetValue(IN:=TRUE,PT:=T#100ms);
				IF TONWaitSetValue.Q THEN
					TONWaitSetValue(IN:=FALSE);
					iStepHoming:=iStepHoming+1;
				END_IF;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				(* It is Important that the accl. for the homing is settled before the mode of operation is set to the homing, otherwise it will not work with this accl. *)
				udiIdxGroup:=16#609A;	(* homing acceleration *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrHomeAcceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;
		5:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6083;	(* Acceleration *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrAcceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;
		6:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6084;	(* Deceleration *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrDecceleration * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
				TONWaitSetValue(IN:=FALSE);
			END_IF;
		7:	IF NOT(SetObjectSDO) THEN
				TONWaitSetValue(IN:=TRUE,PT:=T#200ms);
				IF TONWaitSetValue.Q THEN
					TONWaitSetValue(IN:=FALSE);
					iStepHoming:=iStepHoming+1;
				END_IF;
			END_IF;
		8:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> 6) THEN
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=6;
					SetObjectSDO:=TRUE;
				END_IF;
				iStepHoming:=iStepHoming+1;
			END_IF;
		9:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6098;	(* Homing Methode *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=T_Axis.T_CtrleSingle.lrHomingMethode;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;

		10:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607C;	(* Home Offset *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrHomeOffset * T_Axis.T_CtrleSingle.lrScaleFactor ;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;
		11:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6099;	(* homing speed search for switch *)
				udiIndexOffset:=16#1;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrHomeSpeedSwitch * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;
		12:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6099;	(* homing speed search for zero *)
				udiIndexOffset:=16#2;
				udiLength:=16#4;
				lrReal:=T_Axis.T_CtrleSingle.lrHomeSpeedZero * T_Axis.T_CtrleSingle.lrScaleFactor * 64.0;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;
		13:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#1F;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
			END_IF;
		14:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#1400) = 16#1400) THEN
				udiIdxGroup:=16#6040;	(* Controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#F;
				SetObjectSDO:=TRUE;
				iStepHoming:=iStepHoming+1;
				xNotMoving:=FALSE;
			END_IF;
		15:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#4037) = 16#4037) THEN
				iStepHoming:=99;
			END_IF;
		(* Wrong paramter for this function *)
		91:	udiFBErrorID:=16#F20D;	(* Wrong Parameter for Function: Move referencing *)
			(* last step *)
			iStepHoming:=99;
		(* No power supply of the Axis *)
		92:	udiFBErrorID:=16#F212;	(* Can't move, no power supply *)
			(* last step *)
			iStepHoming:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
				xCalcAngleRefIndex:=FALSE;
			END_IF;
			IF NOT(xFBErrorActive) AND NOT(xCalcAngleRefIndex) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xHoming:=FALSE;
			xNotMoving:=TRUE;
		END_CASE;
	END_IF;

(* Set new position *)
	IF xSetPosition AND NOT(xBlockFBFunction) THEN
		CASE iStepSetPosition OF
		1:	udiIdxGroup:=16#6040;	(* Controlword *)
			udiIndexOffset:=16#0;
			udiLength:=16#2;
			lrReal:=16#F;
			SetObjectSDO:=TRUE;
			iStepSetPosition:=iStepSetPosition+1;
		2:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> 6) THEN
					udiIdxGroup:=16#6060;	(* mode of operation *)
					udiIndexOffset:=16#0;
					udiLength:=16#1;
					lrReal:=6;
					SetObjectSDO:=TRUE;
				END_IF;
				iStepSetPosition:=iStepSetPosition+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6098;	(* Homing Methode *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				lrReal:=34;			(* Referenzmethode 34 without Referenzdrive *)
				SetObjectSDO:=TRUE;
				iStepSetPosition:=iStepSetPosition+1;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607C;	(* Home Offset *)
				udiIndexOffset:=16#0;
				udiLength:=16#4;
				IF (T_Axis.T_Config_Gen.iTyp <> 5) THEN
					lrReal:=T_Axis.T_CtrleSingle.rSetPosition * T_Axis.T_CtrleSingle.lrScaleFactor * -1.0;
				ELSE
					lrReal:=T_Axis.T_CtrleSingle.rSetPosition * T_Axis.T_CtrleSingle.lrScaleFactor * rPrismaFactor * -1.0;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepSetPosition:=iStepSetPosition+1;
			END_IF;
		5:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6040;	(* controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#1F;
				SetObjectSDO:=TRUE;
				iStepSetPosition:=iStepSetPosition+1;
			END_IF;
		6:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#1400) = 16#1400) THEN
				udiIdxGroup:=16#6040;	(* Controlword *)
				udiIndexOffset:=16#0;
				udiLength:=16#2;
				lrReal:=16#F;
				SetObjectSDO:=TRUE;
				iStepSetPosition:=iStepSetPosition+1;
			END_IF;
		7:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#4037) = 16#4037) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xSetPosition:=FALSE;
			END_IF;
		END_CASE;
	END_IF;

(* calcultate angle between Reference Index and Reference Sensor *)
	IF xCalcAngleRefIndex AND NOT(xBlockFBFunction) THEN
		CASE iStepCalcAngleRefIndex OF
		1:	udiFBErrorID:=0;
			xHoming:=TRUE;
			iStepHoming:=1;
			T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=0;
			iStepCalcAngleRefIndex:=iStepCalcAngleRefIndex + 1;
		2:	IF NOT(xHoming) THEN
				xMoveAbs:=TRUE;
				iStepMovePos:=1;
				iStepCalcAngleRefIndex:=iStepCalcAngleRefIndex + 1;
			END_IF;
		3:	IF NOT(xMoveAbs) THEN
				xMoveRel:=TRUE;
				iStepMovePos:=1;
				iStepCalcAngleRefIndex:=iStepCalcAngleRefIndex + 1;
			END_IF;
		4:	IF NOT(xMoveRel) THEN
				iStepCalcAngleRefIndex:=91;
			END_IF;
			IF GETBIT32(T_Axis.T_TxPdoParameter.udiDigitalInput,23) THEN
				lrCapturePosition:=ABS(T_Axis.T_LiveValue.lrActualPosition);
				xStop:=TRUE;
				iStepStop:=1;
				iStepCalcAngleRefIndex:=iStepCalcAngleRefIndex + 1;
			END_IF;
		5:	IF NOT(xStop) THEN
				T_Axis.T_CtrleSingle.iStrokeAngleRefIndex:=LREAL_TO_INT((360.0/8000.0) * lrCapturePosition * T_Axis.T_CtrleSingle.lrScaleFactor);	(* calculate Distance between RefSensor and RefIndex *)
				iStepCalcAngleRefIndex:=99;
			END_IF;
		(* Wrong paramter for this function *)
		91:	udiFBErrorID:=16#F211;	(* Function CalcAnlgeRefIndex:Ref.Sensor not found *)
			(* last step *)
			iStepCalcAngleRefIndex:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0)  THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xCalcAngleRefIndex:=FALSE;
		END_CASE;
	END_IF;

(* Send Axis Parameter *)
	IF xSendAxisParameter AND NOT(xBlockFBFunction) THEN
		CASE iStepSendPara OF
		(* control flag *)
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (iPtrAxisParameter = 1) AND (T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup = 0) THEN
				iStepSendPara:=91;
				RETURN;
			END_IF;
			udiIdxGroup:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup;
			udiIndexOffset:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIndexOffset;
			udiLength:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiLength;
			lrReal:=T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal;
			SetObjectSDO:=TRUE;
			(* set next step  *)
			iStepSendPara:=iStepSendPara+1;
		2:	IF NOT(SetObjectSDO) THEN
				IF (T_Axis.T_ParamFileObj[iPtrAxisParameter + 1].udiIdxGroup <> 0) THEN
					(* next parameter *)
					iPtrAxisParameter:=iPtrAxisParameter+1;
					(* set next step  *)
					iStepSendPara:=1;
				ELSE
					(* set flag end function *)
					iStepSendPara:=99;
				END_IF;
			END_IF;
		(* Wrong paramter for this function *)
		91:	udiFBErrorID:=16#F20E;	(* Wrong Parameter for Function: Send Axis Parameter *)
			(* last step *)
			iStepSendPara:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xSendAxisParameter:=FALSE;
		END_CASE
	END_IF;

(* Send parameter to axis *)
	IF xSendPDOMappingPara AND NOT(xBlockFBFunction) THEN
		CASE iStepSendPara OF
		(* control flag *)
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF (iPtrAxisParameter = 1) AND (T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup = 0) THEN
				iStepSendPara:=91;
				RETURN;
			END_IF;
			udiIdxGroup:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup;
			udiIndexOffset:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIndexOffset;
			udiLength:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiLength;
			lrReal:=T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal;
			SetObjectSDO:=TRUE;
			(* set next step  *)
			iStepSendPara:=iStepSendPara+1;
		2:	IF NOT(SetObjectSDO) THEN
				IF (T_Axis.T_ParamFileObj[iPtrAxisParameter + 1].udiIdxGroup <> 0) THEN
					(* next parameter *)
					iPtrAxisParameter:=iPtrAxisParameter+1;
					(* set next step  *)
					iStepSendPara:=1;
				ELSE
					(* set flag end function *)
					iStepSendPara:=99;
				END_IF;
			END_IF;
		(* Wrong paramter for this function *)
		91:	udiFBErrorID:=16#F20F;	(* Wrong Parameter for Function: Send PDOMapping Parameter *)
			(* last step *)
			iStepSendPara:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xSendPDOMappingPara:=FALSE;
		END_CASE
	END_IF

(* Switch Master/Slave *)
	IF xMasterSlave AND NOT(xBlockFBFunction) THEN
		CASE iStepMasterSlave OF
		1:	udiFBErrorID:=0;
			(* Check first the usage of the correct parameter *)
			IF ((T_Axis.T_CtrleSingle.lrGearFactor = 0) OR (T_Axis.T_CtrleSingle.lrGearDivider = 0)) AND (siOpMode <> -4) THEN
				iStepMasterSlave:=91;
				RETURN;
			END_IF;
			udiIdxGroup:=16#6040;	(* Controlword *)
			udiIndexOffset:=16#0;
			udiLength:=16#2;
			lrReal:=16#F;
			SetObjectSDO:=TRUE;
			iStepMasterSlave:=iStepMasterSlave+1;
		2:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#2509;	(* Mapping of the speed *)
				udiIndexOffset:=16#2;
				udiLength:=16#4;
				IF (siOpMode <> -4) THEN
					lrReal:=16#60FF0020;
				ELSE
					lrReal:=16#0;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepMasterSlave:=iStepMasterSlave+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> -4) THEN
					udiIdxGroup:=16#2509;	(* Gear Factor *)
					udiIndexOffset:=16#3;
					udiLength:=16#2;
					lrReal:=T_Axis.T_CtrleSingle.lrGearFactor;
					SetObjectSDO:=TRUE;
				END_IF;
				iStepMasterSlave:=iStepMasterSlave+1;
			END_IF;
		4:	IF NOT(SetObjectSDO) THEN
				IF (siOpMode <> -4) THEN
					udiIdxGroup:=16#2509;	(* Gear Divider *)
					udiIndexOffset:=16#4;
					udiLength:=16#2;
					lrReal:=T_Axis.T_CtrleSingle.lrGearDivider;
					SetObjectSDO:=TRUE;
				END_IF;
				iStepMasterSlave:=iStepMasterSlave+1;
			END_IF;
		5:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#2509;	(* Modus *)
				udiIndexOffset:=16#5;
				udiLength:=16#2;
				IF (siOpMode <> -4) THEN
					lrReal:=2;			(* Master/Slave *)
				ELSE
					lrReal:=0;			(* Master *)
				END_IF;
				SetObjectSDO:=TRUE;
				iStepMasterSlave:=iStepMasterSlave+1;
			END_IF;
		6:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#6060;	(* mode of operation *)
				udiIndexOffset:=16#0;
				udiLength:=16#1;
				IF (siOpMode <> -4) THEN
					lrReal:=-4;
				ELSE
					lrReal:=1;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepMasterSlave:=iStepMasterSlave+1;
			END_IF;
		7:	IF NOT(SetObjectSDO) AND ((UINT_TO_WORD(uiStatusWord) AND 16#4037) = 16#4037) THEN
				iStepMasterSlave:=99;
			END_IF;
		(* Wrong paramter for this function *)
		91:	udiFBErrorID:=16#F210;	(* Wrong Parameter for Function: Master/Slave *)
			(* last step *)
			iStepMasterSlave:=99;
		(* init. done *)
		99:	IF (udiFBErrorID <> 0) THEN
				xFBErrorActive:=TRUE;
			END_IF;
			IF NOT(xFBErrorActive) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xMasterSlave:=FALSE;
		END_CASE;
	END_IF;

(* Save Parameter of Servo Drive *)
	IF xSaveParaEcoDrive AND NOT(xBlockFBFunction) THEN
		CASE iStepSaveParaEcoDrive OF
		1:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#1010;	(* Save Objekt *)
				udiIndexOffset:=16#1;
				udiLength:=16#4;
				lrReal:=16#65766173;	(* Save all Ecostep Parameter *)
				SetObjectSDO:=TRUE;
				iStepSaveParaEcoDrive:=iStepSaveParaEcoDrive+1;
			END_IF;
		2:	IF NOT(SetObjectSDO) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xSaveParaEcoDrive:=FALSE;
			END_IF;
		END_CASE;
	END_IF;

(* Get Software Version EcoStep *)
	IF xGetSoftwareVersion AND NOT(xBlockFBFunction) THEN
		CASE iStepGetSoftwareVersion OF
		1:	IF NOT(GetObjectSDO) THEN
				udiIdxGroup:=16#2FE0;		(* Software version *)
				udiIndexOffset:=16#1;
				udiLength:=16#4;
				GetObjectSDO:=TRUE;
				iStepGetSoftwareVersion:=iStepGetSoftwareVersion + 1;
			END_IF;
		2:	IF NOT(GetObjectSDO) THEN
				T_Axis.T_SoftwareDetails.lrSoftwareVersion:=lrReal;
				udiIdxGroup:=16#2FE0;		(* Build version *)
				udiIndexOffset:=16#2;
				udiLength:=16#4;
				GetObjectSDO:=TRUE;
				iStepGetSoftwareVersion:=iStepGetSoftwareVersion + 1;
			END_IF;
		3:	IF NOT(GetObjectSDO) THEN
				T_Axis.T_SoftwareDetails.lrBuildVersion:=lrReal;
				udiIdxGroup:=16#2FE0;		(* Software date code *)
				udiIndexOffset:=16#3;
				udiLength:=16#4;
				GetObjectSDO:=TRUE;
				iStepGetSoftwareVersion:=iStepGetSoftwareVersion + 1;
			END_IF;
		4:	IF NOT(GetObjectSDO) THEN
				T_Axis.T_SoftwareDetails.lrDateCode:=lrReal;
				sCopyDateCode:=LREAL_TO_STRING(lrReal);
				sTmpDateCode:=MID(sCopyDateCode,2,7);	(* Get Day *)
				sTmpDateCode:=CONCAT(sTmpDateCode,'.');
				sTmpDateCode:=CONCAT(sTmpDateCode,MID(sCopyDateCode,2,5));	(* Get Month *)
				sTmpDateCode:=CONCAT(sTmpDateCode,'.');
				sTmpDateCode:=CONCAT(sTmpDateCode,MID(sCopyDateCode,4,1));	(* Get Year *)
				T_Axis.T_SoftwareDetails.sDateCode:=sTmpDateCode;
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xGetSoftwareVersion:=FALSE;
			END_IF;
		END_CASE;
	END_IF;

(* Set Software limit switch *)
	IF xSetSWLimitSwitch AND NOT(xBlockFBFunction) THEN
		CASE iStepSetSWLimitSwitch OF
		1:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607D;	(* Object for the SW Limit switch *)
				udiIndexOffset:=16#1;	(* Subindex for the neg end switch *)
				udiLength:=16#4;
				IF (T_Axis.T_Config_Gen.iTyp <> 5) THEN
					lrReal:=T_Axis.T_CtrleSingle.lrSWNegLimitSwitch * T_Axis.T_CtrleSingle.lrScaleFactor;
				ELSE
					lrReal:=T_Axis.T_CtrleSingle.lrSWNegLimitSwitch * T_Axis.T_CtrleSingle.lrScaleFactor * rPrismaFactor;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepSetSWLimitSwitch:=iStepSetSWLimitSwitch+1;
			END_IF;
		2:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607D;	(* Object for the SW Limit switch *)
				udiIndexOffset:=16#2;	(* Subindex for the pos end switch *)
				udiLength:=16#4;
				IF (T_Axis.T_Config_Gen.iTyp <> 5) THEN
					lrReal:=T_Axis.T_CtrleSingle.lrSWPosLimitSwitch * T_Axis.T_CtrleSingle.lrScaleFactor;
				ELSE
					lrReal:=T_Axis.T_CtrleSingle.lrSWPosLimitSwitch * T_Axis.T_CtrleSingle.lrScaleFactor * rPrismaFactor;
				END_IF;
				SetObjectSDO:=TRUE;
				iStepSetSWLimitSwitch:=iStepSetSWLimitSwitch+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xSetSWLimitSwitch:=FALSE;
			END_IF;
		END_CASE;
	END_IF;

(* Reset Software limit switch *)
	IF xResetSWLimitSwitch AND NOT(xBlockFBFunction) THEN
		CASE iStepResetSWLimitSwitch OF
		1:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607D;	(* Object for the SW Limit switch *)
				udiIndexOffset:=16#1;	(* Subindex for the neg end switch *)
				udiLength:=16#4;
				lrReal:=0;
				SetObjectSDO:=TRUE;
				iStepResetSWLimitSwitch:=iStepResetSWLimitSwitch+1;
			END_IF;
		2:	IF NOT(SetObjectSDO) THEN
				udiIdxGroup:=16#607D;	(* Object for the SW Limit switch *)
				udiIndexOffset:=16#2;	(* Subindex for the pos end switch *)
				udiLength:=16#4;
				lrReal:=0;
				SetObjectSDO:=TRUE;
				iStepResetSWLimitSwitch:=iStepResetSWLimitSwitch+1;
			END_IF;
		3:	IF NOT(SetObjectSDO) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
				(* init. variable *)
				xResetSWLimitSwitch:=FALSE;
			END_IF;
		END_CASE;
	END_IF;

(* send set SDO Object *)
	IF SetObjectSDO THEN
		IF (udiIdxGroup = 16#6040) THEN
			lrSettledControlword:=lrReal;
		END_IF;
		FBSetObjectSDO(		ADSNetId:=T_Axis.T_Config_Gen.sAmsNetId,
							NodeId:=UDINT_TO_INT(T_Axis.T_Config_Gen.udiNodeId),
							Write:=TRUE,
							ObjectIndex:=UDINT_TO_UINT(udiIdxGroup),
							ObjectSubIndex:=UDINT_TO_USINT(udiIndexOffset),
							LEN:=UDINT_TO_USINT(udiLength),
							Data:=LREAL_TO_UDINT(lrReal));
		IF FBSetObjectSDO.Done AND NOT(FBSetObjectSDO.ERR) THEN
			FBSetObjectSDO(Write:=FALSE);
			SetObjectSDO:=FALSE;
		END_IF;
		IF FBSetObjectSDO.ERR THEN
			xADSErrorActive:=TRUE;
			udiADSErrorID:=FBSetObjectSDO.ErrNo;
			FBSetObjectSDO(Write:=FALSE);
			SetObjectSDO:=FALSE;
		END_IF;
	ELSE
		FBSetObjectSDO(Write:=FALSE);
	END_IF;

(* send get SDO Object *)
	IF GetObjectSDO THEN
		FBGetObjectSDO(		ADSNetId:=T_Axis.T_Config_Gen.sAmsNetId,
							NodeId:=UDINT_TO_INT(T_Axis.T_Config_Gen.udiNodeId),
							Read:=TRUE,
							ObjectIndex:=UDINT_TO_UINT(udiIdxGroup),
							ObjectSubIndex:=UDINT_TO_USINT(udiIndexOffset),
							LEN:=UDINT_TO_USINT(udiLength));
		IF FBGetObjectSDO.Done AND NOT(FBGetObjectSDO.ERR) THEN
			lrReal:=FBGetObjectSDO.Data;
			FBGetObjectSDO(Read:=FALSE);
			GetObjectSDO:=FALSE;
		END_IF;
		IF FBGetObjectSDO.ERR THEN
			xADSErrorActive:=TRUE;
			udiADSErrorID:=FBGetObjectSDO.ErrNo;
			FBGetObjectSDO(Read:=FALSE);
			GetObjectSDO:=FALSE;
		END_IF;
	ELSE
		FBGetObjectSDO(Read:=FALSE);
	END_IF;


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_BOXID
VAR_INPUT
	udiDeviceIdLightBusMaster:UDINT;
END_VAR
VAR_IN_OUT
	T_BoxId:ST_BOXID;
END_VAR
VAR_OUTPUT
END_VAR
VAR
(* pointer of Box ID *)
	ptrBoxId: POINTER TO ST_BOXID;
(* function bloc *)
	fbGetBoxAddrByName:IOF_GetBoxAddrByName;
	fbGetBoxNetId:IOF_GetBoxNetId;
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
(* variable *)
	xGetBoxId:BOOL:=FALSE;
	xConfirmResetFB:BOOL:=FALSE;
	iPtrBoxName:INT:=0;
	iPtrBoxNameEnd:INT:=0;
	T_BoxId_AdrTmp:ARRAY[1..20] OF ST_BOXID_DATA_ADR;
	xInitReadStructure: BOOL;
	xCopyReadyStructure:BOOL;
	xGetBoxAddress: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                     This Functionblock is needed for read the BoxID information of the Beckhoff components               ************)
(****************************************************************************************************************************************************)
(* reset *)
	RisingEdgeResetFB(CLK:=T_BoxId.T_Ctrle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* init ptr*)
		ptrBoxId:=ADR(T_BoxId);
	(* init. variable *)
		xGetBoxId:=FALSE;
		iPtrBoxName:=1;
	(* Init. variable *)
		ptrBoxId^.T_Ctrle.xDone:=FALSE;
		ptrBoxId^.T_Ctrle.xErr:=FALSE;
		ptrBoxId^.T_Ctrle.udiErrorID:=0;
	(* activ confirm reset *)
		xConfirmResetFB:=TRUE;
	(* Exit FB *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			ptrBoxId^.T_Ctrle.xDone:=TRUE;
			ptrBoxId^.T_Ctrle.xErr:=FALSE;
			ptrBoxId^.T_Ctrle.udiErrorID:=0;
		(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* execute *)
	RisingEdgeExecute(CLK:=T_BoxId.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
	(* init ptr*)
		ptrBoxId:=ADR(T_BoxId);
	(* activ get device Id *)
		xInitReadStructure:=TRUE;
	(* init. state flag *)
		ptrBoxId^.T_Ctrle.xDone:=FALSE;
		ptrBoxId^.T_Ctrle.xErr:=FALSE;
		ptrBoxId^.T_Ctrle.udiErrorID:=0;
	(* Exit FB *)
		RETURN;
	END_IF

(* init. read structure *)
	IF xInitReadStructure THEN
	(* PLC name, servo  *)
		iPtrBoxName:=1;
		T_BoxId_AdrTmp[1]:=T_BoxId.T_Servo_ToolLeft;
		T_BoxId_AdrTmp[2]:=T_BoxId.T_Servo_ToolCenter;
		T_BoxId_AdrTmp[3]:=T_BoxId.T_Servo_ToolRight;
		T_BoxId_AdrTmp[4]:=T_BoxId.T_Servo_ToolFeeder;
		T_BoxId_AdrTmp[5]:=T_BoxId.T_Servo_GrindFeeder;
		iPtrBoxNameEnd:=5;
		(* end *)
		T_BoxId_AdrTmp[6].sDeviceName:='';
		(*reset variable*)
		xInitReadStructure:=FALSE;
		(* start device id reading *)
		xGetBoxAddress:=TRUE;
	(* Exit FB *)
		RETURN;
	END_IF

(* get box address *)
	IF xGetBoxAddress THEN
		fbGetBoxAddrByName(	NETID:='',
								DEVICEID:=udiDeviceIdLightBusMaster,
								BOXNAME:=T_BoxId_AdrTmp[iPtrBoxName].sBoxName,
								START:=TRUE,
								TMOUT:=T#2s);
		IF NOT(fbGetBoxAddrByName.BUSY) OR fbGetBoxAddrByName.ERR THEN
			IF fbGetBoxAddrByName.ERR THEN
				IF T_BoxId_AdrTmp[iPtrBoxName].xDeviceOption THEN
				(* Init. FB *)
					fbGetBoxAddrByName(START:=FALSE);
					IF iPtrBoxName <> iPtrBoxNameEnd THEN
					(* next box *)
						iPtrBoxName:=iPtrBoxName+1;
						IF (T_BoxId.T_Ctrle.iMachineType = 1) AND (iPtrBoxName = 2) THEN
							iPtrBoxName:=3;
						END_IF;
						(* exit FB *)
						RETURN;
					(* activ copy value *)
					ELSE xCopyReadyStructure:=TRUE;END_IF
				ELSE
				(* acitve error *)
					ptrBoxId^.T_Ctrle.xDone:=FALSE;
					ptrBoxId^.T_Ctrle.xErr:=TRUE;
					ptrBoxId^.T_Ctrle.udiErrorID:=fbGetBoxAddrByName.ERRID;
				END_IF
			ELSE
			(* get address *)
				T_BoxId_AdrTmp[iPtrBoxName].wAddrBox:=UINT_TO_WORD(fbGetBoxAddrByName.BOXADDR);
				(* enable get box id *)
				xGetBoxId:=TRUE;
			END_IF
			(* disable get address *)
			xGetBoxAddress:=FALSE;
		END_IF
	ELSE
		fbGetBoxAddrByName(START:=FALSE);
	END_IF

(* get device Id *)
	IF xGetBoxId THEN
		fbGetBoxNetId(	NETID:='',
						DEVICEID:=udiDeviceIdLightBusMaster,
						BOXADDR:=T_BoxId_AdrTmp[iPtrBoxName].wAddrBox,
						START:=TRUE,
						TMOUT:=T#2s);
		IF NOT(fbGetBoxNetId.BUSY) OR fbGetBoxNetId.ERR THEN
			IF fbGetBoxNetId.ERR THEN
			(* acitve error *)
				ptrBoxId^.T_Ctrle.xDone:=FALSE;
				ptrBoxId^.T_Ctrle.xErr:=TRUE;
				ptrBoxId^.T_Ctrle.udiErrorID:=fbGetBoxNetId.ERRID;
			ELSE
				(* get BoxID *)
				T_BoxId_AdrTmp[iPtrBoxName].sAmsNetId:=fbGetBoxNetId.BoxNetId;
				IF iPtrBoxName <> iPtrBoxNameEnd THEN
				(* next box *)
					iPtrBoxName:=iPtrBoxName+1;
					IF (T_BoxId.T_Ctrle.iMachineType = 1) AND (iPtrBoxName = 2) THEN
						iPtrBoxName:=3;
					END_IF;
					(* activ get address *)
					xGetBoxAddress:=TRUE;
				ELSE
				(* activ copy value *)
					xCopyReadyStructure:=TRUE;
				END_IF
			END_IF
			(* init. variable *)
			xGetBoxId:=FALSE;
		END_IF
	ELSE
		fbGetBoxNetId(START:=FALSE);
	END_IF

(* copy read value *)
	IF xCopyReadyStructure THEN
	(* copy value *)
		T_BoxId.T_Servo_ToolLeft:=T_BoxId_AdrTmp[1];
		T_BoxId.T_Servo_ToolCenter:=T_BoxId_AdrTmp[2];
		T_BoxId.T_Servo_ToolRight:=T_BoxId_AdrTmp[3];
		T_BoxId.T_Servo_ToolFeeder:=T_BoxId_AdrTmp[4];
		T_BoxId.T_Servo_GrindFeeder:=T_BoxId_AdrTmp[5];
		(* confirm device list id *)
		ptrBoxId^.T_Ctrle.xDone:=TRUE;
		ptrBoxId^.T_Ctrle.xErr:=FALSE;
		ptrBoxId^.T_Ctrle.udiErrorID:=0;
		(* reset variable *)
		xCopyReadyStructure:=FALSE;
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_CYL_ANALOGCYLINDER
VAR_INPUT
	xCtrlePosOn:BOOL;
	xCtrlePosOff:BOOL;
	iAnalogIn:INT;
END_VAR
VAR_OUTPUT
	xCylinder:BOOL;
	iAnalogOut:INT;
END_VAR
VAR_IN_OUT
	T_Cylinder:ST_CYLINDER;
END_VAR
VAR
(* variable *)
	xConfirmResetFB: BOOL;
	xActivCtrle:BOOL;
	iStep:INT;
(* timer *)
	TimerOn:TON;
	TimerOff:TON;
	TimerPreOn:TON;
	TimerPreOff:TON;
	TimerOut:TON;
	TimerActiv: TON;
(* trigger *)
	RisingEdgeExecute:R_TRIG;
	RisingEdgeReset:R_TRIG;
	RisingEdgeActiv:R_TRIG;
	FallingEdgeActiv:F_TRIG;
	xFct3Activ: BOOL;
	xTmpFct3Activ: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                       This Functionblock is the driver for the ToolTension Cylinder                                                    ************)
(****************************************************************************************************************************************************)
(* if function bloc set activ then Analog state will be transfered *)
	RisingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	FallingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	IF RisingEdgeActiv.Q OR FallingEdgeActiv.Q THEN
		iAnalogOut:=0;
		xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv:= FALSE;
	END_IF
	(* transfer sensor state only if fb is activ *)
	IF T_Cylinder.T_CtrleCyl.xFBActiv THEN
		T_Cylinder.T_CtrleCyl.xStatePosOn:=xCtrlePosOn;
		T_Cylinder.T_CtrleCyl.xStatePosOff:=xCtrlePosOff;
	(* copy state value *)
		T_Cylinder.T_CtrleCyl.T_AnalogCylinder.iAnalogOut:=iAnalogOut;
	ELSE
	(* exit fb *)
		RETURN;
	END_IF

(* wait for reseting *)
	RisingEdgeReset(CLK:=T_Cylinder.T_CtrleCyl.xReset);
	IF RisingEdgeReset.Q THEN
		(* Init. timer *)
		TimerOn(IN:=TRUE,PT:=T#1ms);
		TimerOff(IN:=TRUE,PT:=T#1ms);
		TimerOut(IN:=TRUE,PT:=T#1ms);
		TimerPreOn(IN:=TRUE,PT:=T#1ms);
		TimerPreOff(IN:=TRUE,PT:=T#1ms);
		TimerActiv(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		xActivCtrle:=FALSE;
		iStep:=0;
		xFct3Activ:=FALSE;
		xTmpFct3Activ:=FALSE;
		T_Cylinder.T_CtrleCyl.T_AnalogCylinder.tDelayActiv:=T#0s;
		T_Cylinder.T_Config.tDelayPreOn:=T#0s;
		T_Cylinder.T_Config.tDelayPreOff:=T#0s;
	(* Init. structure *)
		T_Cylinder.T_CtrleCyl.iFunction:=0;
		T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv:= FALSE;
		xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
		iAnalogOut:=0;
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* wait for execute *)
	RisingEdgeExecute(CLK:=T_Cylinder.T_CtrleCyl.xExecute);
	IF RisingEdgeExecute.Q THEN
		IF NOT(T_Cylinder.T_CtrleCyl.xDone) AND NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		(* can execute function if both signal are disable *)
			RETURN;
		END_IF
		CASE T_Cylinder.T_CtrleCyl.iFunction OF
		(* disable *)
		1:	iStep:=11;
		(* Activ without sensor position ctrle *)
		2:	iStep:=1;
		(* set value Analog Out = Analog In *)
		4:	iStep:=21;
		(* inverse cylinder state *)
		51:	iStep:=51;
		ELSE
			(* function not implemented *)
			iStep:=0;
			T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* exit FB *)
		RETURN;
	END_IF

(* Timer activ *)
	TimerOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOn);
	TimerOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOff);
	TimerPreOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOn);
	TimerPreOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOff);
	TimerOut(IN:=TRUE,PT:=T_Cylinder.T_Config.tTimeOut);
	TimerActiv(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_AnalogCylinder.tDelayActiv);
(* waiting for activ *)
	CASE iStep OF
	(* Set Analog output *)
	1:	IF (T_Cylinder.T_Config.tDelayPreOn = T#0s) THEN
			TimerOn(IN:=FALSE);
			iAnalogOut:=iAnalogIn;
			xCylinder:=T_Cylinder.T_Config.xActivState;
			T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv:= TRUE;
			iStep:=2;
		ELSE
			TimerPreOn(IN:=FALSE);
			iStep:=4;
		END_IF;
	(* wait for timer On *)
	2:	IF TimerOn.Q THEN
			iStep:=3;
			TimerOut(IN:=FALSE);
		END_IF
	(* control position activ *)
	3:	IF T_Cylinder.T_Config.xCtrlePosOn THEN
		(* position ctrle activ *)
			IF TimerOut.Q THEN
			(* timerout done, activ error cylinder has not activ position reached *)
				iStep:=999;
			ELSE
				IF xCtrlePosOn THEN
				(* Activ position reached, activ confirmation *)
					iStep:=90;
				END_IF
			END_IF
		ELSE
		(* no position ctrle, activ confirm *)
			iStep:=90;
		END_IF
	(* wait for timer Pre On *)
	4:	IF TimerPreOn.Q THEN
			T_Cylinder.T_Config.tDelayPreOn:=T#0s;
			iStep:=1;
		END_IF
	(* process timer Off *)
	11:	IF (T_Cylinder.T_Config.tDelayPreOff = T#0s) THEN
			TimerOff(IN:=FALSE);
			iAnalogOut:=0;
			xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
			T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv:= FALSE;
			iStep:=12;
		ELSE
			TimerPreOff(IN:=FALSE);
			iStep:=14;
		END_IF;
	(* wait for timer Off *)
	12:	IF TimerOff.Q THEN
			iStep:=13;
			TimerOut(IN:=FALSE);
		END_IF
	(* control position inactiv *)
	13:	IF T_Cylinder.T_Config.xCtrlePosOff THEN
		(* control position activ *)
			IF TimerOut.Q THEN
			(* timerout done, activ error 'cylinder has not inactiv position reached' *)
				iStep:=998;
			ELSE
				IF xCtrlePosOff THEN
				(* inactiv position reached, activ confirmation *)
					iStep:=99;
				END_IF
			END_IF
		ELSE
		(* no control position activ, activ confirmation *)
			iStep:=99;
		END_IF
	(* wait for timer Pre Off *)
	14:	IF TimerPreOff.Q THEN
			T_Cylinder.T_Config.tDelayPreOff:=T#0s;
			iStep:=11;
		END_IF
	(* set value Analog Out = Analog In *)
	21:	xCylinder:=T_Cylinder.T_Config.xActivState;
		T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv:= TRUE;
		iAnalogOut:=iAnalogIn;
		iStep:=99;
	(* inverse cylinder state *)
	51:	IF T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv THEN
			iAnalogOut:=0;
		ELSE
			iAnalogOut:=iAnalogIn;
		END_IF;
		xCylinder:=NOT(xCylinder);
		T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv:=NOT(T_Cylinder.T_CtrleCyl.T_AnalogCylinder.xActiv);
		iStep:=99;
	(* test if delay activ *)
	90:	IF T_Cylinder.T_CtrleCyl.T_AnalogCylinder.tDelayActiv <> T#0s THEN
			TimerActiv(IN:=FALSE);
			iStep:=91;
		ELSE
			iStep:=99;
		END_IF
	(* wait for time delay activ *)
	91:	IF TimerActiv.Q THEN
			T_Cylinder.T_CtrleCyl.T_AnalogCylinder.tDelayActiv:=T#0s;
			iStep:=11;	(* Zylinder wird wieder deaktiviert *)
		END_IF;
	(* no ctrle position *)
	99:	T_Cylinder.T_CtrleCyl.xDone:=TRUE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
	(* error, cylinder not in inactiv position *)
	998:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=TRUE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#F202;
	(* error, cylinder not in activ position *)
	999:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=TRUE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#F201;
	END_CASE
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_CYL_STANDARD
VAR_INPUT
	xCtrlePosOn:BOOL;
	xCtrlePosOff:BOOL;
END_VAR
VAR_OUTPUT
	xCylinder:BOOL;
END_VAR
VAR_IN_OUT
	T_Cylinder:ST_CYLINDER;
END_VAR
VAR
(* variable *)
	xConfirmResetFB:BOOL:=FALSE;
	iStep:INT;
(* timer *)
	TimerOn:TON;
	TimerOff:TON;
	TimerPreOn:TON;
	TimerPreOff:TON;
	TimerOut:TON;
	TimerActiv: TON;
(* trigger *)
	RisingEdgeActiv:R_TRIG;
	FallingEdgeActiv:F_TRIG;
	RisingEdgeReset:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	TimerAfterSensor: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(* if function bloc set activ then Analog state will be transfered *)
	RisingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	FallingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	IF RisingEdgeActiv.Q OR FallingEdgeActiv.Q THEN
	(* set Analog Out = In on the rising edge from the activ signal *)
		xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:= FALSE;
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF T_Cylinder.T_CtrleCyl.xFBActiv THEN
	(* copy control position state *)
		T_Cylinder.T_CtrleCyl.xStatePosOn:=xCtrlePosOn;
		T_Cylinder.T_CtrleCyl.xStatePosOff:=xCtrlePosOff;
	ELSE
	(* exit FB *)
		T_Cylinder.T_CtrleCyl.xStatePosOn:=xCtrlePosOn;
		T_Cylinder.T_CtrleCyl.xStatePosOff:=xCtrlePosOff;
		RETURN;
	END_IF

(* wait for reseting *)
	RisingEdgeReset(CLK:=T_Cylinder.T_CtrleCyl.xReset);
	IF RisingEdgeReset.Q THEN
		(* Init. timer *)
		TimerOn(IN:=TRUE,PT:=T#1ms);
		TimerOff(IN:=TRUE,PT:=T#1ms);
		TimerPreOn(IN:=TRUE,PT:=T#1ms);
		TimerPreOff(IN:=TRUE,PT:=T#1ms);
		TimerOut(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		iStep:=0;
	(* Init. structure *)
		T_Cylinder.T_CtrleCyl.iFunction:=0;
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
		xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF NOT(T_Cylinder.T_CtrleCyl.xFBActiv) THEN
		RETURN;
	END_IF

(* wait for execute *)
	RisingEdgeExecute(CLK:=T_Cylinder.T_CtrleCyl.xExecute);
	IF RisingEdgeExecute.Q THEN
		IF NOT(T_Cylinder.T_CtrleCyl.xDone) AND NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		(* can execute function if both signal are disable *)
			RETURN;
		END_IF
		CASE T_Cylinder.T_CtrleCyl.iFunction OF
		(* disable *)
		1:	iStep:=11;
		(* Activ without sensor position ctrle *)
		2:	iStep:=1;
		(* inverse cylinder state *)
		51:	iStep:=51;
		ELSE
			(* function not implemented *)
			iStep:=0;
			T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* exit FB *)
		RETURN;
	END_IF

(* Timer activ *)
	TimerOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOn);
	TimerOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOff);
	TimerPreOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOn);
	TimerPreOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOff);
	TimerOut(IN:=TRUE,PT:=T_Cylinder.T_Config.tTimeOut);
	TimerActiv(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayActiv);
	TimerAfterSensor(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensor);
(* waiting for activ *)
	CASE iStep OF
	(* process timer On *)
	1:	IF (T_Cylinder.T_Config.tDelayPreOn = T#0s) THEN
			TimerOn(IN:=FALSE);
			xCylinder:=T_Cylinder.T_Config.xActivState;
			T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=TRUE;
			iStep:=2;
		ELSE
			TimerPreOn(IN:=FALSE);
			iStep:=4;
		END_IF;
	(* wait for timer On *)
	2:	IF TimerOn.Q THEN
			iStep:=3;
			TimerOut(IN:=FALSE);
		END_IF
	(* control position activ *)
	3:	IF T_Cylinder.T_Config.xCtrlePosOn THEN
		(* position ctrle activ *)
			IF TimerOut.Q THEN
			(* timerout done, activ error cylinder has not activ position reached *)
				iStep:=999;
			ELSE
				IF xCtrlePosOn THEN
				(* Activ position reached, activ confirmation *)
					iStep:=80;
				END_IF
			END_IF
		ELSE
		(* no position ctrle, activ confirm *)
			iStep:=90;
		END_IF
	(* wait for timer Pre On *)
	4:	IF TimerPreOn.Q THEN
			T_Cylinder.T_Config.tDelayPreOn:=T#0s;
			iStep:=1;
		END_IF
	(* process timer Off *)
	11:	IF (T_Cylinder.T_Config.tDelayPreOff = T#0s) THEN
			TimerOff(IN:=FALSE);
			xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
			T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
			iStep:=12;
		ELSE
			TimerPreOff(IN:=FALSE);
			iStep:=14;
		END_IF;
	(* wait for timer Off *)
	12:	IF TimerOff.Q THEN
			iStep:=13;
			TimerOut(IN:=FALSE);
		END_IF
	(* control position inactiv *)
	13:	IF T_Cylinder.T_Config.xCtrlePosOff THEN
		(* control position activ *)
			IF TimerOut.Q THEN
			(* timerout done, activ error 'cylinder has not inactiv position reached' *)
				iStep:=998;
			ELSE
				IF xCtrlePosOff THEN
				(* inactiv position reached, activ confirmation *)
					iStep:=85;
				END_IF
			END_IF
		ELSE
		(* no control position activ, activ confirmation *)
			iStep:=99;
		END_IF
	(* wait for timer Pre Off *)
	14:	IF TimerPreOff.Q THEN
			T_Cylinder.T_Config.tDelayPreOff:=T#0s;
			iStep:=11;
		END_IF
	(* inverse cylinder state *)
	51:	xCylinder:=NOT(xCylinder);
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=NOT(T_Cylinder.T_CtrleCyl.T_Standard.xActivOn);
		iStep:=99;
	80:	IF (T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensor <> T#0s) THEN
			TimerAfterSensor(IN:=FALSE);
			iStep:=81;
		ELSE
			iStep:=90;
		END_IF;
	(* wait for time after sensor *)
	81:	IF TimerAfterSensor.Q THEN
			iStep:=90;
		END_IF
	85:	IF (T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensor <> T#0s) THEN
			TimerAfterSensor(IN:=FALSE);
			iStep:=86;
		ELSE
			iStep:=99;
		END_IF;
	(* wait for time after sensor *)
	86:	IF TimerAfterSensor.Q THEN
			iStep:=99;
		END_IF
	(* test if delay activ *)
	90:	IF T_Cylinder.T_CtrleCyl.T_Standard.tDelayActiv <> T#0s THEN
			TimerActiv(IN:=FALSE);
			iStep:=98;
		ELSE
			iStep:=99;
		END_IF
	(* wait for time delay activ *)
	98:	IF TimerActiv.Q THEN
		(* activ time is over, set variable off *)
			xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
			T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
			iStep:=99;
		END_IF
	(* process end *)
	99:	T_Cylinder.T_CtrleCyl.xDone:=TRUE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
	(* error, cylinder not in inactiv position *)
	998:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=TRUE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#F202;
	(* error, cylinder not in activ position *)
	999:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=TRUE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#F201;
	END_CASE
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_DEVICEID
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_DeviceId:ST_DEVICEID;
END_VAR
VAR_OUTPUT
END_VAR
VAR
(* pointer of Device ID *)
	ptrDeviceId: POINTER TO ST_DEVICEID;
(* function bloc *)
	FBGeviceInfoByName:IOF_GetDeviceInfoByName;
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	FallingEdgeBusy:F_TRIG;
(* variable *)
	xGetDeviceId:BOOL:=FALSE;
	xConfirmResetFB:BOOL:=FALSE;
	iPtrDeviceName:INT:=0;
	T_DeviceId_AdrTmp:ARRAY[1..10] OF ST_DEVICEID_DATA_ADR;
	xInitReadStructure: BOOL;
	xCopyReadyStructure:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                                This Functionblock is for init the Beckhoff component                                                          ************)
(****************************************************************************************************************************************************)
(* reset *)
	RisingEdgeResetFB(CLK:=T_DeviceId.T_Ctrle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* init ptr*)
		ptrDeviceId:=ADR(T_DeviceId);
	(* init. variable *)
		xGetDeviceId:=FALSE;
		iPtrDeviceName:=1;
	(* Init. variable *)
		ptrDeviceId^.T_Ctrle.xDone:=FALSE;
		ptrDeviceId^.T_Ctrle.xErr:=FALSE;
		ptrDeviceId^.T_Ctrle.udiErrorID:=0;
	(* activ confirm reset *)
		xConfirmResetFB:=TRUE;
	(* Exit FB *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			ptrDeviceId^.T_Ctrle.xDone:=TRUE;
			ptrDeviceId^.T_Ctrle.xErr:=FALSE;
			ptrDeviceId^.T_Ctrle.udiErrorID:=0;
		(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* execute *)
	RisingEdgeExecute(CLK:=T_DeviceId.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
	(* init ptr*)
		ptrDeviceId:=ADR(T_DeviceId);
		ptrDeviceId^.T_Ctrle.xDone:=FALSE;
		ptrDeviceId^.T_Ctrle.xErr:=FALSE;
		ptrDeviceId^.T_Ctrle.udiErrorID:=0;
	(* activ get device Id *)
		xInitReadStructure:=TRUE;
	(* Exit FB *)
		RETURN;
	END_IF

(* init. read structure *)
	IF xInitReadStructure THEN
	(* PLC name *)
		T_DeviceId_AdrTmp[1]:=T_DeviceId.T_CX1020;
		(* feldbus name *)
		T_DeviceId_AdrTmp[2]:=T_DeviceId.T_CANOpenMaster;
		T_DeviceId_AdrTmp[4]:=T_DeviceId.T_LightbusMaster;
		(* NovRAM name *)
		T_DeviceId_AdrTmp[3]:=T_DeviceId.T_NovRAM;
		(* end *)
		T_DeviceId_AdrTmp[5].sDeviceName:='';
		(*reset variable*)
		xInitReadStructure:=FALSE;
		iPtrDeviceName:=1;
		(* start device id reading *)
		xGetDeviceId:=TRUE;
	(* Exit FB *)
		RETURN;
	END_IF

(* get device Id *)
	IF xGetDeviceId THEN
		FallingEdgeBusy(CLK:=FBGeviceInfoByName.BUSY);
		IF FallingEdgeBusy.Q THEN
		(* save device id *)
			T_DeviceId_AdrTmp[iPtrDeviceName].udiDeviceID:=FBGeviceInfoByName.DEVICEID;
			T_DeviceId_AdrTmp[iPtrDeviceName].sAmsNetId:=FBGeviceInfoByName.DEVICENETID;
			(* next device *)
			iPtrDeviceName:=iPtrDeviceName+1;
		END_IF
		IF NOT(FBGeviceInfoByName.BUSY) AND T_DeviceId_AdrTmp[iPtrDeviceName].sDeviceName <> '' THEN
			FBGeviceInfoByName(	NETID:='',
								DEVICENAME:=T_DeviceId_AdrTmp[iPtrDeviceName].sDeviceName,
								START:=TRUE,
								TMOUT:=T#2s);
		ELSE
			FBGeviceInfoByName(START:=FALSE);
		END_IF
		IF NOT(FBGeviceInfoByName.BUSY) AND NOT(FBGeviceInfoByName.ERR) AND T_DeviceId_AdrTmp[iPtrDeviceName].sDeviceName = '' THEN
			(* init. variable *)
			xGetDeviceId:=FALSE;
			(* set copy value *)
			xCopyReadyStructure:=TRUE;
		END_IF
		IF FBGeviceInfoByName.ERR THEN
		(* acitve error *)
			IF NOT(T_DeviceId_AdrTmp[iPtrDeviceName].xDeviceOption) THEN
				IF (iPtrDeviceName <> 5) THEN
					ptrDeviceId^.T_Ctrle.xDone:=FALSE;
					ptrDeviceId^.T_Ctrle.xErr:=TRUE;
					ptrDeviceId^.T_Ctrle.udiErrorID:=FBGeviceInfoByName.ERRID;
					(* init. variable *)
					xGetDeviceId:=FALSE;
				ELSE
					(* init. variable *)
					xGetDeviceId:=FALSE;
					(* set copy value *)
					xCopyReadyStructure:=TRUE;
				END_IF;
			END_IF
		END_IF
	ELSE
		FBGeviceInfoByName(START:=FALSE);
	END_IF

(* copy read value *)
	IF xCopyReadyStructure THEN
	(* copy value *)
		(* PLC name *)
		T_DeviceId.T_CX1020:=T_DeviceId_AdrTmp[1];
		(* feldbus name *)
		T_DeviceId.T_CANOpenMaster:=T_DeviceId_AdrTmp[2];
		T_DeviceId.T_LightbusMaster:=T_DeviceId_AdrTmp[4];
		(* NovRAM name *)
		T_DeviceId.T_NovRAM:=T_DeviceId_AdrTmp[3];
		(* confirm device list id *)
		ptrDeviceId^.T_Ctrle.xDone:=TRUE;
		ptrDeviceId^.T_Ctrle.xErr:=FALSE;
		ptrDeviceId^.T_Ctrle.udiErrorID:=0;
		(* reset variable *)
		xCopyReadyStructure:=FALSE;
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_HDD
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_HDD:ST_HDD;
END_VAR
VAR
(* variable *)
	xConfirmResetFB: BOOL;
	i:INT;
	dwOpenFileMod:DWORD;
	udiHdleFile:UINT;
	xFileOpen: BOOL;
	xFileClose:BOOL;
	xFileRead:BOOL;
	xFileAppendWrite:BOOL;
	xFileCreate:BOOL;
	xFileBiggerAsMaxLine:BOOL;
	xFileDelete: BOOL;
	xRenameFile:BOOL;

(* function bloc *)
	fbFileOpen:FB_FileOpen;
	fbFileWrite:FB_FileWrite;

	fbFileClose:FB_FileClose;
	fbFileGets:FB_FileGets;
	fbFilePuts:FB_FilePuts;

	fbFileDelete:FB_FileDelete;
	fbRenameFile:FB_FileRename;
(* Trigger *)
	RisingEdgeExecute:R_TRIG;
	RisingEdgeReset:R_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                                  This Functionblock is for manage the file handling                                                             ************)
(****************************************************************************************************************************************************)
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_HDD.T_Ctrle.xReset);
	IF RisingEdgeReset.Q THEN
	(* init. function bloc *)
		fbFileOpen(bExecute:=FALSE);
		fbFileClose(bExecute:=FALSE);
		fbFileWrite(bExecute:=FALSE);
		fbFileGets(bExecute:=FALSE);
		fbFilePuts(bExecute:=FALSE);
		fbFileDelete(bExecute:=FALSE);
		fbRenameFile(bExecute:=FALSE);
	(* init. variable *)
		dwOpenFileMod:=0;
		udiHdleFile:=0;
		xFileOpen:=FALSE;
		xFileClose:=FALSE;
		xFileRead:=FALSE;
		xFileAppendWrite:=FALSE;
		xFileCreate:=FALSE;
		xFileBiggerAsMaxLine:=FALSE;
		xFileDelete:=FALSE;
		xRenameFile:=FALSE;
	(* init. structure *)
		T_HDD.T_Ctrle.xDone:=FALSE;
		T_HDD.T_Ctrle.xErr:=FALSE;
		T_HDD.T_Ctrle.udiErrorID:=0;
		T_HDD.T_Ctrle.iFunction:=0;
		T_HDD.T_File.sPathAndFileName:='';
		T_HDD.T_File.sOldPathAndFileName:='';
		T_HDD.T_Ctrle.tTimeOut:=T#2s;
		T_HDD.T_Ctrle.xLocked:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_HDD.T_Ctrle.xDone:=TRUE;
			T_HDD.T_Ctrle.xErr:=FALSE;
			T_HDD.T_Ctrle.udiErrorID:=0;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* waiting for execute *)
	RisingEdgeExecute(CLK:=T_HDD.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_HDD.T_Ctrle.iFunction OF
		(* Read file *)
		1:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* Write file *)
		2:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEWRITE OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* overwrite file *)
		3:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEAPPEND OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* file exists *)
		4:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* delete file *)
		5:	xFileDelete:=TRUE;
		(* rename file *)
		6:	xRenameFile:=TRUE;
		ELSE
		(* function not implemented *)
			 T_HDD.T_Ctrle.xDone:=FALSE;
			 T_HDD.T_Ctrle.xErr:=TRUE;
			 T_HDD.T_Ctrle.udiErrorID:=16#F000;
			 T_HDD.T_Ctrle.xLocked:=FALSE;
			 (* exit FB *)
			 RETURN;
		END_CASE
		(* Init. variable *)
		T_HDD.T_Ctrle.xDone:=FALSE;
		T_HDD.T_Ctrle.xErr:=FALSE;
		T_HDD.T_Ctrle.udiErrorID:=16#0;
		xFileBiggerAsMaxLine:=FALSE;
		(* init. variable*)
		i:=1;
		RETURN;
	END_IF

(* Open file *)
	IF xFileOpen THEN
		fbFileOpen(	sNetId:=T_HDD.T_Config.sNetId,
					sPathName:=T_HDD.T_File.sPathAndFileName,
					nMode:=dwOpenFileMod,
					bExecute:=TRUE,
					tTimeout:=T#2s);
		IF NOT(fbFileOpen.bBusy) OR fbFileOpen.bError THEN
			IF NOT(fbFileOpen.bError) THEN
				CASE T_HDD.T_Ctrle.iFunction OF
				1:	xFileRead:=TRUE;
				2:	xFileCreate:=TRUE;
				3: 	xFileAppendWrite:=TRUE;
				4:	xFileClose:=TRUE;
				END_CASE
				(* Handle file *)
				udiHdleFile:=fbFileOpen.hFile;
			ELSE
				udiHdleFile:=0;
				 T_HDD.T_Ctrle.xDone:= FALSE;
				 T_HDD.T_Ctrle.xErr:=fbFileOpen.bError;
				 T_HDD.T_Ctrle.udiErrorID:=fbFileOpen.nErrId;
				 T_HDD.T_Ctrle.xLocked:=FALSE;
			END_IF
			(* set flag xfileopen off *)
			xFileOpen:=FALSE;
		END_IF
	ELSE fbFileOpen(bExecute:=FALSE); END_IF

(* Read file *)
	IF xFileRead THEN
		fbFileGets(	sNetId:=T_HDD.T_Config.sNetId,
					hFile:=udiHdleFile,
					bExecute:=TRUE,
					tTimeOut:=T_HDD.T_Ctrle.tTimeOut);
		IF NOT(fbFileGets.bBusy) OR fbFileGets.bError THEN
			T_HDD.T_Data.sData[i]:=fbFileGets.sLine;
			(* check eof or error *)
			IF fbFileGets.bEOF OR fbFileGets.bError OR i = csiMaxFileLine THEN
				 (* set flag xFileRead off *)
				 xFileRead:=FALSE;
				 (* activ closing file *)
				 xFileClose:=TRUE;
				 (* activ variable file bigger as structure *)
				 IF i = csiMaxFileLine THEN xFileBiggerAsMaxLine:=TRUE; END_IF
			ELSE
			(* read next line *)
				fbFileGets(bExecute:=FALSE);
				i:=i+1;
			END_IF
		END_IF
	ELSE fbFileGets(bExecute:=FALSE); END_IF

(* Write at the end of file or create file *)
	IF xFileAppendWrite OR xFileCreate THEN
		fbFilePuts(	sNetId:=T_HDD.T_Config.sNetId,
					hFile:=udiHdleFile,
					sLine:=CONCAT(T_HDD.T_Data.sData[i],'$L'),
					bExecute:=TRUE,
					tTimeOut:=T_HDD.T_Ctrle.tTimeOut);
		IF NOT(fbFilePuts.bBusy) OR fbFilePuts.bError THEN
			IF T_HDD.T_Data.sData[i+1] = '' THEN
				 (* set flag xFileCreate or xFileAppendWrite off *)
				xFileAppendWrite:=FALSE;
				xFileCreate:=FALSE;
				 (* activ closing file *)
				 xFileClose:=TRUE;
			ELSE
			(* Init. FB *)
				 fbFilePuts(bExecute:=FALSE);
				 (* next line *)
				i:=i+1;
			END_IF
		END_IF
	ELSE IF NOT(xFileAppendWrite) AND NOT(xFileCreate) THEN fbFilePuts(bExecute:=FALSE); END_IF
	END_IF

(* Close file *)
	IF xFileClose THEN
		fbFileClose(	sNetId:=T_HDD.T_Config.sNetId,
					hFile:=udiHdleFile,
					bExecute:=TRUE,
					tTimeout:=T#2s);
		IF NOT(fbFileClose.bBusy) OR fbFileClose.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbFileClose.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbFileClose.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbFileClose.nErrId;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			 udiHdleFile:=0;
			(* check if file bigger as maximum reading line *)
			IF xFileBiggerAsMaxLine THEN
				T_HDD.T_Ctrle.xErr:=TRUE;
				T_HDD.T_Ctrle.udiErrorID:=16#F501;
			END_IF
			 (* set flag xFileClose off *)
			 xFileClose:=FALSE;
		END_IF
	ELSE fbFileClose(bExecute:=FALSE); END_IF

(* Delete file *)
	IF xFileDelete THEN
		fbFileDelete(	sNetId:=T_HDD.T_Config.sNetId,
					sPathName:=T_HDD.T_File.sPathAndFileName,
					bExecute:=TRUE,
					tTimeout:=T#2s);
		IF NOT(fbFileDelete.bBusy) OR fbFileDelete.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbFileDelete.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbFileDelete.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbFileDelete.nErrId;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			 (* set flag xFileDelete off *)
			 xFileDelete:=FALSE;
		END_IF
	ELSE fbFileDelete(bExecute:=FALSE); END_IF

(* rename file *)
	IF xRenameFile THEN
		fbRenameFile(	sNetId:=T_HDD.T_Config.sNetId,
						sOldName:=T_HDD.T_File.sOldPathAndFileName,
						sNewName:=T_HDD.T_File.sPathAndFileName,
						ePath:=PATH_GENERIC,
						bExecute:=TRUE,
						tTimeout:=T#2s);
		IF NOT(fbRenameFile.bBusy) OR fbRenameFile.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbRenameFile.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbRenameFile.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbRenameFile.nErrId;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			 (* set flag xFileDelete off *)
			 xRenameFile:=FALSE;
		END_IF
	ELSE fbRenameFile(bExecute:=FALSE); END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_NOVRAM
VAR_INPUT
	udiDeviceID:UDINT;
END_VAR
VAR_IN_OUT
	T_NovRam:ST_NOVRAM;
END_VAR
VAR_OUTPUT
END_VAR
VAR
(* function bloc *)
	fbNovRamReadWrite:FB_NovRamReadWrite;
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
(* variable *)
	xRead:BOOL:=FALSE;
	xWrite:BOOL:=FALSE;
	xConfirmResetFB: BOOL;
	xDummy1: BOOL;
	xDummy2: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                            This Functionblock is for manage the NovRAM handling                                                      ************)
(****************************************************************************************************************************************************)
(* reset *)
	RisingEdgeResetFB(CLK:=T_NovRam.T_Ctrle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* init. variable *)
		xRead:=FALSE;
		xWrite:=FALSE;
	(* activ confirmation reset *)
		xConfirmResetFB:=TRUE;
	(* Exit FB *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_NovRam.T_Ctrle.xFirstRead:=FALSE;
			T_NovRam.T_Ctrle.xDone:=TRUE;
			T_NovRam.T_Ctrle.xErr:=FALSE;
			T_NovRam.T_Ctrle.udiErrorID:=16#0;
		(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* execute *)
	RisingEdgeExecute(CLK:=T_NovRam.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		(* init. capacity and pointer *)
		T_NovRam.T_Ctrle.udipSrcAddr:=ADR(T_NovRam.T_Data);
		T_NovRam.T_Ctrle.udiSrcLen:=SIZEOF(T_NovRam.T_Data);
		T_NovRam.T_Ctrle.udipDestAddr:=ADR(T_NovRam.T_Data);
		T_NovRam.T_Ctrle.udiDestLen:=SIZEOF(T_NovRam.T_Data);
		CASE T_NovRam.T_Ctrle.iFunction OF
		(* Read *)
		1:	xRead:=TRUE;
		(* Write *)
		2:	xWrite:=TRUE;
		ELSE
		(* function not implemented *)
			T_NovRam.T_Ctrle.xDone:=FALSE;
			T_NovRam.T_Ctrle.xErr:=TRUE;
			T_NovRam.T_Ctrle.udiErrorID:=16#F000;
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_NovRam.T_Ctrle.xDone:=FALSE;
		T_NovRam.T_Ctrle.xErr:=FALSE;
		T_NovRam.T_Ctrle.udiErrorID:=0;
	(* Exit FB *)
		RETURN;
	END_IF

(* wait for read/write *)
	IF xRead OR xWrite THEN
		IF xWrite THEN
			xDummy1:=TRUE;
			xDummy2:=FALSE;
		END_IF;
		IF xRead THEN
			xDummy2:=TRUE;
			xDummy1:=FALSE;
		END_IF;
		fbNovRamReadWrite(	nDevId:=udiDeviceID,
							bRead:=xRead,
							bWrite:=xWrite,
							cbSrcLen:=T_NovRam.T_Ctrle.udiSrcLen,
							cbDestLen:=T_NovRam.T_Ctrle.udiDestLen,
							pSrcAddr:=T_NovRam.T_Ctrle.udipSrcAddr,
							pDestAddr:=T_NovRam.T_Ctrle.udipDestAddr,
							tTimeOut:=T_NovRam.T_Ctrle.tTimeOut);
		IF NOT(fbNovRamReadWrite.bBusy) OR fbNovRamReadWrite.bError THEN
			IF fbNovRamReadWrite.bError THEN
			(* set error *)
				T_NovRam.T_Ctrle.xDone:=FALSE;
				T_NovRam.T_Ctrle.xErr:=TRUE;
				T_NovRam.T_Ctrle.udiErrorID:=fbNovRamReadWrite.nErrId;
			ELSE
			(* confirm execution *)
				IF xRead THEN
					IF NOT(T_NovRam.T_Ctrle.xBlockReadFirstTime) THEN
						T_NovRam.T_Ctrle.xFirstRead:=TRUE;
					ELSE
						T_NovRam.T_Ctrle.xFirstRead:=FALSE;
					END_IF;
					T_NovRam.T_Ctrle.xBlockReadFirstTime:=FALSE;
				END_IF
				T_NovRam.T_Ctrle.xDone:=TRUE;
				T_NovRam.T_Ctrle.xErr:=FALSE;
				T_NovRam.T_Ctrle.udiErrorID:=0;
			END_IF
			(* reset variable *)
			xRead:=FALSE;
			xWrite:=FALSE;
		END_IF
	ELSE
		fbNovRamReadWrite(	nDevId:=udiDeviceID,
							bRead:=FALSE,
							bWrite:=FALSE);
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_PANEL_IO
VAR_INPUT
	arxButton:ARRAY[1..10] OF BOOL;
END_VAR
VAR_OUTPUT
	arxLed:ARRAY[1..10] OF BOOL;
END_VAR
VAR_IN_OUT
	T_CtrlePanel:ST_CTRLEPANEL;
END_VAR
VAR
(* variable *)
	xConfirmResetFB:BOOL;
	xConfirmFct:BOOL;
	i: INT;
	si: SINT;
(* trigger *)
	RisingEdgeExecute:R_TRIG;
	RisingEdgeReset:R_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                            This Functionblock is for manage the IO's of the ControlPanel                                             ************)
(****************************************************************************************************************************************************)
(* reset function bloc *)
	RisingEdgeReset(CLK:=T_CtrlePanel.xReset);
	IF RisingEdgeReset.Q THEN
	(* reset output *)
		FOR i := 1 TO 10 DO
			arxLed[i]:=FALSE;
		END_FOR
	(* init. structure *)
		T_CtrlePanel.iFunction:=0;
		T_CtrlePanel.xDone:=FALSE;
		T_CtrlePanel.xErr:=FALSE;
		T_CtrlePanel.udiErrorID:=0;
		T_CtrlePanel.udiButton:=0;
		T_CtrlePanel.udiLED:=0;
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit fb *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_CtrlePanel.xDone:=TRUE;
			T_CtrlePanel.xErr:=FALSE;
			T_CtrlePanel.udiErrorID:=0;
			(* Init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* Switch on/off the Led from the control panel *)
	RisingEdgeExecute(CLK:=T_CtrlePanel.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_CtrlePanel.iFunction OF
		(* switch off a specific LED off *)
		-10..-1:	IF arxLed[ABS(T_CtrlePanel.iFunction)] THEN
					arxLed[ABS(T_CtrlePanel.iFunction)]:=FALSE;
					T_CtrlePanel.udiLED:=T_CtrlePanel.udiLED - MUX(ABS(T_CtrlePanel.iFunction)-1,1,2,4,8,16,32,64,128,256,512);
				END_IF
		(* switch off all the LED *)
		0:	FOR i := 1 TO 10 DO
				arxLed[i]:=FALSE;
			END_FOR
			T_CtrlePanel.udiLED:=0;
		(* switch on a specific Led on *)
		1..10:	IF NOT(arxLed[T_CtrlePanel.iFunction]) THEN
					arxLed[T_CtrlePanel.iFunction]:=TRUE;
					T_CtrlePanel.udiLED:=T_CtrlePanel.udiLED + MUX(T_CtrlePanel.iFunction-1,1,2,4,8,16,32,64,128,256,512);
				END_IF
		ELSE
			(* function not implemented *)
			T_CtrlePanel.xDone:=FALSE;
			T_CtrlePanel.xErr:=TRUE;
			T_CtrlePanel.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_CtrlePanel.xDone:=FALSE;
		T_CtrlePanel.xErr:=FALSE;
		T_CtrlePanel.udiErrorID:=16#0;
		(* activ confirm *)
		xConfirmFct:=TRUE;
		(* exit FB *)
		RETURN;
	END_IF

(* return the button state *)
	T_CtrlePanel.udiButton:=0;
	FOR i := 0 TO 9 DO
		IF arxButton[i+1] THEN
			T_CtrlePanel.udiButton:=T_CtrlePanel.udiButton + MUX(i,1,2,4,8,16,32,64,128,256,512);
		END_IF
	END_FOR

(* set the led state *)
	FOR si := 0 TO 9 DO
		IF GETBIT32(T_CtrlePanel.udiLED,si) <> 16#0 THEN
			arxLed[si+1]:=TRUE; ELSE arxLed[si+1]:=FALSE; END_IF
	END_FOR

(* wait to confirm *)
	IF xConfirmFct THEN
		T_CtrlePanel.xDone:=TRUE;
		T_CtrlePanel.xErr:=FALSE;
		T_CtrlePanel.udiErrorID:=16#0;
		(* reset variable *)
		xConfirmFct:=FALSE;
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION FCT_GET_AXIS_ERROR : UDINT
VAR_INPUT
	dwInputBitStructError:DWORD;
END_VAR
VAR
	udiTmpErrorID:UDINT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                             This Functionblock read the Axis error of the EcoStep drive                                                ************)
(****************************************************************************************************************************************************)
udiTmpErrorID:=0;
IF GETBIT32(dwInputBitStructError,0) THEN
	udiTmpErrorID:=16#F801;	(* Interne Ursache, darf niemals auftreten *)
END_IF;
IF GETBIT32(dwInputBitStructError,1) THEN
	udiTmpErrorID:=16#F802;	(* Interne Ursache, darf niemals auftreten *)
END_IF;
IF GETBIT32(dwInputBitStructError,2) THEN
	udiTmpErrorID:=16#F803;	(* Antivalenzfehler der Motorencodersignale (auf Drahtbruch beim Encoder an X8 prüfen) *)
END_IF;
IF GETBIT32(dwInputBitStructError,3) THEN
	udiTmpErrorID:=16#F804;	(* Encoder Zählfehler, >+/-4 inc, Encoderscheibe beschädigt oder verspannt *)
END_IF;
IF GETBIT32(dwInputBitStructError,4) THEN
	udiTmpErrorID:=16#F805;	(* Master Encoder X7 Zählfehler, >+/-4 inc, Encoderscheibe beschädigt oder verspannt *)
END_IF;
IF GETBIT32(dwInputBitStructError,5) THEN
	udiTmpErrorID:=16#F806;	(* Kühlkörpertemperatur zu hoch (> 80°) *)
END_IF;
IF GETBIT32(dwInputBitStructError,6) THEN
	udiTmpErrorID:=16#F807;	(* Unterspannung (<18V) der +24V Logikversorgung *)
END_IF;
IF GETBIT32(dwInputBitStructError,7) THEN
	udiTmpErrorID:=16#F808;	(* Überspannung X10 (>180V) der Leistungsversorgung DC_BUS (Netzteil prüfen;Rückspeisung beachten!) *)
END_IF;
IF GETBIT32(dwInputBitStructError,8) THEN
	udiTmpErrorID:=16#F809;	(* Unterspannung X10 (<24V) der Leistungsversorgung DC_BUS (Netzteil prüfen!) *)
END_IF;
IF GETBIT32(dwInputBitStructError,9) THEN
	udiTmpErrorID:=16#F80A;	(* Kurzschluss in Motorphase A *)
END_IF;
IF GETBIT32(dwInputBitStructError,10) THEN
	udiTmpErrorID:=16#F80B;	(* Kurzschluss in Motorphase B *)
END_IF;
IF GETBIT32(dwInputBitStructError,11) THEN
	udiTmpErrorID:=16#F80C;	(* Kurzschluss eines digitalen Ausgangs während Antrieb eingeschaltet war *)
END_IF;
IF GETBIT32(dwInputBitStructError,12) THEN
	udiTmpErrorID:=16#F80D;	(* Digital-Eingang "ENABLE" wurde auf Low-Pegel gesetzt während der Antrieb eingeschaltet war *)
END_IF;
IF GETBIT32(dwInputBitStructError,13) THEN
	udiTmpErrorID:=16#F80E;	(* Max. Schleppfehler überschritten (im Positioniermodus) *)
END_IF;
IF GETBIT32(dwInputBitStructError,14) THEN
	udiTmpErrorID:=16#F80F;	(* Drehzahl zu hoch, Regler kann Encoder nicht mehr auslesen (>4MHz) *)
END_IF;
IF GETBIT32(dwInputBitStructError,15) THEN
	udiTmpErrorID:=16#F810;	(* Kommutierung nicht gefunden *)
END_IF;
IF GETBIT32(dwInputBitStructError,16) THEN
	udiTmpErrorID:=16#F811;	(* CAN-Kommunikation unterbrochen bei Node Guarding *)
END_IF;
IF GETBIT32(dwInputBitStructError,17) THEN
	udiTmpErrorID:=16#F812;	(* I^2t- Überwachung ausgelöst (Stromgrenze) *)
END_IF;
FCT_GET_AXIS_ERROR:=udiTmpErrorID;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_BIOSPARAMETER
VAR_INPUT
	dwBIOSPasswordPage:DWORD;		(* Page number of the BIOS password page *)
	dwBIOSParameterPage:DWORD;		(* Page number of the BIOS parameter page *)
	T_TwinSafeOut:ST_TWINSAFE_OUT;	(* Output of the TwinSAFE components *)
END_VAR
VAR_IN_OUT
	T_Visu:ST_QVIS;						(* Data structure of the visualisation *)
	T_HDD:ST_HDD;						(* Data structure of the File Management *)
	T_NovRam : ST_NOVRAM;				(* Data structure of the NovRam *)
	T_CtrlePanel:ST_CTRLEPANEL;		(* Data structure of the ControlPanel *)
	T_DeviceID:ST_DEVICEID;				(* Data structure of the Device components *)
	T_BoxID:ST_BOXID;					(* Data structure of the components with the BoxId *)
	T_Profile:ST_PROFILE;				(* Data structure of the Profile management *)
END_VAR
VAR_OUTPUT
END_VAR
VAR
	TONShowMessage: TON;
	xChangeToBIOSPassword: BOOL;
	xChangeToBIOSParameter: BOOL;
	xSaveBIOSParameterToNovRAM: BOOL;
	xCopyBIOSParameter: BOOL;
	xReadFirstTimeParameter: BOOL;
	iStepSaveToNovRAM: INT;
	iStepReadFirstTimeParameter: INT;
	xCheckMsgBoxActive: BOOL;
(* Random *)
	fbGetCpuAccount:GETCPUCOUNTER;
	fbPwSystem:FBPW_SYSTEM;
	iPwSystem:INT;
	xNovRAMParaReaded: BOOL;
	xTmp: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********     This Functionblock gives the possibility to set the bios parameter, with input a SystemLevel password     ************)
(****************************************************************************************************************************************************)
(* Managing BIOS Parameter on Startup *)
	IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS <> 0) THEN
		TONShowMessage(IN:=TRUE,PT:=T#3s);
		IF TONShowMessage.Q THEN
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS:=0;
		END_IF;
	ELSE
		TONShowMessage(IN:=FALSE);
	END_IF;
	xCheckMsgBoxActive:=	(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError <> 0) OR
							(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo <> 0) OR
							(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning <> 0);
	IF ((T_Visu.T_PlcParam.dwActualPage = 0) AND NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone) OR xCheckMsgBoxActive THEN
		xChangeToBIOSPassword:=FALSE;
		xChangeToBIOSParameter:=FALSE;
		xSaveBIOSParameterToNovRAM:=FALSE;
		xCopyBIOSParameter:=FALSE;
		xReadFirstTimeParameter:=FALSE;
		iStepSaveToNovRAM:=1;
		iStepReadFirstTimeParameter:=1;
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS:=0;
		IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = DWORD_TO_INT(dwBIOSParameterPage)) THEN
			T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=0;
		END_IF;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = dwBIOSPasswordPage) OR (T_Visu.T_PlcParam.dwActualPage = dwBIOSParameterPage) THEN
		IF (T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage = 2) THEN	(* check if external relase button has been pressed *)
			IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
				T_Visu.T_PlcParam.dwSetNewPage:=0;
				T_Visu.T_CtrleVisu.iFunction:=1;
				T_Visu.T_CtrleVisu.xExecute:=TRUE;
			END_IF;
		END_IF;
	END_IF;
	(* check if the function button F1 is pressed-->if it is pressed the change to the BIOS password page *)
	IF NOT(xChangeToBIOSPassword) THEN
		IF (T_Visu.T_PlcParam.dwActualPage = 0) AND NOT(T_StartUp.T_State.xCompleted) THEN
			IF (T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage = 1) AND NOT(T_TwinSafeOut.QxContactor_K3) AND NOT(T_TwinSafeOut.QxContactor_K4) THEN
				IF T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wActivBt = 16#1 THEN
					T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wActivBt:=0;
					IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS:=0;
						xChangeToBIOSPassword:=TRUE;
						T_Visu.T_PlcParam.dwSetNewPage:=dwBIOSPasswordPage;
						T_Visu.T_CtrleVisu.iFunction:=1;
						T_Visu.T_CtrleVisu.xExecute:=TRUE;
						fbGetCpuAccount;
						fbPwSystem(	dwCounter:=fbGetCpuAccount.fbGetCpuCounter.dwCpuCntHi+fbGetCpuAccount.fbGetCpuCounter.dwCpuCntLo,
									iRandom=>T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iRandom,
									iPwSystem=>iPwSystem);
					END_IF;
				END_IF;
			END_IF;
		END_IF;
	END_IF;
	(* check the settled password *)
	IF xChangeToBIOSPassword THEN
		IF (T_Visu.T_PlcParam.dwActualPage = dwBIOSPasswordPage) THEN
			IF T_Visu.ptrT_ExchgParam^.T_Visu.xKey_Escape THEN	(* ESC Button for exit and go to the Startpage *)
				T_Visu.ptrT_ExchgParam^.T_Visu.xKey_Escape:=FALSE;
				IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					xChangeToBIOSPassword:=FALSE;
					T_Visu.T_PlcParam.dwSetNewPage:=0;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
				END_IF;
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem = iPwSystem) THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS:=0;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
				IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					xChangeToBIOSPassword:=FALSE;
					xChangeToBIOSParameter:=TRUE;
					T_Visu.T_PlcParam.dwSetNewPage:=dwBIOSParameterPage;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
					IF NOT(T_NovRam.T_Ctrle.xFirstRead) THEN
						xReadFirstTimeParameter:=TRUE;
					ELSE
						xCopyBIOSParameter:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem <> 999) THEN
				IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem <> iPwSystem) THEN
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS:=2;	(* Wrong password *)
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
				END_IF;
			END_IF;
		END_IF;
	END_IF;
	(* the edit parameterlist is now active *)
	IF xChangeToBIOSParameter AND NOT(xReadFirstTimeParameter) THEN
		T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=DWORD_TO_INT(dwBIOSParameterPage);
		IF (T_Visu.T_PlcParam.dwActualPage = dwBIOSParameterPage) AND NOT(xReadFirstTimeParameter) AND NOT(xSaveBIOSParameterToNovRAM) AND NOT(xCopyBIOSParameter) THEN
			IF T_Visu.ptrT_ExchgParam^.T_Visu.xKey_Escape THEN	(* ESC Button for exit and go to the Startpage *)
				T_Visu.ptrT_ExchgParam^.T_Visu.xKey_Escape:=FALSE;
				IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					xChangeToBIOSParameter:=FALSE;
					xSaveBIOSParameterToNovRAM:=FALSE;
					xCopyBIOSParameter:=TRUE;
					T_Visu.T_PlcParam.dwSetNewPage:=0;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF (UDINT_TO_WORD(T_CtrlePanel.udiButton) = 16#200) AND NOT(xSaveBIOSParameterToNovRAM) THEN	(* Right Panel Button for save Parameter *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iStateBIOS:=1;	(* Parameter saved *)
				xSaveBIOSParameterToNovRAM:=TRUE;
				xCopyBIOSParameter:=FALSE;
				iStepSaveToNovRAM:=1;
			END_IF;
		END_IF;
	END_IF;
	(* save the settled parameter to the NovRam *)
	IF xSaveBIOSParameterToNovRAM THEN
		CASE iStepSaveToNovRAM OF
		1:	IF xNovRAMParaReaded THEN
				(* 30.11.2010 KFS: {	*)
				IF ( T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength <> T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength) THEN
					T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal:=0.0;
				END_IF;
				(* 30.11.2010 KFS:	}	*)
				T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType:=T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigMachineType;
				T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigAxisType:=T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigAxisType;
				T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation:=T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigVisuNavigation;
				T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength;
				T_NovRAM.T_Ctrle.iFunction:=2;
				T_NovRAM.T_Ctrle.xExecute:=TRUE;
				iStepSaveToNovRAM:=10;
			ELSE
				iStepSaveToNovRAM:=1;
				xSaveBIOSParameterToNovRAM:=FALSE;
			END_IF;
		10:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone THEN
				iStepSaveToNovRAM:=1;
				xSaveBIOSParameterToNovRAM:=FALSE;
				T_Visu.T_CtrleVisu.xReset:=TRUE;	(* Exit the BIOS Parameter Page *)
			END_IF;
		END_CASE;
	END_IF;
	(* copy the NovRam config parameter to the visu structure *)
	IF xCopyBIOSParameter THEN
		IF xNovRAMParaReaded THEN
			T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigMachineType:=T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigAxisType:=T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigAxisType;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigVisuNavigation:=T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength:=T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLengthOriginal:=T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal;
			xCopyBIOSParameter:=FALSE;
		ELSE
			xCopyBIOSParameter:=FALSE;
		END_IF;
	END_IF;
	(* Init the Hardware for read the first time the parameter *)
	IF xReadFirstTimeParameter THEN
		CASE iStepReadFirstTimeParameter OF
		1:	T_HDD.T_Ctrle.xReset:=TRUE;
			T_DeviceID.T_Ctrle.xReset:=TRUE;
			T_BoxID.T_Ctrle.xReset:=TRUE;
			T_NovRAM.T_Ctrle.xReset:=TRUE;
			T_Profile.T_Ctrle.xReset:=TRUE;
			(* next step *)
			iStepReadFirstTimeParameter:=10;
			(* waiting reset confirmation *)
		10:	xTmp:=	T_HDD.T_Ctrle.xDone
					AND T_DeviceID.T_Ctrle.xDone
					AND T_NovRAM.T_Ctrle.xDone
					AND T_BoxID.T_Ctrle.xDone
					AND T_Profile.T_Ctrle.xDone;
			IF xTmp THEN  iStepReadFirstTimeParameter:=20; END_IF
		20:	(* PLC name *)
			T_DeviceID.T_CX1020.sDeviceName:='CX1000_PLC';
			(* feldbus name *)
			T_DeviceID.T_CANOpenMaster.sDeviceName:='CANOpenMaster';
			T_DeviceID.T_CANOpenMaster.xDeviceOption:=TRUE;
			T_DeviceID.T_LightbusMaster.sDeviceName:='LightbusMaster';
			T_DeviceID.T_LightbusMaster.xDeviceOption:=TRUE;
			(* NovRAM *)
			T_DeviceID.T_NovRAM.sDeviceName:='NovRAM';
			(* read device ID *)
			T_DeviceID.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepReadFirstTimeParameter:=30;
		(* waiting ID confirmation, Start BoxID *)
		30:	IF NOT(T_DeviceID.T_Ctrle.xExecute) AND T_DeviceID.T_Ctrle.xDone THEN iStepReadFirstTimeParameter:=40; END_IF
		(* waiting Box ID confirmation *)
		40:	IF NOT(T_BoxID.T_Ctrle.xExecute) AND T_BoxID.T_Ctrle.xDone THEN
				(* next step *)
				iStepReadFirstTimeParameter:=50;
			END_IF
		50:	T_NovRAM.T_Ctrle.iFunction:=1;
			T_NovRam.T_Ctrle.xBlockReadFirstTime:=TRUE;
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			iStepReadFirstTimeParameter:=60;
		60:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone THEN
				xNovRAMParaReaded:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigMachineType:=T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigAxisType:=T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigAxisType;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigVisuNavigation:=T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength:=T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLengthOriginal:=T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal;
				xReadFirstTimeParameter:=FALSE;
				iStepReadFirstTimeParameter:=1;
			END_IF;
		END_CASE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALC_GEARFACTOR
VAR_INPUT
	rSpeed:REAL;				(* Speed in mm/s *)
	rToolRotationSpeed:REAL;		(* Speed in U/Min *)
	T_WorkTool:ST_WORKTOOL;	(* Tool Parameter *)
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                 This Functionblock calculate the gear factor for the ToolFeeder axis                                           ************)
(****************************************************************************************************************************************************)
(* Set ToolFeeder Speed in mm/s *)
	T_WorkTool.rToolFeederSpeedUnit:=rSpeed;
(* Set ToolRotation Speed in U/Min *)
	T_WorkTool.rToolRotationSpeed:=rToolRotationSpeed;
(* calcul ToolRotation Speed in inc/64s *)
	T_WorkTool.rToolRotationSpeedMotor:=((T_WorkTool.rToolRotationSpeed / 60.0) * 8000.0 * 64.0) / T_WorkTool.rToolRightGearRatio;
(* calcul ToolFeeder Speed in inc/64s Relativ *)
	T_WorkTool.rToolFeederSpeedMotorRel:=T_WorkTool.rToolFeederScaleFactor * T_WorkTool.rToolFeederSpeedUnit * 64.0;
(* calcul ToolFeeder Speed in inc/64s Relativ *)
	T_WorkTool.rToolFeederSpeedMotorAbs:=(T_WorkTool.rToolRotationSpeedMotor * T_WorkTool.rToolRightGearRatio) + T_WorkTool.rToolFeederSpeedMotorRel;
(* Set ToolFeeder GearDivider *)
	T_WorkTool.iToolFeederGearDivider:=T_WorkTool.iBaseGearDivider;
(* calcul ToolFeeder GearFactor *)
	IF (rSpeed <> 0) THEN
		T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorAbs));
	ELSE
		T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iToolFeederGearDivider) * T_WorkTool.rToolRightGearRatio);
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALC_PLUNGE_GRINDING
VAR_INPUT
	T_Geometry:ST_GEOMETRY;								(* Structure of the NovRAM parameter *)
	T_AutoGeometryPara:ST_EXCHG_PARAM_AUTOGEOMETRY;	(* Structure of the NovRAM parameter *)
	rToolDiameter:REAL;					(* diameter of the unworked Tool *)
	rToolDiameterWithOffset:REAL;			(* diameter of the unworked Tool plus the offset for plunge and displace procedure *)
	rPlungeCycleGrindFeedGeometry:REAL;	(* max grinding plunging per cycle *)
	iStartSection:INT;						(* number of the start section *)
	iEndSection:INT;						(* number of the end section *)
END_VAR
VAR_IN_OUT
	xReset:BOOL;						(* resetting of the FB *)
END_VAR
VAR_OUTPUT
	iStepSectionWork:INT;				(* actual worked section number *)
	rGrindingRelativePosition:REAL;		(* relative way of the GrindFeeder plunge *)
	xEndWorking:BOOL;				(* end of the hole working procedure *)
	xError:BOOL;						(* error flag *)
END_VAR
VAR
	rActualPositionGrindFeedStart: ARRAY [0..5] OF REAL;	(* 0=StartPos Plunge,1-4=Dynamic StartPos Section 1-4, 5=StartPos Displace *)
	rActualPositionGrindFeedEnd: ARRAY [0..5] OF REAL;	(* 0=EndPos Plunge,1-4=Dynamic EndPos Section 1-4, 5=EndPos Displace *)
	rDistanceToWorkedTool: REAL;
	ii: INT;
	iStepSection: INT;
	axWorkEndSection: ARRAY [0..5] OF BOOL;
	xCheckEnd: BOOL;
	rTmpActualPositionGrindFeedStart:REAL;
	iStepCheckSection: INT;
	rTmpDistance: REAL;
	rGrinded: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********      This Functionblock calculate the plunge way for the GrindFeeder axis for the geometry sections  1-4        ************)
(***********                                           It calculate also the plunge and displace procedure							    ************)
(****************************************************************************************************************************************************)
IF xReset THEN
	xReset:=FALSE;
	iStepSection:=0;
	FOR ii:=0 TO 5 DO
		rActualPositionGrindFeedStart[ii]:=rToolDiameterWithOffset;
		rActualPositionGrindFeedEnd[ii]:=rToolDiameterWithOffset;
		axWorkEndSection[ii]:=FALSE;
	END_FOR;
	rActualPositionGrindFeedStart[0]:=rToolDiameterWithOffset;
	rActualPositionGrindFeedEnd[5]:=rToolDiameterWithOffset;
	rTmpActualPositionGrindFeedStart:=rToolDiameterWithOffset;
	rGrindingRelativePosition:=0.0;
	iStepSectionWork:=0;
	RETURN;
END_IF;
xError:=FALSE;
(* check the settled start and end section *)
IF (iStartSection < 1) OR (iStartSection > 4) THEN
	xError:=TRUE;
	RETURN;
END_IF;
IF (iEndSection < 1) OR (iEndSection > 4) THEN
	xError:=TRUE;
	RETURN;
END_IF;
IF (iStepSection < 0) OR (iStepSection > 5) THEN
	xError:=TRUE;
	RETURN;
END_IF;
CASE iStepSection OF
	(* plunge procedure *)
		0:	iStepCheckSection:=1;
			xCheckEnd:=TRUE;
			(* Check if the end of all section is reached *)
			FOR ii:=iStartSection TO iEndSection DO
				IF (rActualPositionGrindFeedStart[iStepCheckSection] <> T_Geometry.arStartDiameter[ii]) THEN
					xCheckEnd:=FALSE;
				END_IF;
				IF (rActualPositionGrindFeedEnd[iStepCheckSection] <> T_Geometry.arEndDiameter[ii]) THEN
					xCheckEnd:=FALSE;
				END_IF;
				iStepCheckSection:=iStepCheckSection + 1;
			END_FOR;
			xEndWorking:=xCheckEnd;
			IF xEndWorking THEN
				rGrindingRelativePosition:=0.0;
				RETURN;
			END_IF;
			IF (T_Geometry.arStartDiameter[iStartSection] = rActualPositionGrindFeedEnd[0]) THEN	(* check if the defined ToolDiameter for the plunge procedure is reached *)
				axWorkEndSection[0]:=TRUE;
				rGrindingRelativePosition:=rToolDiameterWithOffset - T_Geometry.arStartDiameter[iStartSection];
			END_IF;
			IF NOT(axWorkEndSection[0]) THEN
			(* if the end of the plunge procedure is not reached, then calculate the plunge way of the plunge procedure *)
				rGrindingRelativePosition:=(rToolDiameterWithOffset - rActualPositionGrindFeedEnd[0]) + rPlungeCycleGrindFeedGeometry;
				IF ((rToolDiameterWithOffset - rGrindingRelativePosition) <= T_Geometry.arStartDiameter[iStartSection]) THEN
					rGrindingRelativePosition:=rToolDiameterWithOffset - T_Geometry.arStartDiameter[iStartSection];
				END_IF;
			END_IF;
			rActualPositionGrindFeedStart[0]:=rToolDiameterWithOffset;	(* the start zero section of the geometry is always the diameter of the Tool *)
			rActualPositionGrindFeedEnd[0]:=rToolDiameterWithOffset - rGrindingRelativePosition;	(* calcualte the plunge way *)
			iStepSectionWork:=iStepSection;	(* set the actual section which is working *)
			iStepSection:=iStepSection + 1;		(* go to the next section *)
	(* geometry section 1,2,3 and 4 *)
	1,2,3,4:	rGrinded:=(rActualPositionGrindFeedStart[iStepSection] - rActualPositionGrindFeedEnd[iStepSection - 1]);	(* calculate the difference of the worked section before to the unworked section after *)
			IF (rGrinded < 0) THEN
				rGrinded:=rGrinded;
			END_IF;
			rActualPositionGrindFeedStart[iStepSection]:=rActualPositionGrindFeedStart[iStepSection] - rGrinded;		(* set the new diameter of the section which will going to work *)
			rTmpDistance:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)]; (* set the difference of the start and end diameter of the section *)
			IF (rActualPositionGrindFeedStart[iStepSection] < T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)]) THEN	(* correct of the to grind Tool diameter *)
				rActualPositionGrindFeedStart[iStepSection]:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)];
			END_IF;
			rGrindingRelativePosition:=rPlungeCycleGrindFeedGeometry - rGrinded;	(* calculate the effectiv way for the plunge *)
			IF (rGrinded >= rPlungeCycleGrindFeedGeometry) THEN				(* check if the to grinding way is grater than the defined max grinding *)
				IF (rActualPositionGrindFeedStart[iStepSection] < T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)]) THEN
				(* correct the effective way for the plunge, because it can not work more than the defined grinding way *)
					rGrindingRelativePosition:=rActualPositionGrindFeedStart[iStepSection] - T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)];
				END_IF;
			ELSE
				IF (rTmpDistance = 0) THEN
				(* a cylinder part will now work *)
					rGrindingRelativePosition:=0.0;
				ELSE
					(* a cone part will now work *)
					rTmpDistance:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - rActualPositionGrindFeedEnd[iStepSection];
					rGrindingRelativePosition:=rTmpDistance + rPlungeCycleGrindFeedGeometry;
					IF ((T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - rGrindingRelativePosition) < T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)]) THEN
					(* correct the effective way for the plunge, because it can not work more than the defined grinding way *)
						rGrindingRelativePosition:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)];
					END_IF;
				END_IF;
			END_IF;
			rActualPositionGrindFeedEnd[iStepSection]:=rActualPositionGrindFeedStart[iStepSection] - rGrindingRelativePosition;	(* calculate the end position of the section *)
			iStepSectionWork:=iStepSection;		(* set the actual section which is working *)
			IF ((iStepSection + (iStartSection - 1)) < iEndSection) THEN	(* check if the end section is active *)
				iStepSection:=iStepSection + 1;
			ELSE
				iStepSection:=5;	(* end section is reached-->go the displace procedure *)
			END_IF;
	(* plunge procedure *)
	5:		rActualPositionGrindFeedStart[5]:=rActualPositionGrindFeedEnd[iEndSection - (iStartSection - 1)];	(* set the new diameter of the section which will going to work *)
			rDistanceToWorkedTool:=rActualPositionGrindFeedStart[5] - rToolDiameterWithOffset;	(* check the distance to the end diameter, which will go to work *)
			rGrindingRelativePosition:=rDistanceToWorkedTool;
			IF (rActualPositionGrindFeedStart[5] = T_Geometry.arEndDiameter[iEndSection]) THEN
				axWorkEndSection[5]:=TRUE;		(* the end of this section is reached *)
			ELSE
				axWorkEndSection[5]:=FALSE;		(* the end of this section is reached *)
			END_IF;
			rActualPositionGrindFeedEnd[5]:=rToolDiameterWithOffset;
			iStepSectionWork:=iStepSection;		(* set the actual section which is working *)
			iStepSection:=0;
END_CASE;

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALC_PLUNGE_GRINDING_MultiCycle
VAR_INPUT
	T_Geometry:ST_GEOMETRY;								(* Structure of the NovRAM parameter *)
	T_AutoGeometryPara:ST_EXCHG_PARAM_AUTOGEOMETRY;	(* Structure of the NovRAM parameter *)
	rToolDiameter:REAL;					(* diameter of the unworked Tool *)
	rToolDiameterWithOffset:REAL;			(* diameter of the unworked Tool plus the offset for plunge and displace procedure *)
	rPlungeCycleGrindFeedGeometry:REAL;	(* max grinding plunging per cycle *)
	iStartSection:INT;						(* number of the start section *)
	iEndSection:INT;						(* number of the end section *)
END_VAR
VAR_IN_OUT
	xReset:BOOL;						(* resetting of the FB *)
	xInit:BOOL;							(* Init of the FB *)
END_VAR
VAR_OUTPUT
	iStepSectionWork:INT;				(* actual worked section number *)
	rGrindingRelativePosition:REAL;		(* relative way of the GrindFeeder plunge *)
	xEndWorking:BOOL;				(* end of the hole working procedure *)
	xError:BOOL;						(* error flag *)
END_VAR
VAR
	rActualPositionGrindFeedStart: ARRAY [0..5] OF REAL;	(* 0=StartPos Plunge,1-4=Dynamic StartPos Section 1-4, 5=StartPos Displace *)
	rActualPositionGrindFeedEnd: ARRAY [0..5] OF REAL;	(* 0=EndPos Plunge,1-4=Dynamic EndPos Section 1-4, 5=EndPos Displace *)
	rDistanceToWorkedTool: REAL;
	ii: INT;
	iStepSection: INT;
	axWorkEndSection: ARRAY [0..5] OF BOOL;
	xCheckEnd: BOOL;
	rTmpActualPositionGrindFeedStart:REAL;
	iStepCheckSection: INT;
	rTmpDistance: REAL;
	rGrinded: REAL;
	rMaxPlungeWay:REAL;
	rMaxPlungeWayStepOffset:REAL;
        	diNrOfAdditionalPlungeCycle:DINT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********      This Functionblock calculate the plunge way for the GrindFeeder axis for the geometry sections  1-4        ************)
(***********                                           It calculate also the plunge and displace procedure							    ************)
(****************************************************************************************************************************************************)
IF xReset THEN
	xReset:=FALSE;
	iStepSection:=0;
	FOR ii:=0 TO 5 DO
		rActualPositionGrindFeedStart[ii]:=rToolDiameterWithOffset;
		rActualPositionGrindFeedEnd[ii]:=rToolDiameterWithOffset;
		axWorkEndSection[ii]:=FALSE;
	END_FOR;
	rActualPositionGrindFeedStart[0]:=rToolDiameterWithOffset;
	rActualPositionGrindFeedEnd[5]:=rToolDiameterWithOffset;
	rTmpActualPositionGrindFeedStart:=rToolDiameterWithOffset;
	rGrindingRelativePosition:=0.0;
	iStepSectionWork:=0;
	rMaxPlungeWay:=0.0;
	RETURN;
END_IF;
(*22.12.2009: KFS 	{   *)
IF xInit THEN
	xInit:=FALSE;
(*	rMaxPlungeWay:= rToolDiameter - T_Geometry.arEndDiameter[iEndSection]; (*Calculation of the max. plunge way*)*)
	rMaxPlungeWay:= rToolDiameterWithOffset - T_Geometry.arEndDiameter[iEndSection]; (*Calculation of the max. plunge way*)
	diNrOfAdditionalPlungeCycle:= MODTURNS (rMaxPlungeWay, rPlungeCycleGrindFeedGeometry);
	IF diNrOfAdditionalPlungeCycle > 0 THEN
		rMaxPlungeWayStepOffset:=LMOD(rMaxPlungeWay, rPlungeCycleGrindFeedGeometry);
		IF rMaxPlungeWayStepOffset > 0 THEN
			diNrOfAdditionalPlungeCycle:=diNrOfAdditionalPlungeCycle + 1;
		END_IF;
		rMaxPlungeWay:= rPlungeCycleGrindFeedGeometry * diNrOfAdditionalPlungeCycle;
	END_IF;
	iStepCheckSection:=1;
	(*Add the max plunge way on all start- and stop- points of the geometry*)
	FOR ii:=iStartSection TO iEndSection DO
(*		rActualPositionGrindFeedStart[iStepCheckSection] := rToolDiameterWithOffset - rToolDiameter +T_Geometry.arStartDiameter[ii] + rMaxPlungeWay;
		rActualPositionGrindFeedEnd[iStepCheckSection]:= rToolDiameterWithOffset  - rToolDiameter + T_Geometry.arEndDiameter[ii]+ rMaxPlungeWay; *)
		rActualPositionGrindFeedStart[iStepCheckSection] := T_Geometry.arStartDiameter[ii] + rMaxPlungeWay;
		rActualPositionGrindFeedEnd[iStepCheckSection]:=  T_Geometry.arEndDiameter[ii]+ rMaxPlungeWay;
		iStepCheckSection:=iStepCheckSection + 1;
	END_FOR;
	rActualPositionGrindFeedStart[0]:=rActualPositionGrindFeedStart[1];
	rActualPositionGrindFeedEnd[0]:=rActualPositionGrindFeedStart[1];
	RETURN;
END_IF;
(*22.12.2009: KFS 	}   *)
xError:=FALSE;
(* check the settled start and end section *)
IF (iStartSection < 1) OR (iStartSection > 4) THEN
	xError:=TRUE;
	RETURN;
END_IF;
IF (iEndSection < 1) OR (iEndSection > 4) THEN
	xError:=TRUE;
	RETURN;
END_IF;
IF (iStepSection < 0) OR (iStepSection > 5) THEN
	xError:=TRUE;
	RETURN;
END_IF;
CASE iStepSection OF
	(* plunge procedure *)
		0:	iStepCheckSection:=1;
			xCheckEnd:=TRUE;
			(* Check if the end of all section is reached *)
			FOR ii:=iStartSection TO iEndSection DO
				IF (rActualPositionGrindFeedStart[iStepCheckSection] <> T_Geometry.arStartDiameter[ii]) THEN
					xCheckEnd:=FALSE;
				END_IF;
				IF (rActualPositionGrindFeedEnd[iStepCheckSection] <> T_Geometry.arEndDiameter[ii]) THEN
					xCheckEnd:=FALSE;
				END_IF;
				iStepCheckSection:=iStepCheckSection + 1;
			END_FOR;
			xEndWorking:=xCheckEnd;
			IF xEndWorking THEN
				rGrindingRelativePosition:=0.0;
				RETURN;
			END_IF;
			IF (T_Geometry.arStartDiameter[iStartSection] = rActualPositionGrindFeedEnd[0]) THEN	(* check if the defined ToolDiameter for the plunge procedure is reached *)
				axWorkEndSection[0]:=TRUE;
				rGrindingRelativePosition:=rToolDiameterWithOffset - T_Geometry.arStartDiameter[iStartSection];
			END_IF;
			IF NOT(axWorkEndSection[0]) THEN
			(* if the end of the plunge procedure is not reached, then calculate the plunge way of the plunge procedure *)
				rGrindingRelativePosition:=(rToolDiameterWithOffset - rActualPositionGrindFeedEnd[0]) + rPlungeCycleGrindFeedGeometry;
				IF ((rToolDiameterWithOffset - rGrindingRelativePosition) <= T_Geometry.arStartDiameter[iStartSection]) THEN
					rGrindingRelativePosition:=rToolDiameterWithOffset - T_Geometry.arStartDiameter[iStartSection];
				END_IF;
			END_IF;
			(*22.12.2009: KFS 	{   *)
			(*
			rActualPositionGrindFeedStart[0]:=rToolDiameterWithOffset;	(* the start zero section of the geometry is always the diameter of the Tool *)
			*)
			rActualPositionGrindFeedStart[0]:=rToolDiameterWithOffset - rGrindingRelativePosition;	(* the start zero section of the geometry is always the diameter of the Tool *)
			(*22.12.2009: KFS 	}   *)
			rActualPositionGrindFeedEnd[0]:=rToolDiameterWithOffset - rGrindingRelativePosition;	(* calcualte the plunge way *)
			iStepSectionWork:=iStepSection;	(* set the actual section which is working *)
			iStepSection:=iStepSection + 1;		(* go to the next section *)
	(* geometry section 1,2,3 and 4 *)
	1,2,3,4:	rGrinded:=(rActualPositionGrindFeedStart[iStepSection] - rActualPositionGrindFeedEnd[iStepSection - 1]);	(* calculate the difference of the worked section before to the unworked section after *)
			IF (rGrinded < 0) THEN
				rGrinded:=rGrinded;
			END_IF;
			rActualPositionGrindFeedStart[iStepSection]:=rActualPositionGrindFeedStart[iStepSection] - rGrinded;		(* set the new diameter of the section which will going to work *)
			rTmpDistance:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)]; (* set the difference of the start and end diameter of the section *)
			IF (rActualPositionGrindFeedStart[iStepSection] < T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)]) THEN	(* correct of the to grind Tool diameter *)
				rActualPositionGrindFeedStart[iStepSection]:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)];
			END_IF;
			rGrindingRelativePosition:=rPlungeCycleGrindFeedGeometry - rGrinded ;	(* calculate the effectiv way for the plunge *)
(*			IF (rGrinded >= rPlungeCycleGrindFeedGeometry) THEN				(* check if the to grinding way is grater than the defined max grinding *) *)
			IF (rGrinded > rPlungeCycleGrindFeedGeometry) THEN				(* check if the to grinding way is grater than the defined max grinding *)
				IF (rActualPositionGrindFeedStart[iStepSection] < T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)]) THEN
				(* correct the effective way for the plunge, because it can not work more than the defined grinding way *)
					rGrindingRelativePosition:=rActualPositionGrindFeedStart[iStepSection] - T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)];
				END_IF;
			ELSE
				IF (rTmpDistance = 0) THEN
				(* a cylinder part will now work *)
					rGrindingRelativePosition:=0.0;
				ELSE
					(* a cone part will now work *)
					rGrindingRelativePosition:=rTmpDistance;
					IF ((T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - rGrindingRelativePosition) < T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)]) THEN
					(* correct the effective way for the plunge, because it can not work more than the defined grinding way *)
						rGrindingRelativePosition:=T_Geometry.arStartDiameter[iStartSection + (iStepSection - 1)] - T_Geometry.arEndDiameter[iStartSection + (iStepSection - 1)];
					END_IF;
				END_IF;
			END_IF;
			rActualPositionGrindFeedEnd[iStepSection]:=rActualPositionGrindFeedStart[iStepSection] - rGrindingRelativePosition;	(* calculate the end position of the section *)

			iStepSectionWork:=iStepSection;		(* set the actual section which is working *)
			IF ((iStepSection + (iStartSection - 1)) < iEndSection) THEN	(* check if the end section is active *)
				iStepSection:=iStepSection + 1;
			ELSE
				iStepSection:=5;	(* end section is reached-->go the displace procedure *)
			END_IF;
	(* plunge procedure *)
	5:		rActualPositionGrindFeedStart[5]:=rActualPositionGrindFeedEnd[iEndSection - (iStartSection - 1)];	(* set the new diameter of the section which will going to work *)
			rDistanceToWorkedTool:=rActualPositionGrindFeedStart[5] - rToolDiameterWithOffset;	(* check the distance to the end diameter, which will go to work *)
			rGrindingRelativePosition:=rDistanceToWorkedTool;
			IF (rActualPositionGrindFeedStart[5] = T_Geometry.arEndDiameter[iEndSection]) THEN
				axWorkEndSection[5]:=TRUE;		(* the end of this section is reached *)
			ELSE
				axWorkEndSection[5]:=FALSE;		(* the end of this section is not reached *)
			END_IF;
			rActualPositionGrindFeedEnd[5]:=rToolDiameterWithOffset;
			iStepSectionWork:=iStepSection;		(* set the actual section which is working *)
			iStepSection:=0;
END_CASE;

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALC_TOOLTENSION_FORCE
VAR_INPUT
	rForcePistonIn:REAL;	(* in Newton *)
	rPistonDiameterD:REAL;	(* in mm *)
	rMaxAirpressure:REAL;		(* in bar *)
END_VAR
VAR_OUTPUT
	iAnalogOutput:INT;		(* range 0 - 32767 *)
	rSetMaxForce:REAL;		(* in Newton *)
	rForcePistonOut:REAL;		(* in Newton *)
END_VAR
VAR
	rMaxForce: REAL;
	rAreaOutside: REAL;
	rArea: REAL;
	rTmpMaxAirpressure: REAL;
	rTmpAnalogOut:REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(*****       This Functionblock calculate the effective value for the servo ventil for the ToolTension which the settled force         *****)
(****************************************************************************************************************************************************)
	rAreaOutside:=((rPistonDiameterD/2)*(rPistonDiameterD/2))*PI;
	rArea:=rAreaOutside;
	rArea:=rArea / 1000000.0;	(* calculate from mm^2 to m^2 *)
	rTmpMaxAirpressure:=rMaxAirpressure * 100000.0;	(* convert from bar to pascal *)
	rMaxForce:=rArea * rTmpMaxAirpressure;
	rSetMaxForce:=rMaxForce;
	IF(rMaxForce = 0) THEN rMaxForce:=0.01; END_IF;	(* check divide by zero *)
	IF(rMaxForce <> 0.0) THEN
		rTmpAnalogOut:=(rForcePistonIn/rMaxForce)*32767;	(* 32767 = 10V *)
		IF (rTmpAnalogOut > 32767) THEN
			iAnalogOutput:=32767;
		ELSE
			iAnalogOutput:=REAL_TO_INT(rTmpAnalogOut);
		END_IF;
		rForcePistonOut:=rForcePistonIn;
	ELSE
		iAnalogOutput:=0;
		rForcePistonOut:=0;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALC_TOOLTENSION_FORCE_NEW
VAR_INPUT
	rForcePistonIn:REAL;	(* in Newton *)
	rPistonDiameterD1:REAL;	(* in mm *)
	rPistonDiameterD2:REAL;	(* in mm *)
	rMaxAirpressure:REAL;		(* in bar *)
	rFactorForce:REAL;
END_VAR
VAR_OUTPUT
	iAnalogOutput:INT;		(* range 0 - 32767 *)
	rSetMaxForce:REAL;		(* in Newton *)
	rForcePistonOut:REAL;	(* in Newton *)
END_VAR
VAR
	rMaxForce: REAL;
	rAreaOutside: REAL;
	rAreaInside: REAL;
	rArea: REAL;
	rTmpMaxAirpressure: REAL;
	rTmpAnalogOut:REAL;
END_VAR

(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(*****       This Functionblock calculate the effective value for the servo ventil for the ToolTension which the settled force         *****)
(****************************************************************************************************************************************************)
	rAreaOutside:=((rPistonDiameterD1/2)*(rPistonDiameterD1/2))*PI;
	rAreaInside:=((rPistonDiameterD2/2)*(rPistonDiameterD2/2))*PI;
	rArea:=ABS(rAreaOutside - rAreaInside);
	rArea:=rArea / 1000000.0;	(* Umwandeln von mm^2 in m^2 *)
	rTmpMaxAirpressure:=rMaxAirpressure * 100000.0;	(* convert from bar to pascal *)
	rMaxForce:=rArea * rTmpMaxAirpressure * rFactorForce;
	rSetMaxForce:=rMaxForce;

	IF(rMaxForce = 0) THEN rMaxForce:=0.01; END_IF;	(* check divide by zero *)
	IF(rMaxForce <> 0.0) THEN
		rTmpAnalogOut:=(rForcePistonIn/rMaxForce)*32767;	(* 32767 = 10V *)
		IF (rTmpAnalogOut > 32767) THEN
			iAnalogOutput:=32767;
		ELSE
			iAnalogOutput:=REAL_TO_INT(rTmpAnalogOut);
		END_IF;
		rForcePistonOut:=rForcePistonIn;
	ELSE
		iAnalogOutput:=0;
		rForcePistonOut:=0;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALCPROCESSTIME
VAR_INPUT
	T_Geometry:ST_GEOMETRY;									(* Structure of the NovRAM parameter *)
	T_AutoGeometryPara:ST_EXCHG_PARAM_AUTOGEOMETRY;		(* Structure of the NovRAM parameter *)
	T_CalibrationPara:ST_EXCHG_PARAM_CALIBRATION;			(* Structure of the NovRAM parameter *)
	T_AutoGroovePara:ST_EXCHG_PARAM_AUTOGROOVE;			(* Structure of the NovRAM parameter *)
	T_ProcessPara:ST_EXCHG_PARAM_PROCESS;					(* Structure of the NovRAM parameter *)
	rToolRotationSpeed:REAL;										(* Speed of the ToolRotation in U/Min *)
	rToolDiameter:REAL;											(* Diameter of the Tool in um *)
	rToolDiameterWithOffset:REAL;			(* diameter of the unworked Tool plus the offset for plunge and displace procedure *)
	iAutoProcess:INT;												(* 0=Calibration, 1=AutoGeometry process, 2=AutoGroove process *)
	xMicroRodActive:BOOL;										(* choice of the machine MicroWire or MicroRod *)
END_VAR
VAR_IN_OUT
	T_WorkTool:ST_WORKTOOL;									(* Tool parameter *)
END_VAR
VAR_OUTPUT
	rProcessTime: REAL;											(* calculated process time *)
END_VAR
VAR
	FBToolCalcul:FB_TOOL_CALCUL;
	ii: INT;
	rTimeLeftWork: REAL;
	iStartSection: INT;
	iEndSection: INT;
	rPlungeGrind: REAL;
	rDisplaceGrind: REAL;
	rGrindFeederPlunge: REAL;
	xResetFB: BOOL;
	xInitFB:BOOL;
(*11.10.2010 KFS {	*)
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING;
	FBCalcPlungeGrindingMultiCycle: FB_CALC_PLUNGE_GRINDING_MultiCycle;
(*11.10.2010 KFS }	*)
	rPlungeCycleGrindFeedGeometry: REAL;
	iTmpStartSection: INT;
	xCalculation: BOOL;
	rToolFeedLength: REAL;
	rSpeedToolFeed: REAL;
	rTimeAddLeftWork:REAL;
	rToolLength:REAL;
	rPlungeGrind2: REAL;
	rTimeAddLeftWorkPlungeGrind: REAL;
	rTimeAddLeftWorkPlungeGrind2: REAL;
	rTimeAddLeftWorkToolFeed: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********        This Functionblock calculate the time which is needed to work a geometry, groove or for calibration       ************)
(****************************************************************************************************************************************************)
	rProcessTime:=0.0;
	rTimeLeftWork:=0;
	iStartSection:=0;
	iEndSection:=0;
	xInitFB:=FALSE;
	IF (iAutoProcess = 1) THEN
	(* calculate the time for the process AutoGeometry or AutoGroove *)
		T_WorkTool.iTotalCountDownPlungeCycle:=0;
		(* Check Start and End Section of the ToolGeometry *)
		FOR ii:=1 TO 4 DO
			IF T_Geometry.axActiveSection[ii] THEN
				IF (iStartSection = 0) THEN
					iStartSection:=ii;
				END_IF;
				iEndSection:=ii;
			END_IF;
		END_FOR;
		xResetFB:=TRUE;
		(* reset first the FB for calculate the grinding plunge for each sections *)
		FBCalcPlungeGrindingMultiCycle(	rToolDiameter:= rToolDiameter,
										rToolDiameterWithOffset:=rToolDiameterWithOffset,
										xReset:= xResetFB,
										xInit:=xInitFB);
		xInitFB:=TRUE;
		FBCalcPlungeGrindingMultiCycle(	T_Geometry:= T_Geometry,
										T_AutoGeometryPara:= T_AutoGeometryPara,
										rToolDiameter:= rToolDiameter,
										rToolDiameterWithOffset:=rToolDiameterWithOffset,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB,
										xInit:=xInitFB);
		rPlungeCycleGrindFeedGeometry:=1.0;
		IF (iAutoProcess = 1) AND xMicroRodActive THEN
			rPlungeCycleGrindFeedGeometry:=T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry;
		END_IF;
		T_WorkTool.rToolRotationSpeed:=rToolRotationSpeed;
		xCalculation:=TRUE;
		WHILE(xCalculation) DO
			(* calculate the grinding way of each section *)
			FBCalcPlungeGrindingMultiCycle(	T_Geometry:= T_Geometry,
											T_AutoGeometryPara:= T_AutoGeometryPara,
											rToolDiameter:= rToolDiameter,
											rToolDiameterWithOffset:=rToolDiameterWithOffset,
											rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
											iStartSection:= iStartSection,
											iEndSection:= iEndSection,
											xReset:= xResetFB,
											xInit:=xInitFB);
			IF FBCalcPlungeGrindingMultiCycle.xEndWorking THEN		(* check if the end of the to work Tool is reached *)
				xCalculation:=FALSE;
				EXIT;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork = 5) THEN
				(* Count the Plunge Cycle *)
				T_WorkTool.iTotalCountDownPlungeCycle:=T_WorkTool.iTotalCountDownPlungeCycle + 1;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork >= 1) AND (FBCalcPlungeGrindingMultiCycle.iStepSectionWork <= 4) THEN
			(* section 1 - 4 *)
				iTmpStartSection:=iStartSection + (FBCalcPlungeGrindingMultiCycle.iStepSectionWork - 1);
				rGrindFeederPlunge:=FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition;
				T_WorkTool.rGrindFeederPlunge:=rGrindFeederPlunge;
				T_WorkTool.rPitch:=T_Geometry.arSectionPitch[iTmpStartSection];
				T_WorkTool.rToolLength:=T_Geometry.arSectionLength[iTmpStartSection];
				FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
								xBeckhoffDriveActive:=FALSE,
								T_WorkTool:= T_WorkTool);
				rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rTimeLeftWork;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork = 0) THEN
				(* Calc Plunge *)
				IF T_AutoGeometryPara.xPlungeActivationGeometry THEN
					T_WorkTool.rPitch:=T_Geometry.arSectionPitch[iStartSection] * -1.0;
					T_WorkTool.rGrindFeederPlunge:=FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition;
					rToolFeedLength:=T_AutoGeometryPara.rPlungeLengthToolFeedGeometry;
					T_WorkTool.rToolLength:=rToolFeedLength;
					T_WorkTool.rToolRotationSpeed:=T_AutoGeometryPara.rSpeedToolRotationGeometry;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool);
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
					IF (rSpeedToolFeed <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rToolLength/rSpeedToolFeed;
					END_IF;
				ELSE
					(* No Plunging activation, than also is the GrindFeeder the master *)
					rPlungeGrind:=ABS(FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition);
					IF (T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + (rPlungeGrind / T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry);
					END_IF;
				END_IF;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork = 5) THEN
				(* Calc Displace *)
				IF T_AutoGeometryPara.xDisplaceActivationGeometry THEN
					T_WorkTool.rPitch:=T_Geometry.arSectionPitch[iEndSection] * -1.0;
					T_WorkTool.rGrindFeederPlunge:=FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition;
					rToolFeedLength:=T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry;
					T_WorkTool.rToolLength:=rToolFeedLength;
					T_WorkTool.rToolRotationSpeed:=T_AutoGeometryPara.rSpeedToolRotationGeometry;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool);
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
					IF (rSpeedToolFeed <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rToolLength/rSpeedToolFeed;
					END_IF;
				ELSE
					(* No Displace activation, than also is the GrindFeeder the master *)
					rDisplaceGrind:=ABS(FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition);
					IF (T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + (rDisplaceGrind / T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry);
					END_IF;
				END_IF;
			END_IF;
		END_WHILE;
		IF (T_AutoGeometryPara.iCycleGeometry > 1) THEN
			rTimeLeftWork:=rTimeLeftWork * INT_TO_REAL(T_AutoGeometryPara.iCycleGeometry);
		END_IF;
	END_IF;
(**************iAutoProcess 2 --> AutoGroove********************************************************************************************************************************************************************************************************)
	IF (iAutoProcess = 2) THEN
	(* calculate the time for the process AutoGeometry or AutoGroove *)
		T_WorkTool.iTotalCountDownPlungeCycle:=0;
		(* Check Start and End Section of the ToolGeometry *)
		FOR ii:=1 TO 4 DO
			IF T_Geometry.axActiveSection[ii] THEN
				IF (iStartSection = 0) THEN
					iStartSection:=ii;
				END_IF;
				iEndSection:=ii;
			END_IF;
		END_FOR;
(*
		xResetFB:=TRUE;
		(* reset first the FB for calculate the grinding plunge for each sections *)
		FBCalcPlungeGrinding(	rToolDiameter:= rToolDiameter,
								rToolDiameterWithOffset:=rToolDiameterWithOffset,
								xReset:= xResetFB);
		rPlungeCycleGrindFeedGeometry:=1.0;
*)
		xResetFB:=TRUE;
		(* reset first the FB for calculate the grinding plunge for each sections *)
		FBCalcPlungeGrindingMultiCycle(	rToolDiameter:= rToolDiameter,
										rToolDiameterWithOffset:=rToolDiameterWithOffset,
										xReset:= xResetFB,
										xInit:=xInitFB);
		xInitFB:=TRUE;
		FBCalcPlungeGrindingMultiCycle(	T_Geometry:= T_Geometry,
										T_AutoGeometryPara:= T_AutoGeometryPara,
										rToolDiameter:= rToolDiameter,
										rToolDiameterWithOffset:=rToolDiameterWithOffset,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB,
										xInit:=xInitFB);
		rPlungeCycleGrindFeedGeometry:=1.0;
		IF (iAutoProcess = 2) OR NOT(xMicroRodActive) THEN
			rPlungeCycleGrindFeedGeometry:=rToolDiameter;		(* for the groove process or for the MicroWire is not possible to work in more cycle, because of that it will set the tooldiamter *)
		END_IF;
		T_WorkTool.rToolRotationSpeed:=rToolRotationSpeed;
		xCalculation:=TRUE;
		WHILE(xCalculation) DO
			(* calculate the grinding way of each section *)
			FBCalcPlungeGrindingMultiCycle(	T_Geometry:= T_Geometry,
											T_AutoGeometryPara:= T_AutoGeometryPara,
											rToolDiameter:= rToolDiameter,
											rToolDiameterWithOffset:=rToolDiameterWithOffset,
											rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
											iStartSection:= iStartSection,
											iEndSection:= iEndSection,
											xReset:= xResetFB,
											xInit:=xInitFB);
			IF FBCalcPlungeGrindingMultiCycle.xEndWorking THEN		(* check if the end of the to work Tool is reached *)
				xCalculation:=FALSE;
				EXIT;
			END_IF;
			IF (T_WorkTool.iTotalCountDownPlungeCycle >= 20) THEN	(* not possible to work a Tool in more that 20 cycle *)
				xCalculation:=FALSE;
				EXIT;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork = 5) THEN
				(* Count the Plunge Cycle *)
				T_WorkTool.iTotalCountDownPlungeCycle:=T_WorkTool.iTotalCountDownPlungeCycle + 1;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork >= 1) AND (FBCalcPlungeGrindingMultiCycle.iStepSectionWork <= 4) THEN
			(* section 1 - 4 *)
				iTmpStartSection:=iStartSection + (FBCalcPlungeGrindingMultiCycle.iStepSectionWork - 1);
				rGrindFeederPlunge:=FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition;
				T_WorkTool.rGrindFeederPlunge:=rGrindFeederPlunge;
				T_WorkTool.rPitch:=T_AutoGroovePara.rPitchGroove;
				T_WorkTool.rToolLength:=T_Geometry.arSectionLength[iTmpStartSection];
				FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
								xBeckhoffDriveActive:=FALSE,
								T_WorkTool:= T_WorkTool);
				rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rTimeLeftWork;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork = 0) THEN
				(* Calc Plunge *)
				IF T_AutoGroovePara.xPlungeActivationGroove  THEN
					T_WorkTool.rPitch:=T_AutoGroovePara.rPitchGroove * -1.0;
					T_WorkTool.rGrindFeederPlunge:=FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition;
					rToolFeedLength:=T_AutoGroovePara.rPlungeLengthToolFeedGroove;
					T_WorkTool.rToolLength:=rToolFeedLength;
					T_WorkTool.rToolRotationSpeed:=T_AutoGroovePara.rSpeedToolRotationGroove;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool);
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
					IF (rSpeedToolFeed <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rToolLength/rSpeedToolFeed;
					END_IF;
				ELSE
					(* No Plunging activation, than also is the GrindFeeder the master *)
					rPlungeGrind:=ABS(FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition);
					IF (T_AutoGroovePara.rPlungeSpeedGrindFeedGroove <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + (rPlungeGrind / T_AutoGroovePara.rPlungeSpeedGrindFeedGroove);
					END_IF;
				END_IF;
			END_IF;
			IF (FBCalcPlungeGrindingMultiCycle.iStepSectionWork = 5) THEN
				(* Calc Displace *)
				IF T_AutoGroovePara.xDisplaceActivationGroove  THEN
					T_WorkTool.rPitch:=T_AutoGroovePara.rPitchGroove * -1.0;
					T_WorkTool.rGrindFeederPlunge:=FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition;
					rToolFeedLength:=T_AutoGroovePara.rDisplaceLengthToolFeedGroove;
					T_WorkTool.rToolLength:=rToolFeedLength;
					T_WorkTool.rToolRotationSpeed:=T_AutoGroovePara.rSpeedToolRotationGroove;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool);
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
					IF (rSpeedToolFeed <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rToolLength/rSpeedToolFeed;
					END_IF;
				ELSE
					(* No Displace activation, than also is the GrindFeeder the master *)
					rDisplaceGrind:=ABS(FBCalcPlungeGrindingMultiCycle.rGrindingRelativePosition);
					IF (T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove <> 0) THEN
						rTimeLeftWork:=rTimeLeftWork + (rPlungeGrind / T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove);
					END_IF;
				END_IF;
			END_IF;
		END_WHILE;
		IF (T_AutoGroovePara.iNumberOfGrooves > 1) THEN
			rTimeLeftWork:=rTimeLeftWork * INT_TO_REAL(T_AutoGroovePara.iNumberOfGrooves);
			(* Berechnung zusätzlicher Weg und Zeit für Ausstechen & Einstechen ab 2. Zyklus*)
			rPlungeGrind:=ABS(T_ProcessPara.rSecurityPosGrindFeedProcess - T_ProcessPara.rToolDiameterProcess) * 2.0;
			rTimeAddLeftWorkPlungeGrind:= rPlungeGrind / T_ProcessPara.rSpeedForwardFastGrindFeed;
			(* Berechnung zusätzlicher Weg und Zeit  Ausstechen für letzten Zyklus*)
			rPlungeGrind2:=ABS(T_ProcessPara.rSecurityPosGrindFeedProcess - T_ProcessPara.rToolDiameterProcess);
			rTimeAddLeftWorkPlungeGrind2:= rPlungeGrind2 / T_ProcessPara.rSpeedForwardFastGrindFeed;
			(*Berechnung zusätzlicher Weg und Zeit  Rückfahren  ab 2. Zyklus*)
			rToolLength:=0;
			FOR ii:=1 TO 4 DO
				IF T_Geometry.axActiveSection[ii] THEN
					rToolLength:=rToolLength + T_Geometry.arSectionLength[ii];
				END_IF;
			END_FOR;
			rTimeAddLeftWorkToolFeed:= rToolLength*10/T_ProcessPara.rSpeedStartPosToolFeedProcess;
			(*Berchnung der gesamten zusätzlichen Prozesszeit*)
			rTimeAddLeftWork:=(rTimeAddLeftWorkPlungeGrind + rTimeAddLeftWorkToolFeed) * (T_AutoGroovePara.iNumberOfGrooves -1);
			rTimeAddLeftWork:= rTimeAddLeftWork+rTimeAddLeftWorkPlungeGrind2;
			rTimeLeftWork:=rTimeLeftWork + rTimeAddLeftWork;
		END_IF;
	END_IF;
(**************iAutoProcess 0***********************************************************************************************************************************************************************************************************************)
	IF (iAutoProcess = 0) THEN
	(* Calculate the time for the process ToolCalibration *)
		T_WorkTool.rToolRotationSpeed:=T_CalibrationPara.rSpeedToolRotationCalib;
		T_WorkTool.rGrindFeederPlunge:=T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
		T_WorkTool.rPitch:=T_CalibrationPara.rPitchCalib;
		T_WorkTool.rToolLength:=T_CalibrationPara.rToolLengthCylinderPartCalib;
		FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
						xBeckhoffDriveActive:=FALSE,
						T_WorkTool:= T_WorkTool);
		rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rTimeLeftWork;
		IF T_CalibrationPara.xPlungeActivationCalib THEN
			T_WorkTool.rPitch:=T_CalibrationPara.rPitchCalib;
			T_WorkTool.rGrindFeederPlunge:=T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
			rToolFeedLength:=T_CalibrationPara.rPlungeLengthToolFeedCalib;
			T_WorkTool.rToolLength:=rToolFeedLength;
			FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
							xBeckhoffDriveActive:=FALSE,
							T_WorkTool:= T_WorkTool);
			rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
			IF (rSpeedToolFeed <> 0) THEN
				rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rToolLength/ABS(rSpeedToolFeed);
			END_IF;
		ELSE
			(* No Plunging activation, than also is the GrindFeeder the master *)
			rPlungeGrind:=T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
			rTimeLeftWork:=rTimeLeftWork + (rPlungeGrind / T_CalibrationPara.rPlungeSpeedGrindFeedCalib);
		END_IF;


		IF T_CalibrationPara.xDisplaceActivationCalib THEN
			T_WorkTool.rPitch:=T_CalibrationPara.rPitchCalib * -1.0;
			T_WorkTool.rGrindFeederPlunge:=T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
			rToolFeedLength:=T_CalibrationPara.rDisplaceLengthToolFeedCalib;
			T_WorkTool.rToolLength:=rToolFeedLength;
			FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
							xBeckhoffDriveActive:=FALSE,
							T_WorkTool:= T_WorkTool);
			rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
			IF (rSpeedToolFeed <> 0) THEN
				rTimeLeftWork:=rTimeLeftWork + T_WorkTool.rToolLength/ABS(rSpeedToolFeed);
			END_IF;
		ELSE
			(* No Displace activation, than also is the GrindFeeder the master *)
			rDisplaceGrind:=T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
			rTimeLeftWork:=rTimeLeftWork + (rDisplaceGrind / T_CalibrationPara.rDisplaceSpeedGrindFeedCalib);
		END_IF;
	END_IF;
	rProcessTime:=rTimeLeftWork;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CHECKACTIVEMOVEMENT
VAR_INPUT
	T_TwinSafeOut:ST_TWINSAFE_OUT;		(* Output of the TwinSafe components *)
	xKeySwitch:BOOL;							(* Activation and deactivation of the key switch *)
	xBlockChecking:BOOL;						(* block the checking of the axis movement *)
END_VAR
VAR_IN_OUT
	xReset:BOOL;							(* Reset the FB *)
	T_Visu:ST_QVIS;							(* Data structure of the visualisation *)
	T_Station:ST_STATION;					(* Data structure of the station level *)
	T_Process : ST_PROCESS;				(* Data structure of the process level *)
END_VAR
VAR_OUTPUT
	xActiveSetupLevel: BOOL;					(* state of the setuplevel, if it is active *)
	xActiveProcess: BOOL;						(* state of a process if it is active *)
	xActiveStation: BOOL;						(* state of the stationlevel if it is active *)
	xActiveHWStation: BOOL;					(* state of the hardware of the station, if it is active *)
END_VAR
VAR
	xActivateOverlayMessage: BOOL;
	xDoNotCheckMovement: BOOL;
	FallingEdgeKeySwitchOff: F_TRIG;
	iStepSwitchMachineLevel: INT;
	TONWaitTimeStateMachine: TON;
	xPowerSupplyActive: BOOL;
	xTmp: BOOL;
	xStopAxisWithStationFunction: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(*****        This Functionblock check the general movement of all axes. This will be need by change from the station level        ****)
(*****        to the machine level. If case of a change from the station level to the machine level and a axis move than the             ****)
(*****        movement will be stopp																			       ****)
(****************************************************************************************************************************************************)
(* Check Active movement and block visu if active *)
	xTmp:=	(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder = 2) OR
			(T_Visu.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState = 2);
	IF xTmp THEN
		T_StartUp.T_State.xBlockVisuNavigation:=TRUE;	(* Lock the navigation of the visu *)
	END_IF;
	IF T_StartUp.T_State.xBlockVisuNavigation AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu) AND NOT(T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject) AND NOT(xTmp) THEN
		T_StartUp.T_State.xBlockVisuNavigation:=FALSE;	(* Unlock the navigation of the visu *)
	END_IF;

(* Check Setup Level with active key switch and an active movement *)
	IF xReset THEN
		xReset:=FALSE;
		xActivateOverlayMessage:=FALSE;
	END_IF;
	IF NOT(xActivateOverlayMessage) THEN
		xActiveSetupLevel:=	(T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer <> 0) AND
							T_StartUp.T_State.xCompleted AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu);
		xDoNotCheckMovement:=	NOT(T_Process.xEnd) AND NOT(T_Process.xError) AND ((T_Process.iFunctNr = 10) OR (T_Process.iFunctNr = 20) OR (T_Process.iFunctNr = 30));
		xActiveProcess:=		NOT(T_Process.xEnd) AND NOT(T_Process.xError) AND (T_Process.iFunctNr = 40);
		xActiveStation:=		NOT(T_Station.TControl.xEnd) AND NOT(T_Station.TControl.xError) AND NOT(xActiveProcess) AND NOT(xDoNotCheckMovement);
		xActiveHWStation:=	T_Station.TControl.xActiveMovement AND NOT(xActiveProcess) AND NOT(xActiveStation) AND NOT(xDoNotCheckMovement);
		(* check if the ToolTorque was activatet *)
		xStopAxisWithStationFunction:=FALSE;
		IF xActiveHWStation THEN
			IF (T_Visu.T_PlcParam.dwActualPage = 220) THEN
				xActiveHWStation:=FALSE;
				xStopAxisWithStationFunction:=TRUE;
			END_IF;
		END_IF;
	END_IF;
	FallingEdgeKeySwitchOff(CLK:=xKeySwitch);
	IF xActiveSetupLevel THEN
		IF FallingEdgeKeySwitchOff.Q THEN
			IF xActiveProcess OR xActiveStation OR xActiveHWStation OR xStopAxisWithStationFunction THEN
				xActivateOverlayMessage:=TRUE;
				iStepSwitchMachineLevel:=1;
			END_IF;
		END_IF;
	END_IF;
(*
	IF NOT(xBlockChecking) THEN
		xActivateOverlayMessage:= xActivateOverlayMessage AND NOT
								(T_Station.TControl.xSecurityCircuitOff OR T_Station.TControl.xSecurityCircuitOn);
	END_IF;
*)
	IF xActivateOverlayMessage THEN
		CASE iStepSwitchMachineLevel OF
		1:	TONWaitTimeStateMachine(IN:=FALSE);
			(* next step *)
			iStepSwitchMachineLevel:=10;
		10:	TONWaitTimeStateMachine(IN:=TRUE,PT:=T#150ms);
			IF TONWaitTimeStateMachine.Q THEN
				TONWaitTimeStateMachine(IN:=FALSE);
				(* next step *)
				iStepSwitchMachineLevel:=20;
			END_IF;
		20:	IF T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4 THEN
				xPowerSupplyActive:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;	(* Display message -> The Movement of the machine will be breaked! *)
				(* with switching off of the key switch the power supply is not switched off and the movement are still active *)
				IF xActiveProcess THEN
					T_Process.xStop:=TRUE;
					iStepSwitchMachineLevel:=30;
				END_IF;
				IF xActiveStation THEN
					T_Station.TControl.xStop:=TRUE;
					iStepSwitchMachineLevel:=40;
				END_IF;
				IF xActiveHWStation THEN
					iStepSwitchMachineLevel:=60;
				END_IF;
				IF xStopAxisWithStationFunction THEN
					iStepSwitchMachineLevel:=70;
				END_IF;
			ELSE
				(* with switching off of the key switch the power supply is switched off *)
				xPowerSupplyActive:=FALSE;
				(* next step *)
				iStepSwitchMachineLevel:=80;
			END_IF;
		30:	IF T_Process.xEnd THEN
				(* next step *)
				iStepSwitchMachineLevel:=80;
			END_IF;
			IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
				xPowerSupplyActive:=FALSE;
				iStepSwitchMachineLevel:=80;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;	(* Display message -> The Movement of the machine will be breaked! *)
		40:	IF T_Station.TControl.xEnd THEN
				(* next step *)
				T_Station.TControl.xStop:=FALSE;
				iStepSwitchMachineLevel:=60;
			END_IF;
			IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
				xPowerSupplyActive:=FALSE;
				iStepSwitchMachineLevel:=80;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;	(* Display message -> The Movement of the machine will be breaked! *)
		60:	IF T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone AND NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone) AND T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xNotMoving AND NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone AND NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone) AND T_Station.THardware.TAxisToolRight.T_CtrleSingle.xNotMoving AND NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone AND NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone) AND T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xNotMoving AND NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving) AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone) AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving) AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr) THEN
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone) THEN T_Station.THardware.TCylToolTension.T_CtrleCyl.xReset:=TRUE; END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;	(* Display message -> The Movement of the machine will be breaked! *)
			(* next step *)
			iStepSwitchMachineLevel:=80;
		70:	IF T_Station.TControl.xEnd THEN
				(* next step *)
				T_Station.TControl.iFunctNr:=3;
				T_Station.TControl.xStart:=TRUE;
				iStepSwitchMachineLevel:=71;
			END_IF;
			IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
				xPowerSupplyActive:=FALSE;
				iStepSwitchMachineLevel:=80;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;	(* Display message -> The Movement of the machine will be breaked! *)
		71:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				(* next step *)
				iStepSwitchMachineLevel:=80;
			END_IF;
			IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
				xPowerSupplyActive:=FALSE;
				iStepSwitchMachineLevel:=80;
			END_IF;
		80:	IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
				T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=0;
				T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
				T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=1;
				T_Visu.T_PlcParam.dwSetNewPage:=16#A;	(* Main Page wird aufgerufen *)
				T_Visu.T_CtrleVisu.iFunction:=1;
				T_Visu.T_CtrleVisu.xExecute:=TRUE;
				iStepSwitchMachineLevel:=90;
			END_IF;
		90:	IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
				T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
				T_StartUp.T_State.xBlockVisuNavigation:=FALSE;	(* Unlock the navigation of the visu *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=1;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=1;
				(* Overlay Message Error *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
				IF xPowerSupplyActive THEN
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=18;	(* WHILE A MOVEMENT THE KEY SWITCH *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=18;	(* HAS BEEN SWITCHED OFF! *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=18;	(* NOW YOU ARE ON THE NORMAL OPERATION *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=18;	(* AND THE POWER SUPPLY IS STILL SWITCHED ON *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				ELSE
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=17;	(* WHILE A MOVEMENT THE KEY SWITCH *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=17;	(* HAS BEEN SWITCHED OFF! *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=17;	(* NOW YOU ARE ON THE NORMAL OPERATION *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=17;	(* AND THE POWER SUPPLY IS SWITCHED OFF *)
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				END_IF;
				(* next step *)
				iStepSwitchMachineLevel:=100;
			END_IF;
		100:	IF T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_StartUp.T_State.xBlockVisuNavigation:=FALSE;	(* Unlock the navigation of the visu *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=1;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=1;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				xActivateOverlayMessage:=FALSE;
				iStepSwitchMachineLevel:=1;
			END_IF;
			IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=17;	(* WHILE A MOVEMENT THE KEY SWITCH *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=17;	(* HAS BEEN SWITCHED OFF! *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=17;	(* NOW YOU ARE ON THE NORMAL OPERATION *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=17;	(* AND THE POWER SUPPLY IS SWITCHED OFF *)
			END_IF;
			IF T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4  THEN
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=18;	(* WHILE A MOVEMENT THE KEY SWITCH *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=18;	(* HAS BEEN SWITCHED OFF! *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=18;	(* NOW YOU ARE ON THE NORMAL OPERATION *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=18;	(* AND THE POWER SUPPLY IS STILL SWITCHED ON *)
			END_IF;
		END_CASE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CheckToolGeometryPara
VAR_INPUT
	iProcessNr:INT;	(* 1=AutoGeometry, 2=AutoGroove *)
	T_GeometryCommon:ST_GEOMETRY_COMMON;
	T_AutoGeometryPara:ST_EXCHG_PARAM_AUTOGEOMETRY;
	T_AutoGroovePara:ST_EXCHG_PARAM_AUTOGROOVE;
	T_ProcessPara:ST_EXCHG_PARAM_PROCESS;
	rToolDiameter:REAL;
(*22.12.2009: KFS 	{    *)
	xMicroRodActive: BOOL;				(* choice of the machine MicroWire or MicroRod *)
(*04.04.2011: KFS	{
	rOffsetMaxToolLength:REAL;
04.04.2011: KFS	}   *)
(*22.12.2009: KFS 	}   *)
END_VAR
VAR_OUTPUT
	xError:BOOL;		(* errorflag *)
	diErrorNr: DINT;	(* number of the caused error *)
(*22.12.2009: KFS 	{    *)
	xMultiCycleGrindFeedGeometry: BOOL;				(* choice of multicycle for MicroRod *)
(*22.12.2009: KFS 	}   *)
END_VAR
VAR
	ii: INT;
	rToolLength: REAL;
	rToolDiamterMax: REAL;
	rToolDiamterMin: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                         check the settled value of the geometry and set an error if the value ar not correct                         ************)
(****************************************************************************************************************************************************)
(* Check ToolLength *)
	rToolLength:=0;
	diErrorNr:=0;
	xError:=FALSE;
	xMultiCycleGrindFeedGeometry:= FALSE;
	FOR ii:=1 TO 4 DO
		IF T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
			rToolLength:=rToolLength + T_GeometryCommon.T_Geometry.arSectionLength[ii];
		END_IF;
	END_FOR;
(*
	IF (iProcessNr = 1) THEN
		IF T_AutoGeometryPara.xPlungeActivationGeometry THEN
			rToolLength:=rToolLength + (T_AutoGeometryPara.rPlungeLengthToolFeedGeometry / 10.0);
		END_IF;
		IF T_AutoGeometryPara.xDisplaceActivationGeometry THEN
			rToolLength:=rToolLength + (T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry / 10.0);
		END_IF;
		IF (T_AutoGeometryPara.iCycleGeometry > 1) THEN
			rToolLength:=rToolLength * INT_TO_REAL(T_AutoGeometryPara.iCycleGeometry);
		END_IF;
	END_IF;
	IF (iProcessNr = 2) THEN
		IF T_AutoGroovePara.xPlungeActivationGroove THEN
			rToolLength:=rToolLength + (T_AutoGroovePara.rPlungeLengthToolFeedGroove / 10.0);
		END_IF;
		IF T_AutoGroovePara.xDisplaceActivationGroove THEN
			rToolLength:=rToolLength + (T_AutoGroovePara.rDisplaceLengthToolFeedGroove / 10.0);
		END_IF;
	END_IF;
*)
	(*22.12.2009: KFS 	{    *)
	IF xMicroRodActive THEN
		IF rToolLength > (T_GeometryCommon.rMaxToolLength - T_ProcessPara.rStartPosToolFeedAuto * 0.1(* - rOffsetMaxToolLength*) ) THEN
			diErrorNr:=16#F201;	(* Settled parameter for ToolLength is to long *)
		END_IF;
		IF rToolLength < T_GeometryCommon.rMinToolLength THEN
			diErrorNr:=16#F202;	(* Settled parameter for ToolLength is to short *)
		END_IF;
	ELSE
		IF rToolLength > T_GeometryCommon.rMaxToolLength THEN
			diErrorNr:=16#F201;	(* Settled parameter for ToolLength is to long *)
		END_IF;
		IF rToolLength < T_GeometryCommon.rMinToolLength THEN
			diErrorNr:=16#F202;	(* Settled parameter for ToolLength is to short *)
		END_IF;
	END_IF;
	(*22.12.2009: KFS	}   *)
(* Check ToolDiamter in case of the prisma *)
	rToolDiamterMax:=0;
	FOR ii:=1 TO 4 DO
		IF T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
			IF (T_GeometryCommon.T_Geometry.arStartDiameter[ii] > rToolDiamterMax) THEN
				rToolDiamterMax:=T_GeometryCommon.T_Geometry.arStartDiameter[ii];
			END_IF;
			IF (T_GeometryCommon.T_Geometry.arEndDiameter[ii] > rToolDiamterMax) THEN
				rToolDiamterMax:=T_GeometryCommon.T_Geometry.arEndDiameter[ii];
			END_IF;
		END_IF;
	END_FOR;
	rToolDiamterMin:=999999;
	FOR ii:=1 TO 4 DO
		IF T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
			IF (T_GeometryCommon.T_Geometry.arStartDiameter[ii] < rToolDiamterMin) THEN
				rToolDiamterMin:=T_GeometryCommon.T_Geometry.arStartDiameter[ii];
			END_IF;
			IF (T_GeometryCommon.T_Geometry.arEndDiameter[ii] < rToolDiamterMin) THEN
				rToolDiamterMin:=T_GeometryCommon.T_Geometry.arEndDiameter[ii];
			END_IF;
		END_IF;
	END_FOR;
	IF (rToolDiamterMax > T_GeometryCommon.rMaxToolDiameter) THEN
		diErrorNr:=16#F203;	(* Settled parameter for ToolDiameter is to big *)
	END_IF;
	IF (rToolDiamterMin < T_GeometryCommon.rMinToolDiameter) THEN
		diErrorNr:=16#F204;	(* Settled parameter for ToolDiameter is to small *)
	END_IF;
	(*22.12.2009: KFS 	{    *)
(* Check activation for multicycle of the AutoGeometry *)
	IF xMicroRodActive THEN
		IF ( (rToolDiameter - rToolDiamterMin) > T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry ) THEN
			xMultiCycleGrindFeedGeometry := TRUE;
		END_IF;
	END_IF;
	(*22.12.2009: KFS 	}    *)
(* Check the passage from one section to another section if equal *)
	FOR ii:=1 TO 4 DO
		IF T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
			IF (ii < 4) THEN
				IF T_GeometryCommon.T_Geometry.axActiveSection[ii+ 1] THEN
					IF (T_GeometryCommon.T_Geometry.arEndDiameter[ii] <> T_GeometryCommon.T_Geometry.arStartDiameter[ii + 1]) THEN
						diErrorNr:=16#F205;	(* At least a passage of a section is not equal *)
					END_IF;
				END_IF;
			END_IF;
		END_IF;
	END_FOR;
(* Check ToolDiamter in case of the settled ToolDiameter *)
	rToolDiamterMax:=0;
	FOR ii:=1 TO 4 DO
		IF T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
			IF (T_GeometryCommon.T_Geometry.arStartDiameter[ii] > rToolDiamterMax) THEN
				rToolDiamterMax:=T_GeometryCommon.T_Geometry.arStartDiameter[ii];
			END_IF;
			IF (T_GeometryCommon.T_Geometry.arEndDiameter[ii] > rToolDiamterMax) THEN
				rToolDiamterMax:=T_GeometryCommon.T_Geometry.arEndDiameter[ii];
			END_IF;
		END_IF;
	END_FOR;
	IF (rToolDiamterMax > rToolDiameter) THEN
		diErrorNr:=16#F206;	(* At least one settled diameter is bigger than the ToolDiameter *)
	END_IF;
	IF (diErrorNr <> 0) THEN
		xError:=TRUE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CONTROLLAMP
VAR_INPUT
	xStartUpCompleted:BOOL;		(* State of the machine, if the booting of the machine is active *)
	iStateMessage:INT;			(* State of the message-->with the number 401, an error occur *)
	bActiveStation:BYTE;			(* 0=Normalbetrieb, 1,2,3,4=Sonderbetrieb *)
END_VAR
VAR_IN_OUT
	T_Station:ST_STATION;		(* Data structure of the station level *)
	T_Process : ST_PROCESS;	(* Data structure of the process level *)
	TCtrlePanel:ST_CTRLEPANEL;	(* Data structure of the ControlPanel *)
END_VAR
VAR_OUTPUT
	xLampGreen:BOOL;			(* Output signal for the green lamp *)
	xLampRed:BOOL;				(* Output signal for the red lamp *)
	xLampOrange:BOOL;			(* Output signal for the orange lamp *)
END_VAR
VAR
(* Timer *)
	TimerON:TON;
	TimerOFF:TOF;
	tTimerCadence:TIME;
	xTimerSignal:BOOL;
(* variable *)
	xFirstExecution:BOOL;
	xRedOffGreenOff:BOOL;
	xRedOnGreenOff:BOOL;
	xRedBlinkedGreenOff:BOOL;
	xRedOffGreenOn:BOOL;
	xRedOffGreenBlinked:BOOL;
	xRedOnGreenOn:BOOL;
	xRedAndGreenBlinked: BOOL;
	xPanelLedBlinked: BOOL;
(* Tmp *)
	xTmp:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                             This Functionblock set the ControlLamp for the different state of the machine                                ************)
(****************************************************************************************************************************************************)
(* First execution *)
	IF NOT xFirstExecution THEN
		(* Init. variable *)
		tTimerCadence:=T#0.5s;
		xTimerSignal:=FALSE;
		(* Timer *)
		TimerON(IN:=FALSE);
		TimerOFF(IN:=TRUE);
		(* Confirm execution *)
		xFirstExecution:=TRUE;
	END_IF

(* Each cycle, init. lamp state *)
	xLampGreen:=FALSE;
	xLampRed:=FALSE;
	xLampOrange:=FALSE;
	TCtrlePanel.udiLED:=16#0;

(* Each cycle, init. lamp state function *)
	xTmp:=FALSE;
	xRedOffGreenOff:=FALSE;
	xRedOnGreenOff:=FALSE;
	xRedBlinkedGreenOff:=FALSE;
	xRedOffGreenOn:=FALSE;
	xRedOffGreenBlinked:=FALSE;
	xRedOnGreenOn:=FALSE;
	xRedAndGreenBlinked:=FALSE;
	xPanelLedBlinked:=FALSE;

(* Error *)
	IF NOT(xStartUpCompleted) THEN
		(* While starting up of the machine *)
		 xRedOnGreenOn:=TRUE;
	ELSE
		IF (iStateMessage = 401) THEN
			(* Error state *)
			xRedBlinkedGreenOff:=TRUE;
			xPanelLedBlinked:=TRUE;
		ELSIF NOT(T_Process.xEnd) AND ((T_Process.iFunctNr = 10) OR (T_Process.iFunctNr = 20) OR (T_Process.iFunctNr = 30)) THEN
			(* Normalbetrieb with active process *)
			xRedOffGreenOn:=TRUE;
		ELSIF T_Process.xEnd AND (bActiveStation = 0) THEN
			(* Normalbetrieb and no active process *)
			xRedOffGreenBlinked:=TRUE;
		ELSIF (bActiveStation <> 0) THEN
			(* Einrichtbetrieb *)
			xRedAndGreenBlinked:=TRUE;
		ELSE
			(* Dieser Zustand sollte niemals eintreten dürfen *)
			xRedOffGreenOff:=TRUE;
		END_IF;
	END_IF;

(* Blink *)
	TimerON(IN:=TRUE,PT:=tTimerCadence);
	IF TimerON.Q THEN
		TimerOFF(IN:=FALSE,PT:=tTimerCadence);
		IF NOT TimerOFF.Q THEN TimerON(IN:=FALSE); TimerOFF(IN:=TRUE); END_IF
	END_IF

(* Red off and green off *)
	IF xRedOffGreenOff THEN
		xLampGreen:=FALSE;
		xLampRed:=FALSE;
	END_IF

(* Red on and green off *)
	IF xRedOnGreenOff THEN
		xLampGreen:=FALSE;
		xLampRed:=TRUE;
	END_IF

(* Red blinked green off *)
	IF xRedBlinkedGreenOff THEN
		xLampGreen:=FALSE;
		xLampRed:=TimerON.Q;
		tTimerCadence:=T#0.5s;
	END_IF

(* Red off green on *)
	IF xRedOffGreenOn THEN
		xLampGreen:=TRUE;
		xLampRed:=FALSE;
	END_IF

(* Red off green blinked *)
	IF xRedOffGreenBlinked THEN
		xLampGreen:=TimerON.Q;
		tTimerCadence:=T#0.5s;
		xLampRed:=FALSE;
	END_IF

(* Red on green on *)
	IF xRedOnGreenOn THEN
		xLampGreen:=TRUE;
		xLampRed:=TRUE;
	END_IF

(* Red and green blinked *)
	IF xRedAndGreenBlinked THEN
		xLampGreen:=TimerON.Q;
		xLampRed:=xLampGreen;
		tTimerCadence:=T#0.5s;
	END_IF

(* Panel led blinked *)
	IF xPanelLedBlinked THEN
		IF TimerON.Q THEN TCtrlePanel.udiLED:=16#3FF; ELSE TCtrlePanel.udiLED:=16#0; END_IF
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_TOOL_CALCUL
VAR_INPUT
	xMicroRodActive: BOOL;			(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;		(* choice of the Axis Beckhoff or EcoStep *)
END_VAR
VAR_IN_OUT
	T_WorkTool:ST_WORKTOOL;		(* Tool Parameter *)
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                  This Functionblock calculate all needed parameter for work a Tool                                            ************)
(****************************************************************************************************************************************************)
(* calcul ToolRotation Speed in inc/64s *)
	IF (T_WorkTool.rToolRotationSpeed <> 0) AND (T_WorkTool.rToolRightGearRatio <> 0) THEN
		T_WorkTool.rToolRotationSpeedMotor:=((T_WorkTool.rToolRotationSpeed / 60.0) * 8000.0 * 64.0) / T_WorkTool.rToolRightGearRatio;
	ELSE
		RETURN;	(* Exit FB *)
	END_IF;
(* calcul ToolFeeder Speed in mm/s *)
	T_WorkTool.rToolFeederSpeedUnit:=T_WorkTool.rPitch * (T_WorkTool.rToolRotationSpeed / 60.0);
(* calcul ToolFeeder Speed in inc/64s Relativ *)
	T_WorkTool.rToolFeederSpeedMotorRel:=T_WorkTool.rToolFeederScaleFactor * T_WorkTool.rToolFeederSpeedUnit * 64.0;
(* calcul ToolFeeder Speed in inc/64s Relativ *)
	T_WorkTool.rToolFeederSpeedMotorAbs:=(T_WorkTool.rToolRotationSpeedMotor * T_WorkTool.rToolRightGearRatio) + T_WorkTool.rToolFeederSpeedMotorRel;
(* Set ToolFeeder GearDivider *)
	T_WorkTool.iToolFeederGearDivider:=T_WorkTool.iBaseGearDivider;
	IF xMicroRodActive THEN
	(* calcul ToolFeeder GearFactor *)
		IF (T_WorkTool.rPitch <> 0) THEN
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorRel));
		ELSE
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iToolFeederGearDivider) * T_WorkTool.rToolRightGearRatio);
		END_IF;
	ELSE
	(* calcul ToolFeeder GearFactor *)
		IF (T_WorkTool.rPitch <> 0) THEN
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorAbs));
		ELSE
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iToolFeederGearDivider) * T_WorkTool.rToolRightGearRatio);
		END_IF;
	END_IF;
(* calcul Time to work *)
	IF (T_WorkTool.rToolFeederSpeedUnit <> 0) THEN
		T_WorkTool.rTimeLeftWork:=(T_WorkTool.rToolLength * 10.0) / ABS(T_WorkTool.rToolFeederSpeedUnit);
	ELSE
		T_WorkTool.rTimeLeftWork:=0.0;
	END_IF;
(* calcul ToolFeeder relative Position to drive *)
	T_WorkTool.rToolFeederRelPositionUnit:=T_WorkTool.rToolLength * 10.0;
	T_WorkTool.rToolFeederRelPositionMotor:=T_WorkTool.rToolFeederRelPositionUnit * T_WorkTool.rToolFeederScaleFactor;
(* calcul GrindFeeder Speed in um/s *)
	IF (T_WorkTool.rTimeLeftWork <> 0) THEN
		T_WorkTool.rGrindFeederSpeedUnit:=T_WorkTool.rGrindFeederPlunge / T_WorkTool.rTimeLeftWork;
	ELSE
		T_WorkTool.rGrindFeederSpeedUnit:=0.0;
	END_IF;
(* calcul GrindFeeder Speed in inc/s *)
	T_WorkTool.rGrindFeederSpeedMotor:=T_WorkTool.rGrindFeederSpeedUnit * T_WorkTool.rGrindFeederScaleFactor * 64.0;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_TOOL_CALCUL_NEW
VAR_INPUT
	xMicroRodActive: BOOL;			(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;		(* choice of the Axis Beckhoff or EcoStep *)
	rToolFeedAcclDecl: REAL;
END_VAR
VAR_IN_OUT
	T_WorkTool:ST_WORKTOOL;		(* Tool Parameter *)
END_VAR
VAR_OUTPUT
END_VAR
VAR
	rWayAcclDecl: REAL;
	rWayConst: REAL;
	rTimeAcclDecl: REAL;
	rTimeConst: REAL;
	rTmpToolFeedAcclDecl: REAL;
	rCheckFactor: REAL;
	iTmpBaseGearDivider: INT;
	ii: INT;
	iChkNumber: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                  This Functionblock calculate all needed parameter for work a Tool                                            ************)
(****************************************************************************************************************************************************)
(* calcul ToolRotation Speed in inc/64s *)
	IF (T_WorkTool.rToolRotationSpeed <> 0) AND (T_WorkTool.rToolRightGearRatio <> 0) THEN
		T_WorkTool.rToolRotationSpeedMotor:=((T_WorkTool.rToolRotationSpeed / 60.0) * 8000.0 * 64.0) / T_WorkTool.rToolRightGearRatio;
	ELSE
		RETURN;	(* Exit FB *)
	END_IF;
(* calcul ToolFeeder Speed in mm/s *)
	T_WorkTool.rToolFeederSpeedUnit:=T_WorkTool.rPitch * (T_WorkTool.rToolRotationSpeed / 60.0);
(* calcul ToolFeeder Speed in inc/64s Relativ *)
	T_WorkTool.rToolFeederSpeedMotorRel:=T_WorkTool.rToolFeederScaleFactor * T_WorkTool.rToolFeederSpeedUnit * 64.0;
(* calcul ToolFeeder Speed in inc/64s Relativ *)
	T_WorkTool.rToolFeederSpeedMotorAbs:=(T_WorkTool.rToolRotationSpeedMotor * T_WorkTool.rToolRightGearRatio) + T_WorkTool.rToolFeederSpeedMotorRel;
(* Set ToolFeeder GearDivider *)
	T_WorkTool.iToolFeederGearDivider:=T_WorkTool.iBaseGearDivider;
	IF xMicroRodActive THEN
	(* calcul ToolFeeder GearFactor *)
		IF (T_WorkTool.rPitch <> 0) THEN
			iTmpBaseGearDivider:=T_WorkTool.iBaseGearDivider;
			iChkNumber:=(T_WorkTool.iBaseGearDivider / 1000) - 1;	(* iBaseGearDivider is Base 15000 *)
			(* check first if the factor *)
			rCheckFactor:=INT_TO_REAL(iTmpBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorRel);
			FOR ii:=1 TO iChkNumber DO
				IF (ABS(rCheckFactor) <= 32767.0) OR (iTmpBaseGearDivider = 1) THEN
					T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(iTmpBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorRel));
					EXIT;
				ELSE
					iTmpBaseGearDivider:=iTmpBaseGearDivider - 1000;
					IF (iTmpBaseGearDivider <= 0) THEN
						iTmpBaseGearDivider:=1;
					END_IF;
					rCheckFactor:=INT_TO_REAL(iTmpBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorRel);
				END_IF;
			END_FOR;
			T_WorkTool.iToolFeederGearDivider:=iTmpBaseGearDivider;
		ELSE
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iToolFeederGearDivider) * T_WorkTool.rToolRightGearRatio);
		END_IF;
	ELSE
	(* calcul ToolFeeder GearFactor *)
		IF (T_WorkTool.rPitch <> 0) THEN
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iBaseGearDivider) / (T_WorkTool.rToolRotationSpeedMotor / T_WorkTool.rToolFeederSpeedMotorAbs));
		ELSE
			T_WorkTool.iToolFeederGearFactor:=REAL_TO_INT(INT_TO_REAL(T_WorkTool.iToolFeederGearDivider) * T_WorkTool.rToolRightGearRatio);
		END_IF;
	END_IF;
(* calcul Time to work *)
	IF NOT(xMicroRodActive) THEN
		IF (T_WorkTool.rToolFeederSpeedUnit <> 0) THEN
			T_WorkTool.rTimeLeftWork:=(T_WorkTool.rToolLength * 10.0) / ABS(T_WorkTool.rToolFeederSpeedUnit);
		ELSE
			T_WorkTool.rTimeLeftWork:=0.0;
		END_IF;
	ELSE
		IF (T_WorkTool.rToolFeederSpeedUnit <> 0) THEN
			IF (rToolFeedAcclDecl = 0) THEN
				T_WorkTool.rTimeLeftWork:=(T_WorkTool.rToolLength * 10.0) / ABS(T_WorkTool.rToolFeederSpeedUnit);					(*calc in sec *)
			ELSE
				rTmpToolFeedAcclDecl:=rToolFeedAcclDecl * 64.0 * T_WorkTool.rToolFeederScaleFactor / 16.0;															(* calc in mm/s*s *)
				(* s_a = v^2 / 2*a *)
				rWayAcclDecl:=(T_WorkTool.rToolFeederSpeedUnit * T_WorkTool.rToolFeederSpeedUnit) / (2.0 * rTmpToolFeedAcclDecl);	(* calc in mm *)
				(* s_const = s - s_a *)
				rWayConst:=(T_WorkTool.rToolLength * 10.0) - rWayAcclDecl;														(* calc in mm *)
				IF (rWayConst <= 0) THEN	(* check if max Speed is reached *)
					(* t_a = sqrt(2*s / a) *)
					rTimeAcclDecl:=SQRT((2.0 * (T_WorkTool.rToolLength * 10.0)) / rTmpToolFeedAcclDecl);	(*calc in sec *)
					(* const velocity not reached --> t_const = 0 *)
					rTimeConst:=0.0;																	(*calc in sec *)
					(* t_total = t_a + t_const --> = t_a *)
					T_WorkTool.rTimeLeftWork:=rTimeAcclDecl + rTimeConst;								(*calc in sec *)
				ELSE
					(* t_a = sqrt(2*s_a / a) *)
					rTimeAcclDecl:=SQRT((2.0 * rWayAcclDecl) / rTmpToolFeedAcclDecl);					(*calc in sec *)
					(* t_const = s_const / v *)
					rTimeConst:=rWayConst / ABS(T_WorkTool.rToolFeederSpeedUnit);						(*calc in sec *)
					(* t_total = t_a + t_const *)
					T_WorkTool.rTimeLeftWork:=rTimeAcclDecl + rTimeConst;								(*calc in sec *)
				END_IF;
			END_IF;
		ELSE
			T_WorkTool.rTimeLeftWork:=0.0;
		END_IF;
	END_IF;
(* calcul ToolFeeder relative Position to drive *)
	T_WorkTool.rToolFeederRelPositionUnit:=T_WorkTool.rToolLength * 10.0;
	T_WorkTool.rToolFeederRelPositionMotor:=T_WorkTool.rToolFeederRelPositionUnit * T_WorkTool.rToolFeederScaleFactor;
(* calcul GrindFeeder Speed in um/s *)
	IF (T_WorkTool.rTimeLeftWork <> 0) THEN
		T_WorkTool.rGrindFeederSpeedUnit:=T_WorkTool.rGrindFeederPlunge / T_WorkTool.rTimeLeftWork;
	ELSE
		T_WorkTool.rGrindFeederSpeedUnit:=0.0;
	END_IF;
(* calcul GrindFeeder Speed in inc/s *)
	T_WorkTool.rGrindFeederSpeedMotor:=T_WorkTool.rGrindFeederSpeedUnit * T_WorkTool.rGrindFeederScaleFactor * 64.0;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION FCT_UPLOW_CASE : STRING
VAR_INPUT
	xLowConvert:BOOL;			(* FALSE=conversion to up case, TRUE=conversion in low case *)
	sInString:STRING;				(* string with 80 character, which will be convert *)
END_VAR
VAR
(* variable *)
	sListUpCase:STRING:='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	sListLowCase:STRING:='abcdefghijklmnopqrstuvwxyz';
	i:INT;
(* Tmp *)
	sTmp:STRING;
	iTmp:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                                      This function convert a String in up or low case                                                                ************)
(****************************************************************************************************************************************************)
(* Init. *)
	FCT_UPLOW_CASE:='';

(*Test string size*)
	IF LEN(sInString) < 1 OR LEN(sInString) > 255 THEN RETURN; END_IF

	IF xLowConvert THEN
	(* Conversion to low case *)
		FOR i:= 1 TO LEN(sInString) DO
			sTmp:=MID(sInString,1,i);
			iTmp:=FIND(sListUpCase,sTmp);
			IF iTmp > 0 THEN FCT_UPLOW_CASE:=CONCAT(FCT_UPLOW_CASE,MID(sListLowCase,1,iTmp));
				ELSE FCT_UPLOW_CASE:=CONCAT(FCT_UPLOW_CASE,sTmp); END_IF
		END_FOR
	(* Conversion to up case *)
	ELSE
		FOR i:= 1 TO LEN(sInString) DO
			sTmp:=MID(sInString,1,i);
			iTmp:=FIND(sListLowCase,sTmp);
			IF iTmp > 0 THEN FCT_UPLOW_CASE:=CONCAT(FCT_UPLOW_CASE,MID(sListUpCase,1,iTmp));
				ELSE FCT_UPLOW_CASE:=CONCAT(FCT_UPLOW_CASE,sTmp); END_IF
		END_FOR
	END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_HARDWARE_LAYER2\/FBHWSTATIONEN' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_STATION
VAR_INPUT
	iConfigMachineType:INT;				(* Machine config parameter, 1=MicroWire, 2=MicroRod *)
	iConfigAxisType:INT;					(* Machine config parameter, 1=EcoStep Axis, 2=Beckhoff Axis *)
	iConfigVisuNavigation:INT;				(* Machine config parameter, 1=left and right special button are active, 2=left and right touchbutton are active  *)
	rConfigMaxToolLength:REAL;			(* Machine config parameter, input of the maximal to worked tool length *)
	rPrismaFactor:REAL;					(* correction value of the GrindFeeder axis, this is depend of the settled prisma *)
	T_TwinSafeOut:ST_TWINSAFE_OUT;	(* Output of the TwinSafe components *)
	xEnableStateToolLeft:BOOL;			(* Enable state of the ToolLeft axis *)
	xEnableStateToolCenter:BOOL;			(* Enable state of the ToolCenter axis *)
	xEnableStateToolRight:BOOL;			(* Enable state of the ToolRight axis *)
	xEnableStateToolFeeder:BOOL;			(* Enable state of the ToolFeeder axis *)
	xEnableStateGrindFeeder:BOOL;		(* Enable state of the GrindFeeder axis *)
	xSensorToolTension:BOOL;			(* Signal of the sensor for the ToolTension-->this is only for the MicroRod *)
	iAToolFeederWorkLength:INT;			(* Signal for measuring the max work length of the ToolFeeder *)
END_VAR
VAR_IN_OUT
	T_HDD : ST_HDD;					(* Data structure of the file management *)
	TStation:ST_STATION;				(* Data structure of the Stationlevel *)
	T_ParamToolTensionSystem:ST_EXCHG_PARAM_TOOLTENSIONSYSTEM;	(* NovRam parameter of the ToolTension *)
	(* Ecostep PDO Parameter *)
	TToolLeftRxPdoPara:ST_RX_PDO_PARA;
	TToolLeftTxPdoPara:ST_TX_PDO_PARA;
	TToolCenterRxPdoPara:ST_RX_PDO_PARA;
	TToolCenterTxPdoPara:ST_TX_PDO_PARA;
	TToolRightRxPdoPara:ST_RX_PDO_PARA;
	TToolRightTxPdoPara:ST_TX_PDO_PARA;
	TToolFeederRxPdoPara:ST_RX_PDO_PARA;
	TToolFeederTxPdoPara:ST_TX_PDO_PARA;
	TGrindFeederRxPdoPara:ST_RX_PDO_PARA;
	TGrindFeederTxPdoPara:ST_TX_PDO_PARA;
	(* Beckhoff Axis structure *)
	stToolLeftRefIn :NCTOPLC_AXLESTRUCT;
	stToolLeftRefOut :PLCTONC_AXLESTRUCT;
	stToolCenterRefIn :NCTOPLC_AXLESTRUCT;
	stToolCenterRefOut :PLCTONC_AXLESTRUCT;
	stToolRightRefIn :NCTOPLC_AXLESTRUCT;
	stToolRightRefOut :PLCTONC_AXLESTRUCT;
	stToolFeederRefIn :NCTOPLC_AXLESTRUCT;
	stToolFeederRefOut :PLCTONC_AXLESTRUCT;
	stGrindFeederRefIn :NCTOPLC_AXLESTRUCT;
	stGrindFeederRefOut :PLCTONC_AXLESTRUCT;
	auiActualAxisTorqueBeckhoff:ARRAY [1..5] OF UINT;
	axInputAxisBeckhoff : ARRAY[1..5,1..8] OF BOOL;
END_VAR
VAR_OUTPUT
	xResetControllerToolLeft:BOOL;			(* Reset output for the ToolLeft axis *)
	xResetControllerToolCenter:BOOL;		(* Reset output for the ToolCenter axis *)
	xResetControllerToolRight:BOOL;		(* Reset output for the ToolRight axis *)
	xResetControllerToolFeeder:BOOL;		(* Reset output for the ToolFeeder axis *)
	xResetControllerGrindFeeder:BOOL;		(* Reset output for the GrindFeeder axis *)
	xSetEnableAxisToolLeft:BOOL;			(* Enable output for the ToolLeft axis *)
	xSetEnableAxisToolCenter:BOOL;		(* Enable output for the ToolCenter axis *)
	xSetEnableAxisToolRight:BOOL;			(* Enable output for the ToolRight axis *)
	xSetEnableAxisToolFeeder:BOOL;		(* Enable output for the ToolFeeder axis *)
	xSetEnableAxisGrindFeeder:BOOL;		(* Enable output for the GrindFeeder axis *)
	xActiveHWStation : BOOL;				(* state of the activation of the station hardware *)
	xCylOutToolTension : BOOL;			(* ventil for the Cylinder ToolTension *)
(*22.12.2009: KFS {    *)
	xCylOutToolLeftActive : BOOL;			(* ventil for the Cylinder ToolLeft *)
	xCylOutToolRightActive: BOOL;			(* ventil for the Cylinder ToolRight *)
	xCylOutToolCenterActive : BOOL;		(* ventil for the Cylinder ToolCenter *)
	xCylOutToolPrismaLeftActive : BOOL;		(* ventil for the Cylinder ToolPrismaLeft *)
	xCylOutToolPrismaRightActive : BOOL;	(* ventil for the Cylinder ToolPrismaRight *)
	xCtrlLampToolLeftButton : BOOL;			(* control lamp button for the Cylinder ToolLeft *)
	xCtrlLampToolRightButton : BOOL;		(* control lamp button for the Cylinder ToolRight*)
	xCtrlLampToolCenterButton : BOOL;		(* control lamp button for the Cylinder ToolCenter *)
	xCtrlLampToolPrismaLeftButton : BOOL;	(* control lamp button for the Cylinder ToolPrismaLeft *)
	xCtrlLampToolPrismaRightButton : BOOL;	(* control lamp button for the Cylinder ToolPrismaRight *)
	xCtrlLampToolTensionButton : BOOL;		(* control lamp button for the Cylinder ToolTension *)
(*22.12.2009: KFS }    *)
	iCylOutAnaToolTension : INT;			(* servoventil for the Cylinder ToolTension *)
END_VAR
VAR
(* Ecostep Driver *)
	FBAxisToolLeftEcostep: FBHW_AXIS_SINGLE_ECOSTEP;
	FBAxisToolCenterEcostep: FBHW_AXIS_SINGLE_ECOSTEP;
	FBAxisToolRightEcostep: FBHW_AXIS_SINGLE_ECOSTEP;
	FBAxisToolFeederEcostep: FBHW_AXIS_SINGLE_ECOSTEP;
	FBAxisGrindFeederEcostep: FBHW_AXIS_SINGLE_ECOSTEP;
	FBLivevalueAxisToolLeftEcostep: FBHW_AXIS_LIVEVALUES_ECOSTEP;
	FBLivevalueAxisToolCenterEcostep: FBHW_AXIS_LIVEVALUES_ECOSTEP;
	FBLivevalueAxisToolRightEcostep: FBHW_AXIS_LIVEVALUES_ECOSTEP;
	FBLivevalueAxisToolFeederEcostep: FBHW_AXIS_LIVEVALUES_ECOSTEP;
	FBLivevalueAxisGrindFeederEcostep: FBHW_AXIS_LIVEVALUES_ECOSTEP;

(* Beckhoff Driver *)
	FBAxisToolLeftBeckhoff: FBHW_AXIS_SINGLE_BECKHOFF;
	FBAxisToolCenterBeckhoff: FBHW_AXIS_SINGLE_BECKHOFF;
	FBAxisToolRightBeckhoff: FBHW_AXIS_SINGLE_BECKHOFF;
	FBAxisToolFeederBeckhoff: FBHW_AXIS_SINGLE_BECKHOFF;
	FBAxisGrindFeederBeckhoff: FBHW_AXIS_SINGLE_BECKHOFF;
	FBLivevalueAxisToolLeftBeckhoff: FBHW_AXIS_LIVEVALUES_BECKHOFF;
	FBLivevalueAxisToolCenterBeckhoff: FBHW_AXIS_LIVEVALUES_BECKHOFF;
	FBLivevalueAxisToolRightBeckhoff: FBHW_AXIS_LIVEVALUES_BECKHOFF;
	FBLivevalueAxisToolFeederBeckhoff: FBHW_AXIS_LIVEVALUES_BECKHOFF;
	FBLivevalueAxisGrindFeederBeckhoff: FBHW_AXIS_LIVEVALUES_BECKHOFF;
	FBToolLeftMasterSlave:FBHW_AXIS_MULTI_BECKHOFF;
	FBToolCenterMasterSlave:FBHW_AXIS_MULTI_BECKHOFF;
	FBToolRightMasterSlave:FBHW_AXIS_MULTI_BECKHOFF;
	FBToolFeederMasterSlave:FBHW_AXIS_MULTI_BECKHOFF;
	FBCylToolTension : FBHW_CYL_ANALOGCYLINDER;
(*22.12.2009: KFS {    *)
	(*FBCalcToolTensionForce:FB_CALC_TOOLTENSION_FORCE;*)
	FBCalcToolTensionForce:FB_CALC_TOOLTENSION_FORCE_NEW;
	FBCylToolLeftActive:FBHW_CYL_STANDARD;
	FBCylToolRightActive:FBHW_CYL_STANDARD;
	FBCylToolCenterActive:FBHW_CYL_STANDARD;
	FBCylToolPrismaLeftActive:FBHW_CYL_STANDARD;
	FBCylToolPrismaRightActive:FBHW_CYL_STANDARD;
(*22.12.2009: KFS }   *)

(* Pointer auf Actuatoren *)
	ptrTAxisToolLeft:POINTER TO ST_AXIS;
	ptrTAxisToolCenter:POINTER TO ST_AXIS;
	ptrTAxisToolRight:POINTER TO ST_AXIS;
	ptrTAxisToolFeeder:POINTER TO ST_AXIS;
	ptrTAxisGrindFeeder:POINTER TO ST_AXIS;
	ptrTCylToolTension:POINTER TO ST_CYLINDER;
(*22.12.2009: KFS {    *)
	ptrTCylToolLeftActive:POINTER TO ST_CYLINDER;
	ptrTCylToolRightActive:POINTER TO ST_CYLINDER;
	ptrTCylToolCenterActive:POINTER TO ST_CYLINDER;
	ptrTCylToolPrismaLeftActive:POINTER TO ST_CYLINDER;
	ptrTCylToolPrismaRightActive:POINTER TO ST_CYLINDER;
	ptrTToolFeederWorkLength:POINTER TO ST_CYLINDER;
(*22.12.2009: KFS }   *)
	RisingEdgeHWConfig:R_TRIG;
	TONTickTime: TON;
	RisingEdgeSetError:R_TRIG;
	xHardwareConfigError: BOOL;
	xTmp: BOOL;
	xMicroRodActive: BOOL;
	xBeckhoffDriveActive: BOOL;
	xCkeckAcitveMovement: BOOL;

	axInputAxisToolLeftBeckhoff : ARRAY[1..8] OF BOOL;
	axInputAxisToolCenterBeckhoff : ARRAY[1..8] OF BOOL;
	axInputAxisToolRightBeckhoff : ARRAY[1..8] OF BOOL;
	axInputAxisToolFeederBeckhoff : ARRAY[1..8] OF BOOL;
	axInputAxisGrindFeederBeckhoff : ARRAY[1..8] OF BOOL;
	ii: INT;
	xFirstRead: BOOL;
	iStepResetHardware: INT;
	TONWaitReset: TON;
	rMaxWorkLength:REAL:=27;	 (* 0mm - 270mm = 0V - 10V  --> 270mm  --> Eingabe in cm! *)
	rMeasureWorkLengthCorrection:REAL:=0.4; (*Rundungs-Korrektur in cm*)
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                            This Functionblock manage all the machine hardware                                                           ************)
(****************************************************************************************************************************************************)
(******************************************************************************************************************************************)
(****************************				              Activation Part                                                         *****************************)
(******************************************************************************************************************************************)
IF NOT(xFirstRead) THEN
	xFirstRead:=TRUE;
	TStation.THardware.TAxisToolLeft.T_RxPdoParameter.iControlWord:=6;
	TToolLeftRxPdoPara:=TStation.THardware.TAxisToolLeft.T_RxPdoParameter;
	TStation.THardware.TAxisToolCenter.T_RxPdoParameter.iControlWord:=6;
	TToolCenterRxPdoPara:=TStation.THardware.TAxisToolCenter.T_RxPdoParameter;
	TStation.THardware.TAxisToolRight.T_RxPdoParameter.iControlWord:=6;
	TToolRightRxPdoPara:=TStation.THardware.TAxisToolRight.T_RxPdoParameter;
	TStation.THardware.TAxisToolFeeder.T_RxPdoParameter.iControlWord:=6;
	TToolFeederRxPdoPara:=TStation.THardware.TAxisToolFeeder.T_RxPdoParameter;
	TStation.THardware.TAxisGrindFeeder.T_RxPdoParameter.iControlWord:=6;
	TGrindFeederRxPdoPara:=TStation.THardware.TAxisGrindFeeder.T_RxPdoParameter;
	(*06.12.2010 KFS:	{	*)
	T_Station.xOverwriteMaxToolLength:=FALSE;
	(*06.12.2010 KFS:	}	*)
END_IF;
IF TStation.TControl.xResetHardware THEN
	CASE iStepResetHardware OF
	1:	xResetControllerToolLeft:=TRUE;
		xResetControllerToolCenter:=TRUE;
		xResetControllerToolRight:=TRUE;
		xResetControllerToolFeeder:=TRUE;
		xResetControllerGrindFeeder:=TRUE;
		TONWaitReset(IN:=FALSE);
		iStepResetHardware:=iStepResetHardware + 1;
	2:	TONWaitReset(IN:=TRUE,PT:=T#100ms);
		IF TONWaitReset.Q THEN
			xResetControllerToolLeft:=FALSE;
			xResetControllerToolCenter:=FALSE;
			xResetControllerToolRight:=FALSE;
			xResetControllerToolFeeder:=FALSE;
			xResetControllerGrindFeeder:=FALSE;
			iStepResetHardware:=iStepResetHardware + 1;
		END_IF;
	3:	TStation.THardware.TAxisToolLeft.T_RxPdoParameter.iControlWord:=0;
		TToolLeftRxPdoPara:=TStation.THardware.TAxisToolLeft.T_RxPdoParameter;
		TStation.THardware.TAxisToolCenter.T_RxPdoParameter.iControlWord:=0;
		TToolCenterRxPdoPara:=TStation.THardware.TAxisToolCenter.T_RxPdoParameter;
		TStation.THardware.TAxisToolRight.T_RxPdoParameter.iControlWord:=0;
		TToolRightRxPdoPara:=TStation.THardware.TAxisToolRight.T_RxPdoParameter;
		TStation.THardware.TAxisToolFeeder.T_RxPdoParameter.iControlWord:=0;
		TToolFeederRxPdoPara:=TStation.THardware.TAxisToolFeeder.T_RxPdoParameter;
		TStation.THardware.TAxisGrindFeeder.T_RxPdoParameter.iControlWord:=0;
		TGrindFeederRxPdoPara:=TStation.THardware.TAxisGrindFeeder.T_RxPdoParameter;
		TONWaitReset(IN:=FALSE);
		iStepResetHardware:=iStepResetHardware + 1;
	4:	TONWaitReset(IN:=TRUE,PT:=T#100ms);
		IF TONWaitReset.Q THEN
			TStation.THardware.TAxisToolLeft.T_RxPdoParameter.iControlWord:=6;
			TToolLeftRxPdoPara:=TStation.THardware.TAxisToolLeft.T_RxPdoParameter;
			TStation.THardware.TAxisToolCenter.T_RxPdoParameter.iControlWord:=6;
			TToolCenterRxPdoPara:=TStation.THardware.TAxisToolCenter.T_RxPdoParameter;
			TStation.THardware.TAxisToolRight.T_RxPdoParameter.iControlWord:=6;
			TToolRightRxPdoPara:=TStation.THardware.TAxisToolRight.T_RxPdoParameter;
			TStation.THardware.TAxisToolFeeder.T_RxPdoParameter.iControlWord:=6;
			TToolFeederRxPdoPara:=TStation.THardware.TAxisToolFeeder.T_RxPdoParameter;
			TStation.THardware.TAxisGrindFeeder.T_RxPdoParameter.iControlWord:=6;
			TGrindFeederRxPdoPara:=TStation.THardware.TAxisGrindFeeder.T_RxPdoParameter;
			TONWaitReset(IN:=FALSE);
			iStepResetHardware:=1;
			TStation.TControl.xResetHardware:=FALSE;
		END_IF;
	END_CASE;
	RETURN;
ELSE
	iStepResetHardware:=1;
END_IF;
xActiveHWStation:=TStation.TControl.xActiveHardware;
RisingEdgeHWConfig(CLK:=xHardwareConfigError);
IF RisingEdgeHWConfig.Q THEN
	TStation.TControl.diErrorNr:=0;
	TStation.TControl.xError:=FALSE;
END_IF;
IF NOT(TStation.TControl.xActiveHardware) THEN
	TStation.TControl.xHWAxesActive:=TRUE;
	xHardwareConfigError:=FALSE;
	TONTickTime(IN:=FALSE);
	RisingEdgeSetError(CLK:=FALSE);
	TStation.TControl.xActiveMovement:=FALSE;
	RETURN;
ELSE
	(* Check Hardware Configuration *)
	IF TStation.TControl.xRdy THEN
		xTmp:=	(TStation.T_MachineConfig.iConfigMachineType <> iConfigMachineType) OR
				(TStation.T_MachineConfig.iConfigAxisType <> iConfigAxisType) OR
				(TStation.T_MachineConfig.iConfigVisuNavigation <> iConfigVisuNavigation) OR
				( (TStation.T_MachineConfig.rConfigMaxToolLength <> rConfigMaxToolLength) AND NOT(T_Station.xOverwriteMaxToolLength));
		IF xTmp THEN
			IF (TStation.T_MachineConfig.iConfigMachineType <> iConfigMachineType) THEN
				TStation.TControl.diErrorNr:=7001;	(* Error-->Config Machine Type changed *)
			END_IF;
			IF (TStation.T_MachineConfig.iConfigAxisType <> iConfigAxisType) THEN
				TStation.TControl.diErrorNr:=7002;	(* Error-->Config Axis Type changed *)
			END_IF;
			IF (TStation.T_MachineConfig.iConfigVisuNavigation <> iConfigVisuNavigation) THEN
				TStation.TControl.diErrorNr:=7003;	(* Error-->Config Visu Navigation changed *)
			END_IF;
			IF (TStation.T_MachineConfig.rConfigMaxToolLength <> rConfigMaxToolLength) THEN
				TStation.TControl.diErrorNr:=7004;	(* Error-->Config Max Tool Length changed *)
			END_IF;
			RisingEdgeSetError(CLK:=TRUE);
			IF RisingEdgeSetError.Q THEN
				TStation.TControl.xError:=TRUE;
			END_IF;
			xHardwareConfigError:=TRUE;
			TStation.TControl.xHardwareConfigError:=TRUE;
		END_IF;
	END_IF;
	IF xHardwareConfigError THEN
		TStation.TControl.xActiveMovement:=FALSE;
		RETURN;
	END_IF;
	IF NOT(TStation.TControl.xHardwareConfigError) THEN
		RisingEdgeSetError(CLK:=FALSE);
	END_IF;
	(* Zuweisung der Datenstrukturen der Aktuatoren als Pointer *)
	ptrTAxisToolLeft:=ADR(TStation.THardware.TAxisToolLeft);
	ptrTAxisToolCenter:=ADR(TStation.THardware.TAxisToolCenter);
	ptrTAxisToolRight:=ADR(TStation.THardware.TAxisToolRight);
	ptrTAxisToolFeeder:=ADR(TStation.THardware.TAxisToolFeeder);
	ptrTAxisGrindFeeder:=ADR(TStation.THardware.TAxisGrindFeeder);
	ptrTCylToolTension:=ADR(TStation.THardware.TCylToolTension);
(*22.12.2009: KFS {    *)
	ptrTCylToolLeftActive:=ADR(TStation.THardware.TCylToolLeftActive);
	ptrTCylToolRightActive:=ADR(TStation.THardware.TCylToolRightActive);
	ptrTCylToolCenterActive:=ADR(TStation.THardware.TCylToolCenterActive);
	ptrTCylToolPrismaLeftActive:=ADR(TStation.THardware.TCylToolPrismaLeftActive);
	ptrTCylToolPrismaRightActive:=ADR(TStation.THardware.TCylToolPrismaRightActive);
	ptrTToolFeederWorkLength:=ADR(TStation.THardware.TToolFeederWorkLength);
(*22.12.2009: KFS }   *)
	IF (iConfigMachineType = 2) THEN
		xMicroRodActive:=TRUE;
	ELSE
		xMicroRodActive:=FALSE;
	END_IF;
	IF (iConfigAxisType = 2) THEN
		xBeckhoffDriveActive:=TRUE;
	ELSE
		xBeckhoffDriveActive:=FALSE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				         Check if Axis Active                                                    *****************************)
(******************************************************************************************************************************************)
xTmp:= ptrTAxisToolLeft^.T_CtrleSingle.xDone AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone;
xTmp:=xTmp AND ((ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive));
IF xTmp THEN
	TStation.TControl.xHWAxesActive:=FALSE;
ELSE
	TStation.TControl.xHWAxesActive:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************	                        Check if Axis and Cylinder are Active                               *****************************)
(******************************************************************************************************************************************)
xCkeckAcitveMovement:=	(NOT(ptrTAxisToolLeft^.T_CtrleSingle.xDone) AND NOT(ptrTAxisToolLeft^.T_CtrleSingle.xErr)) OR
						(NOT(ptrTAxisToolRight^.T_CtrleSingle.xDone) AND NOT(ptrTAxisToolRight^.T_CtrleSingle.xErr)) OR
						(NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xDone) AND NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xErr)) OR
						(NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xDone) AND NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xErr)) OR
						(NOT(ptrTAxisToolCenter^.T_CtrleSingle.xDone) AND NOT(ptrTAxisToolCenter^.T_CtrleSingle.xErr) AND xMicroRodActive) OR
(*22.12.2009: KFS {    *)		(NOT(ptrTCylToolLeftActive^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolLeftActive^.T_CtrleCyl.xErr) AND xMicroRodActive) OR
						(NOT(ptrTCylToolRightActive^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolRightActive^.T_CtrleCyl.xErr) AND xMicroRodActive) OR
						(NOT(ptrTCylToolCenterActive^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolCenterActive^.T_CtrleCyl.xErr) AND xMicroRodActive) OR
						(NOT(ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xErr) AND xMicroRodActive) OR
						(NOT(ptrTCylToolPrismaRightActive^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolPrismaRightActive^.T_CtrleCyl.xErr) AND xMicroRodActive) OR	(*22.12.2009: KFS }   *)
						(NOT(ptrTCylToolTension^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolTension^.T_CtrleCyl.xErr));
IF NOT(xCkeckAcitveMovement) THEN
	IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xNotMoving) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND NOT(ptrTAxisToolLeft^.T_CtrleSingle.xErr) THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
	IF NOT(ptrTAxisToolRight^.T_CtrleSingle.xNotMoving) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND NOT(ptrTAxisToolRight^.T_CtrleSingle.xErr) THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
	IF NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xNotMoving) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xErr) THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
	IF NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xNotMoving) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone AND NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xErr) THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
	IF NOT(ptrTAxisToolCenter^.T_CtrleSingle.xNotMoving) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND NOT(ptrTAxisToolCenter^.T_CtrleSingle.xErr) AND xMicroRodActive THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
END_IF;
TStation.TControl.xActiveMovement:=xCkeckAcitveMovement;
IF NOT(xBeckhoffDriveActive) THEN
	(******************************************************************************************************************************************)
	(****************************				   Axis ToolLeft PDO Parameter                                      *****************************)
	(******************************************************************************************************************************************)
	TToolLeftRxPdoPara:=ptrTAxisToolLeft^.T_RxPdoParameter;
	ptrTAxisToolLeft^.T_TxPdoParameter:=TToolLeftTxPdoPara;
	(******************************************************************************************************************************************)
	(****************************				         Axis ToolLeft Live Values                                        *****************************)
	(******************************************************************************************************************************************)
	FBLivevalueAxisToolLeftEcostep(	iTypAxis:=1,
									rPrismaFactor:=0,
									xMicroRodActive:=xMicroRodActive,
									T_Axis:= ptrTAxisToolLeft^);
	(******************************************************************************************************************************************)
	(****************************				         Axis ToolLeft Motion                                                  *****************************)
	(******************************************************************************************************************************************)
	FBAxisToolLeftEcostep(	xCircuitPowerOn:= T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4,
							rPrismaFactor:=0,
							T_Axis:= ptrTAxisToolLeft^,
							T_HDD:= T_HDD);
	xResetControllerToolLeft:=FBAxisToolLeftEcostep.xResetController;
	xSetEnableAxisToolLeft:=FBAxisToolLeftEcostep.xSetEnableAxis;
	IF xMicroRodActive THEN
		(******************************************************************************************************************************************)
		(****************************		     	      Axis ToolCenter PDO Parameter                                      *****************************)
		(******************************************************************************************************************************************)
		TToolCenterRxPdoPara:=ptrTAxisToolCenter^.T_RxPdoParameter;
		ptrTAxisToolCenter^.T_TxPdoParameter:=TToolCenterTxPdoPara;
		(******************************************************************************************************************************************)
		(****************************				      Axis ToolCenter Live Values                                     *****************************)
		(******************************************************************************************************************************************)
		FBLivevalueAxisToolCenterEcostep(	iTypAxis:=2,
										rPrismaFactor:=0,
										xMicroRodActive:=xMicroRodActive,
										T_Axis:= ptrTAxisToolCenter^);
		(******************************************************************************************************************************************)
		(****************************				      Axis ToolCenter Motion                                               *****************************)
		(******************************************************************************************************************************************)
		FBAxisToolCenterEcostep(	xCircuitPowerOn:= T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4,
								rPrismaFactor:=0,
								T_Axis:= ptrTAxisToolCenter^,
								T_HDD:= T_HDD);
		xResetControllerToolCenter:=FBAxisToolCenterEcostep.xResetController;
		xSetEnableAxisToolCenter:=FBAxisToolCenterEcostep.xSetEnableAxis;
	ELSE
		xResetControllerToolCenter:=FALSE;
		xSetEnableAxisToolCenter:=FALSE;
	END_IF;
	(******************************************************************************************************************************************)
	(****************************			         Axis ToolRight PDO Parameter                                      *****************************)
	(******************************************************************************************************************************************)
	TToolRightRxPdoPara:=ptrTAxisToolRight^.T_RxPdoParameter;
	ptrTAxisToolRight^.T_TxPdoParameter:=TToolRightTxPdoPara;
	(******************************************************************************************************************************************)
	(****************************				        Axis ToolRight Live Values                                      *****************************)
	(******************************************************************************************************************************************)
	FBLivevalueAxisToolRightEcostep(	iTypAxis:=3,
									rPrismaFactor:=0,
									xMicroRodActive:=xMicroRodActive,
									T_Axis:= ptrTAxisToolRight^);
	(******************************************************************************************************************************************)
	(****************************				         Axis ToolRight Motion                                               *****************************)
	(******************************************************************************************************************************************)
	FBAxisToolRightEcostep(	xCircuitPowerOn:= T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4,
							rPrismaFactor:=0,
							T_Axis:= ptrTAxisToolRight^,
							T_HDD:= T_HDD);
	xResetControllerToolRight:=FBAxisToolRightEcostep.xResetController;
	xSetEnableAxisToolRight:=FBAxisToolRightEcostep.xSetEnableAxis;
	(******************************************************************************************************************************************)
	(****************************			      Axis ToolFeeder PDO Parameter                                    *****************************)
	(******************************************************************************************************************************************)
	TToolFeederRxPdoPara:=ptrTAxisToolFeeder^.T_RxPdoParameter;
	ptrTAxisToolFeeder^.T_TxPdoParameter:=TToolFeederTxPdoPara;
	(******************************************************************************************************************************************)
	(****************************				    Axis ToolFeeder Live Values                                     *****************************)
	(******************************************************************************************************************************************)
	FBLivevalueAxisToolFeederEcostep(	iTypAxis:=4,
										rPrismaFactor:=0,
										xMicroRodActive:=xMicroRodActive,
										T_Axis:= ptrTAxisToolFeeder^);
	(******************************************************************************************************************************************)
	(****************************				      Axis ToolFeeder Motion                                             *****************************)
	(******************************************************************************************************************************************)
	FBAxisToolFeederEcostep(	xCircuitPowerOn:= T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4,
								rPrismaFactor:=0,
								T_Axis:= ptrTAxisToolFeeder^,
								T_HDD:= T_HDD);
	xResetControllerToolFeeder:=FBAxisToolFeederEcostep.xResetController;
	xSetEnableAxisToolFeeder:=FBAxisToolFeederEcostep.xSetEnableAxis;
	(******************************************************************************************************************************************)
	(****************************			          Axis GrindFeeder PDO Parameter                               *****************************)
	(******************************************************************************************************************************************)
	TGrindFeederRxPdoPara:=ptrTAxisGrindFeeder^.T_RxPdoParameter;
	ptrTAxisGrindFeeder^.T_TxPdoParameter:=TGrindFeederTxPdoPara;
	(******************************************************************************************************************************************)
	(****************************				     Axis GrindFeeder Live Values                                   *****************************)
	(******************************************************************************************************************************************)
	FBLivevalueAxisGrindFeederEcostep(	iTypAxis:=5,
										rPrismaFactor:=rPrismaFactor,
										xMicroRodActive:=xMicroRodActive,
										T_Axis:= ptrTAxisGrindFeeder^);
	(******************************************************************************************************************************************)
	(****************************		           	      Axis GrindFeeder Motion                                            *****************************)
	(******************************************************************************************************************************************)
	FBAxisGrindFeederEcostep(	xCircuitPowerOn:= T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4,
								rPrismaFactor:=rPrismaFactor,
								T_Axis:= ptrTAxisGrindFeeder^,
								T_HDD:= T_HDD);
	xResetControllerGrindFeeder:=FBAxisGrindFeederEcostep.xResetController;
	xSetEnableAxisGrindFeeder:=FBAxisGrindFeederEcostep.xSetEnableAxis;
END_IF;
IF xBeckhoffDriveActive THEN
	(******************************************************************************************************************************************)
	(****************************				         Axis ToolLeft Live Values                                        *****************************)
	(******************************************************************************************************************************************)
	FOR ii:=1 TO 8 DO
		axInputAxisToolLeftBeckhoff[ii]:=axInputAxisBeckhoff[1,ii];
	END_FOR
	FBLivevalueAxisToolLeftBeckhoff(	uiActualTorque:=auiActualAxisTorqueBeckhoff[1],
									arxDigitalInput:=axInputAxisToolLeftBeckhoff,
									T_AXIS:=ptrTAxisToolLeft^,
									T_AXISRefIn:=stToolLeftRefIn);

	(******************************************************************************************************************************************)
	(****************************				         Axis ToolLeft Motion                                                  *****************************)
	(******************************************************************************************************************************************)
	FBAxisToolLeftBeckhoff(	xHWLimitPos:= FALSE,
							xHWLimitNeg:= FALSE,
							xRefHoming:= FALSE,
							T_Axis:= ptrTAxisToolLeft^,
							T_AxisRefIn:= stToolLeftRefIn,
							T_AxisRefOut:= stToolLeftRefOut,
							T_HDD:= T_HDD);

	(******************************************************************************************************************************************)
	(****************************				            Axis ToolLeft Mulit                                                    *****************************)
	(******************************************************************************************************************************************)
	IF xMicroRodActive THEN
		FBToolLeftMasterSlave(	T_AxisMaster:=ptrTAxisToolLeft^ ,
								T_AxisSlave:= ptrTAxisToolCenter^,
								T_AxisMasterRefIn:= stToolLeftRefIn,
								T_AxisSlaveRefIn:= stToolCenterRefIn);
	ELSE
		FBToolLeftMasterSlave(	T_AxisMaster:=ptrTAxisToolLeft^ ,
								T_AxisSlave:= ptrTAxisToolRight^,
								T_AxisMasterRefIn:= stToolLeftRefIn,
								T_AxisSlaveRefIn:= stToolRightRefIn);
	END_IF;

	IF xMicroRodActive THEN
		(******************************************************************************************************************************************)
		(****************************				      Axis ToolCenter Live Values                                     *****************************)
		(******************************************************************************************************************************************)
		FOR ii:=1 TO 8 DO
			axInputAxisToolCenterBeckhoff[ii]:=axInputAxisBeckhoff[2,ii];
		END_FOR
		FBLivevalueAxisToolCenterBeckhoff(	uiActualTorque:=auiActualAxisTorqueBeckhoff[2],
										arxDigitalInput:=axInputAxisToolCenterBeckhoff,
										T_AXIS:=ptrTAxisToolCenter^,
										T_AXISRefIn:=stToolCenterRefIn);

		(******************************************************************************************************************************************)
		(****************************				      Axis ToolCenter Motion                                               *****************************)
		(******************************************************************************************************************************************)
		FBAxisToolCenterBeckhoff(	xHWLimitPos:= FALSE,
								xHWLimitNeg:= FALSE,
								xRefHoming:= FALSE,
								T_Axis:= ptrTAxisToolCenter^,
								T_AxisRefIn:= stToolCenterRefIn,
								T_AxisRefOut:= stToolCenterRefOut,
								T_HDD:= T_HDD);

		(******************************************************************************************************************************************)
		(****************************				        Axis ToolCenter Mulit                                                 *****************************)
		(******************************************************************************************************************************************)
		FBToolCenterMasterSlave(	T_AxisMaster:=ptrTAxisToolCenter^ ,
								T_AxisSlave:= ptrTAxisToolRight^,
								T_AxisMasterRefIn:= stToolCenterRefIn,
								T_AxisSlaveRefIn:= stToolRightRefIn);
	END_IF;

	(******************************************************************************************************************************************)
	(****************************				        Axis ToolRight Live Values                                      *****************************)
	(******************************************************************************************************************************************)
	FOR ii:=1 TO 8 DO
		axInputAxisToolRightBeckhoff[ii]:=axInputAxisBeckhoff[3,ii];
	END_FOR
	FBLivevalueAxisToolRightBeckhoff(	uiActualTorque:=auiActualAxisTorqueBeckhoff[3],
									arxDigitalInput:=axInputAxisToolRightBeckhoff,
									T_AXIS:=ptrTAxisToolRight^,
									T_AXISRefIn:=stToolRightRefIn);

	(******************************************************************************************************************************************)
	(****************************				         Axis ToolRight Motion                                               *****************************)
	(******************************************************************************************************************************************)
	FBAxisToolRightBeckhoff(	xHWLimitPos:= FALSE,
							xHWLimitNeg:= FALSE,
							xRefHoming:= FALSE,
							T_Axis:= ptrTAxisToolRight^,
							T_AxisRefIn:= stToolRightRefIn,
							T_AxisRefOut:= stToolRightRefOut,
							T_HDD:= T_HDD);

	(******************************************************************************************************************************************)
	(****************************				            Axis ToolRight Mulit                                                *****************************)
	(******************************************************************************************************************************************)
	FBToolRightMasterSlave(	T_AxisMaster:=ptrTAxisToolRight^ ,
							T_AxisSlave:= ptrTAxisToolFeeder^,
							T_AxisMasterRefIn:= stToolRightRefIn,
							T_AxisSlaveRefIn:= stToolFeederRefIn);

	(******************************************************************************************************************************************)
	(****************************				    Axis ToolFeeder Live Values                                     *****************************)
	(******************************************************************************************************************************************)
	FOR ii:=1 TO 8 DO
		axInputAxisToolFeederBeckhoff[ii]:=axInputAxisBeckhoff[4,ii];
	END_FOR
	FBLivevalueAxisToolFeederBeckhoff(	uiActualTorque:=auiActualAxisTorqueBeckhoff[4],
										arxDigitalInput:=axInputAxisToolFeederBeckhoff,
										T_AXIS:=ptrTAxisToolFeeder^,
										T_AXISRefIn:=stToolFeederRefIn);

	(******************************************************************************************************************************************)
	(****************************				      Axis ToolFeeder Motion                                             *****************************)
	(******************************************************************************************************************************************)
	FBAxisToolFeederBeckhoff(	xHWLimitPos:= FALSE,
								xHWLimitNeg:= FALSE,
								xRefHoming:= FALSE,
								T_Axis:= ptrTAxisToolFeeder^,
								T_AxisRefIn:= stToolFeederRefIn,
								T_AxisRefOut:= stToolFeederRefOut,
								T_HDD:= T_HDD);

	(******************************************************************************************************************************************)
	(****************************				            Axis ToolFeeder Mulit                                            *****************************)
	(******************************************************************************************************************************************)
	FBToolFeederMasterSlave(T_AxisMaster:=ptrTAxisToolFeeder^ ,
							T_AxisSlave:= ptrTAxisGrindFeeder^,
							T_AxisMasterRefIn:= stToolFeederRefIn,
							T_AxisSlaveRefIn:= stGrindFeederRefIn);

	(******************************************************************************************************************************************)
	(****************************				     Axis GrindFeeder Live Values                                   *****************************)
	(******************************************************************************************************************************************)
	FOR ii:=1 TO 8 DO
		axInputAxisGrindFeederBeckhoff[ii]:=axInputAxisBeckhoff[5,ii];
	END_FOR
	FBLivevalueAxisGrindFeederBeckhoff(	uiActualTorque:=auiActualAxisTorqueBeckhoff[5],
										arxDigitalInput:=axInputAxisGrindFeederBeckhoff,
										T_AXIS:=ptrTAxisGrindFeeder^,
										T_AXISRefIn:=stGrindFeederRefIn);

	(******************************************************************************************************************************************)
	(****************************		           	      Axis GrindFeeder Motion                                            *****************************)
	(******************************************************************************************************************************************)
	FBAxisGrindFeederBeckhoff(	xHWLimitPos:= FALSE,
								xHWLimitNeg:= FALSE,
								xRefHoming:= FALSE,
								T_Axis:= ptrTAxisGrindFeeder^,
								T_AxisRefIn:= stGrindFeederRefIn,
								T_AxisRefOut:= stGrindFeederRefOut,
								T_HDD:= T_HDD);

	(******************************************************************************************************************************************)
	(****************************				           Axis GrindFeeder Mulit                                            *****************************)
	(******************************************************************************************************************************************)
	(* No Slave Axis for Axis GrindFeeder *)
END_IF;

(******************************************************************************************************************************************)
(****************************		                       Cylinder für  ToolTension                                             *****************************)
(******************************************************************************************************************************************)
FBCalcToolTensionForce(	rForcePistonIn:= ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.rForceIn,
						rPistonDiameterD1:= T_ParamToolTensionSystem.rPistonDiameterTT,
						rPistonDiameterD2:= T_ParamToolTensionSystem.rPistonDiameterTT2,
						rMaxAirpressure:= T_ParamToolTensionSystem.rAirPressureTT,
						rFactorForce:= T_ParamToolTensionSystem.rFactorForce);
T_ParamToolTensionSystem.rMaxForceTT:=FBCalcToolTensionForce.rSetMaxForce;
ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.iAnalogIN:=FBCalcToolTensionForce.iAnalogOutput;
ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.rForceOut:=FBCalcToolTensionForce.rForcePistonOut;
FBCylToolTension(	xCtrlePosOn:=xSensorToolTension,
					xCtrlePosOff:=FALSE,
					iAnalogIn:= ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.iAnalogIN,
					T_Cylinder:= ptrTCylToolTension^);
iCylOutAnaToolTension:=FBCylToolTension.iAnalogOut;
ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.iAnalogOut:=FBCylToolTension.iAnalogOut;
xCylOutToolTension:=FBCylToolTension.xCylinder;
IF xMicroRodActive THEN
	(* control lamp button for the Cylinder ToolTension *)
	xCtrlLampToolTensionButton:=FBCylToolTension.xCylinder;
END_IF
(******************************************************************************************************************************************)
IF xMicroRodActive THEN
	(******************************************************************************************************************************************)
	(****************************		                       Cylinder für  ToolLeftActive                                          *****************************)
	(******************************************************************************************************************************************)
	FBCylToolLeftActive(		xCtrlePosOn:= FALSE,
							xCtrlePosOff:= FALSE,
							T_Cylinder:= ptrTCylToolLeftActive^);
	xCylOutToolLeftActive:= FBCylToolLeftActive.xCylinder;
	(* control lamp button for the Cylinder ToolLeft *)
	xCtrlLampToolLeftButton:= FBCylToolLeftActive.xCylinder;
	(******************************************************************************************************************************************)
	(****************************		                       Cylinder für  ToolRightActive                                       *****************************)
	(******************************************************************************************************************************************)
	FBCylToolRightActive(		xCtrlePosOn:= FALSE,
							xCtrlePosOff:= FALSE,
							T_Cylinder:= ptrTCylToolRightActive^);
	xCylOutToolRightActive:= FBCylToolRightActive.xCylinder;
	(* control lamp button for the Cylinder ToolRight*)
	xCtrlLampToolRightButton:= FBCylToolRightActive.xCylinder;
	(******************************************************************************************************************************************)
	(****************************		                       Cylinder für  ToolCenterActive                                       *****************************)
	(******************************************************************************************************************************************)
	FBCylToolCenterActive(	xCtrlePosOn:= FALSE,
							xCtrlePosOff:= FALSE,
							T_Cylinder:= ptrTCylToolCenterActive^);
	xCylOutToolCenterActive:= FBCylToolCenterActive.xCylinder;
	(* control lamp button for the Cylinder ToolCenter *)
	xCtrlLampToolCenterButton:= FBCylToolCenterActive.xCylinder;
	(******************************************************************************************************************************************)
	(****************************		                       Cylinder für  ToolPrismaLeftActive                            *****************************)
	(******************************************************************************************************************************************)
	FBCylToolPrismaLeftActive(	xCtrlePosOn:= FALSE,
								xCtrlePosOff:= FALSE,
								T_Cylinder:= ptrTCylToolPrismaLeftActive^);
	xCylOutToolPrismaLeftActive:= FBCylToolPrismaLeftActive.xCylinder;
	(* control lamp button for the Cylinder ToolPrismaLeft *)
	xCtrlLampToolPrismaLeftButton:= FBCylToolPrismaLeftActive.xCylinder;
	(******************************************************************************************************************************************)
	(****************************		                       Cylinder für  ToolPrismaRightActive                         *****************************)
	(******************************************************************************************************************************************)
	FBCylToolPrismaRightActive(	xCtrlePosOn:= FALSE,
								xCtrlePosOff:= FALSE,
								T_Cylinder:= ptrTCylToolPrismaRightActive^);
	xCylOutToolPrismaRightActive:= FBCylToolPrismaRightActive.xCylinder;
	(* control lamp button for the Cylinder ToolPrismaRight *)
	xCtrlLampToolPrismaRightButton:= FBCylToolPrismaRightActive.xCylinder;
	(************************************************************************************************************************************************************)
	(****************************		              Calculation for the ToolFeederWorkLength                    ***********************************************)
	(************************************************************************************************************************************************************)
	ptrTToolFeederWorkLength^.T_CtrleCyl.T_Analog.rLengthIn:=((rMaxWorkLength/32767) * INT_TO_REAL(iAToolFeederWorkLength)) - rMeasureWorkLengthCorrection;
	(************************************************************************************************************************************************************)
END_IF;
(******************************************************************************************************************************************)
(****************************		                              Reset Control Flags                                                *****************************)
(******************************************************************************************************************************************)
ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=FALSE;
ptrTAxisToolLeft^.T_CtrleSingle.xReset:=FALSE;
ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=FALSE;
ptrTAxisToolCenter^.T_CtrleSingle.xReset:=FALSE;
ptrTAxisToolRight^.T_CtrleSingle.xExecute:=FALSE;
ptrTAxisToolRight^.T_CtrleSingle.xReset:=FALSE;
ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=FALSE;
ptrTAxisToolFeeder^.T_CtrleSingle.xReset:=FALSE;
ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=FALSE;
ptrTAxisGrindFeeder^.T_CtrleSingle.xReset:=FALSE;
ptrTCylToolTension^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolTension^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolLeftActive^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolLeftActive^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolRightActive^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolRightActive^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolCenterActive^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolCenterActive^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolPrismaRightActive^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolPrismaRightActive^.T_CtrleCyl.xExecute:=FALSE;
ptrTToolFeederWorkLength^.T_CtrleCyl.xReset:=FALSE;
ptrTToolFeederWorkLength^.T_CtrleCyl.xExecute:=FALSE;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_HARDWARE_LAYER2' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_HW_GENERAL
VAR
	FBHWHdd: FBHW_HDD;
	FBNovRam: FBHW_NOVRAM;
	FBDeviceId:FBHW_DEVICEID;
	FBBoxId:FBHW_BOXID;
	FBProfileFile: FB_PROFILE_FILE;
	FBControlLamp: FB_CONTROLLAMP;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 11
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBControlLamp
_BOX_EXPR : 6
_OPERAND
_EXPRESSION
_POSITIV
T_StartUp.T_State.xCompleted
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_Visu.T_Message.iState
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_Visu.bActivSpecialLayer
_OPERAND
_EXPRESSION
_POSITIV
T_Station
_OPERAND
_EXPRESSION
_POSITIV
T_Process
_OPERAND
_EXPRESSION
_POSITIV
T_CtrlePanel
_EXPRESSION
_POSITIV
FB_CONTROLLAMP
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[6]
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[5]
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBHWHdd
_BOX_EXPR : 1
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_EXPRESSION
_POSITIV
FBHW_HDD
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_HDD.T_Ctrle.xExecute
_OUTPUT
_POSITIV
_NO_SET
T_HDD.T_Ctrle.xReset
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBNovRam
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_DeviceID.T_NovRAM.udiDeviceID
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam
_EXPRESSION
_POSITIV
FBHW_NOVRAM
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_NovRam.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_NovRam.T_Ctrle.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBDeviceId
_BOX_EXPR : 1
_OPERAND
_EXPRESSION
_POSITIV
T_DeviceID
_EXPRESSION
_POSITIV
FBHW_DEVICEID
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_DeviceID.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_DeviceID.T_Ctrle.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBBoxId
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_DeviceID.T_LightbusMaster.udiDeviceID
_OPERAND
_EXPRESSION
_POSITIV
T_BoxID
_EXPRESSION
_POSITIV
FBHW_BOXID
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_BoxID.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_BoxID.T_Ctrle.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBProfileFile
_BOX_EXPR : 4
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_ProcessImageLoadData
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_ProcessImageData
_OPERAND
_EXPRESSION
_POSITIV
T_Profile
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_EXPRESSION
_POSITIV
FB_PROFILE_FILE
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_Profile.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_Profile.T_Ctrle.xExecute

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_HARDWARE_LAYER2' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_HW_STATION
VAR
	FBHWStation: FBHW_STATION;

(* Ecostep PDO Parameter *)
	TToolLeftRxPdoPara AT %Q*:ST_RX_PDO_PARA;
	TToolLeftTxPdoPara AT %I*:ST_TX_PDO_PARA;
	TToolCenterRxPdoPara AT %Q*:ST_RX_PDO_PARA;
	TToolCenterTxPdoPara AT %I*:ST_TX_PDO_PARA;
	TToolRightRxPdoPara AT %Q*:ST_RX_PDO_PARA;
	TToolRightTxPdoPara AT %I*:ST_TX_PDO_PARA;
	TToolFeederRxPdoPara AT %Q*:ST_RX_PDO_PARA;
	TToolFeederTxPdoPara AT %I*:ST_TX_PDO_PARA;
	TGrindFeederRxPdoPara AT %Q*:ST_RX_PDO_PARA;
	TGrindFeederTxPdoPara AT %I*:ST_TX_PDO_PARA;

(* Beckhoff Axis structure *)
	stToolLeftRefOut AT %Q* :PLCTONC_AXLESTRUCT;
	stToolLeftRefIn AT %I* :NCTOPLC_AXLESTRUCT;
	stToolCenterRefOut AT %Q* :PLCTONC_AXLESTRUCT;
	stToolCenterRefIn AT %I* :NCTOPLC_AXLESTRUCT;
	stToolRightRefOut AT %Q* :PLCTONC_AXLESTRUCT;
	stToolRightRefIn AT %I* :NCTOPLC_AXLESTRUCT;
	stToolFeederRefOut AT %Q* :PLCTONC_AXLESTRUCT;
	stToolFeederRefIn AT %I* :NCTOPLC_AXLESTRUCT;
	stGrindFeederRefOut AT %Q* :PLCTONC_AXLESTRUCT;
	stGrindFeederRefIn AT %I* :NCTOPLC_AXLESTRUCT;

	auiActualAxisTorqueBeckhoff AT %I*:ARRAY [1..5] OF UINT;
	axInputAxisBeckhoff AT %I*: ARRAY[1..5,1..8] OF BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 1
_NETWORK

_COMMENT
'HARDWARE LEVEL-->LAYER 2'
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBHWStation
_BOX_EXPR : 38
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigAxisType
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_ProcessImageData.T_PrismPara.rPrismaFactor
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeOut
_OPERAND
_EXPRESSION
_POSITIV
QarxDigitalOutput[7]
_OPERAND
_EXPRESSION
_POSITIV
QarxDigitalOutput[11]
_OPERAND
_EXPRESSION
_POSITIV
QarxDigitalOutput[15]
_OPERAND
_EXPRESSION
_POSITIV
QarxDigitalOutput[19]
_OPERAND
_EXPRESSION
_POSITIV
QarxDigitalOutput[23]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[5]
_OPERAND
_EXPRESSION
_POSITIV
IariAnalogInput[1]
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_OPERAND
_EXPRESSION
_POSITIV
T_Station
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_ToolTensionSystem
_OPERAND
_EXPRESSION
_POSITIV
TToolLeftRxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolLeftTxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolCenterRxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolCenterTxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolRightRxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolRightTxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolFeederRxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TToolFeederTxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TGrindFeederRxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
TGrindFeederTxPdoPara
_OPERAND
_EXPRESSION
_POSITIV
stToolLeftRefIn
_OPERAND
_EXPRESSION
_POSITIV
stToolLeftRefOut
_OPERAND
_EXPRESSION
_POSITIV
stToolCenterRefIn
_OPERAND
_EXPRESSION
_POSITIV
stToolCenterRefOut
_OPERAND
_EXPRESSION
_POSITIV
stToolRightRefIn
_OPERAND
_EXPRESSION
_POSITIV
stToolRightRefOut
_OPERAND
_EXPRESSION
_POSITIV
stToolFeederRefIn
_OPERAND
_EXPRESSION
_POSITIV
stToolFeederRefOut
_OPERAND
_EXPRESSION
_POSITIV
stGrindFeederRefIn
_OPERAND
_EXPRESSION
_POSITIV
stGrindFeederRefOut
_OPERAND
_EXPRESSION
_POSITIV
auiActualAxisTorqueBeckhoff
_OPERAND
_EXPRESSION
_POSITIV
axInputAxisBeckhoff
_EXPRESSION
_POSITIV
FBHW_STATION
_OUTPUTS : 23
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[12]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[16]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[20]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[24]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[7]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[11]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[15]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[19]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[23]
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[27]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[28]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[29]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[30]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[31]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[32]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[33]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[34]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[35]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[36]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[37]
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[38]
_OUTPUT
_POSITIV
_NO_SET
QariAnalogOutput[1]
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[8]

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ErrorMessage
VAR_INPUT
	diErrorNr : DINT;				(* input of the error number *)
	T_ErrorList:ST_ERROR_LIST;	(* data structure of the errolist *)
END_VAR
VAR_OUTPUT
	sErrorTextEnglish : STRING(100);	(* give the error text in english *)
	sErrorTextDeutsch : STRING(100);	(* give the error text in german *)
	sErrorTextFrancais : STRING(100);	(* give the error text in french *)
END_VAR
VAR
	sTmpText1:STRING(100);
	sTmpText2:STRING(100);
	diTmpErrorNr:DINT;
	ptrErrorList: POINTER TO ST_LANGUAGE_LIST;
	iCounterLanguage: INT;
	sTmpErrorText : STRING(100);
	diTmpDeletePrefix: DINT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                     This Functionblock calculate all errors of the machine an set the follow errornumber                         ************)
(****************************************************************************************************************************************************)
ptrErrorList:=ADR(T_ErrorList.asErrorListEnglish);	(* pointer of the errorlist, default english *)
sErrorTextEnglish:='';
sErrorTextDeutsch:='';
sErrorTextFrancais:='';
sTmpText1:='';
diTmpErrorNr:=0;
diTmpDeletePrefix:=0;
(* detect the error of the hardware, station or process *)
IF (diErrorNr >= 1000000) AND (diErrorNr < 2000000) THEN
	diTmpDeletePrefix:=1000000;
	sTmpText1:='ToolLeft: ';
END_IF;
IF (diErrorNr >= 2000000) AND (diErrorNr < 3000000) THEN
	diTmpDeletePrefix:=2000000;
	sTmpText1:='ToolCenter: ';
END_IF;
IF (diErrorNr >= 3000000) AND (diErrorNr < 4000000) THEN
	diTmpDeletePrefix:=3000000;
	sTmpText1:='ToolRight: ';
END_IF;
IF (diErrorNr >= 4000000) AND (diErrorNr < 5000000) THEN
	diTmpDeletePrefix:=4000000;
	sTmpText1:='ToolFeeder: ';
END_IF;
IF (diErrorNr >= 5000000) AND (diErrorNr < 6000000) THEN
	diTmpDeletePrefix:=5000000;
	sTmpText1:='GrindFeeder: ';
END_IF;
IF (diErrorNr >= 6000000) AND (diErrorNr < 7000000) THEN
	diTmpDeletePrefix:=6000000;
	sTmpText1:='ToolTension: ';
END_IF;
IF (diErrorNr >= 7000000) AND (diErrorNr < 8000000) THEN
	diTmpDeletePrefix:=7000000;
	sTmpText1:='BoxId Err: ';
END_IF;
IF (diErrorNr >= 8000000) AND (diErrorNr < 9000000) THEN
	diTmpDeletePrefix:=8000000;
	sTmpText1:='Station Err: ';
END_IF;

FOR iCounterLanguage:=1 TO 3 DO
	sTmpText2:='';
	sTmpErrorText:='';
	(* set the pointer for the errorlist of the language english, german or french *)
	IF (iCounterLanguage = 1) THEN	ptrErrorList:=ADR(T_ErrorList.asErrorListEnglish); END_IF;
	IF (iCounterLanguage = 2) THEN	ptrErrorList:=ADR(T_ErrorList.asErrorListDeutsch); END_IF;
	IF (iCounterLanguage = 3) THEN	ptrErrorList:=ADR(T_ErrorList.asErrorListFrancais); END_IF;
	IF (diErrorNr >= 0) AND (diErrorNr < 1000000) THEN
		CASE diErrorNr OF
			1:			sTmpText2:=ptrErrorList^.T_LanguagList[52];		(* 'Machine is not referenced' *)
			2:			sTmpText2:=ptrErrorList^.T_LanguagList[57];		(* 'Tool is not clamped' *)
			3:			sTmpText2:=ptrErrorList^.T_LanguagList[58];		(* 'ToolTension is not active' *)
			4:			sTmpText2:=ptrErrorList^.T_LanguagList[59];		(* 'ToolFeeeder is not on the StartPosition' *)
			5:			sTmpText2:=ptrErrorList^.T_LanguagList[63];		(* 'On the MicroWire it is not possible to Referencing' *)
			6:			sTmpText2:=ptrErrorList^.T_LanguagList[65];		(* 'At least one Ecostep CANOpen Controller failed!' *)
			7:			sTmpText2:=ptrErrorList^.T_LanguagList[66];		(* 'No Air Pressure' *)
			16#F201:		sTmpText2:=ptrErrorList^.T_LanguagList[53];		(* 'Settled parameter for ToolLength is to long' *)
			16#F202:		sTmpText2:=ptrErrorList^.T_LanguagList[54];		(* 'Settled parameter for ToolLength is to short' *)
			16#F203:		sTmpText2:=ptrErrorList^.T_LanguagList[55];		(* 'Settled parameter for ToolDiameter is to big' *)
			16#F204:		sTmpText2:=ptrErrorList^.T_LanguagList[56];		(* 'Settled parameter for ToolDiameter is to small' *)
			16#F205:		sTmpText2:=ptrErrorList^.T_LanguagList[62];		(* 'At least a passage of a section is not equal' *)
			16#F206:		sTmpText2:=ptrErrorList^.T_LanguagList[67];		(* 'At least one settled diameter is bigger than ToolDiameter' *)
		ELSE
						sTmpText2:=ptrErrorList^.T_LanguagList[64];		(* 'Undefined Machine Error' *)
		END_CASE;
		sTmpErrorText:=CONCAT(sTmpText1,sTmpText2);
		IF (iCounterLanguage = 1) THEN sErrorTextEnglish:=sTmpErrorText;	END_IF;
		IF (iCounterLanguage = 2) THEN sErrorTextDeutsch:=sTmpErrorText;	END_IF;
		IF (iCounterLanguage = 3) THEN sErrorTextFrancais:=sTmpErrorText;	END_IF;
	ELSE
		IF (diErrorNr >= 1000000) AND (diErrorNr < 6000000) THEN
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			16#F201:		sTmpText2:=ptrErrorList^.T_LanguagList[20];	(* 'Axis function not implemented' *)
			16#F202:		sTmpText2:=ptrErrorList^.T_LanguagList[21];	(* 'No HDD free resource, time out' *)
			16#F203:		sTmpText2:=ptrErrorList^.T_LanguagList[22];	(* 'HDD error, no file found' *)
			16#F204:		sTmpText2:=ptrErrorList^.T_LanguagList[23];	(* 'Axis Parameter File, wrong syntax' *)
			16#F205:		sTmpText2:=ptrErrorList^.T_LanguagList[26];	(* 'PDOMapping Para File, wrong syntax' *)
			16#F206:		sTmpText2:=ptrErrorList^.T_LanguagList[19];	(* 'Axis function time out error' *)
			16#F207:		sTmpText2:=ptrErrorList^.T_LanguagList[28];	(* 'No Axis Power Supply' *)
			16#F208:		sTmpText2:=ptrErrorList^.T_LanguagList[24];	(* 'Wrong Para Fct: Read Axis Parameter' *)
			16#F209:		sTmpText2:=ptrErrorList^.T_LanguagList[27];	(* 'Wrong Para Fct: Read PDOMapping Parameter' *)
			16#F20A:		sTmpText2:=ptrErrorList^.T_LanguagList[29];	(* 'Wrong Para Fct: Move velocity' *)
			16#F20B:		sTmpText2:=ptrErrorList^.T_LanguagList[31];	(* 'Wrong Para Fct: Move position absolute' *)
			16#F20C:		sTmpText2:=ptrErrorList^.T_LanguagList[32];	(* 'Wrong Para Fct: Move position relative' *)
			16#F20D:	sTmpText2:=ptrErrorList^.T_LanguagList[33];	(* 'Wrong Para Fct: Move referencing' *)
			16#F20E:		sTmpText2:=ptrErrorList^.T_LanguagList[35];	(* 'Wrong Para Fct: Send Axis Parameter' *)
			16#F20F:		sTmpText2:=ptrErrorList^.T_LanguagList[36];	(* 'Wrong Para Fct: Send PDOMapping Parameter' *)
			16#F210:		sTmpText2:=ptrErrorList^.T_LanguagList[37];	(* 'Wrong Para Fct: Master/Slave' *)
			16#F211:		sTmpText2:=ptrErrorList^.T_LanguagList[34];	(* 'Fct CalcAnlgeRefIndex:Ref.Sensor not found' *)
			16#F212:		sTmpText2:=ptrErrorList^.T_LanguagList[30];	(* 'Can not move, no power supply' *)
			16#F213:		sTmpText2:=ptrErrorList^.T_LanguagList[25];	(* 'Limit End Switch Active' *)
			16#F214:		sTmpText2:=ptrErrorList^.T_LanguagList[18];	(* 'ADS communication error' *)
			16#F801:		sTmpText2:=ptrErrorList^.T_LanguagList[1];	(* 'Internal problem, should never appear' *)
			16#F802:		sTmpText2:=ptrErrorList^.T_LanguagList[1];	(* 'Internal problem, should never appear' *)
			16#F803:		sTmpText2:=ptrErrorList^.T_LanguagList[2];	(* 'Antivalence error of the motor encoder' *)
			16#F804:		sTmpText2:=ptrErrorList^.T_LanguagList[3];	(* 'Encoder counter error, >+/- 4 inc' *)
			16#F805:		sTmpText2:=ptrErrorList^.T_LanguagList[4];	(* 'Master encoder X7 counter error, >+/- 4 inc' *)
			16#F806:		sTmpText2:=ptrErrorList^.T_LanguagList[5];	(* 'Heat sink temperature to high (>80°)' *)
			16#F807:		sTmpText2:=ptrErrorList^.T_LanguagList[6];	(* 'Low voltage (<18V) of the +24V logic supply' *)
			16#F808:		sTmpText2:=ptrErrorList^.T_LanguagList[7];	(* 'High voltage X10 (>180V) of the motor power supply' *)
			16#F809:		sTmpText2:=ptrErrorList^.T_LanguagList[8];	(* 'Low voltage X10 (<24V) of the motor power supply' *)
			16#F80A:		sTmpText2:=ptrErrorList^.T_LanguagList[9];	(* 'Short circuit in the motor phase A' *)
			16#F80B:		sTmpText2:=ptrErrorList^.T_LanguagList[10];	(* 'Short circuit in the motor phase B' *)
			16#F80C:		sTmpText2:=ptrErrorList^.T_LanguagList[11];	(* 'Short circuit of a digital output' *)
			16#F80D:	sTmpText2:=ptrErrorList^.T_LanguagList[12];	(* 'Digital input ENABLE going to low level' *)
			16#F80E:		sTmpText2:=ptrErrorList^.T_LanguagList[13];	(* 'Exceed max. countouring error ' *)
			16#F80F:		sTmpText2:=ptrErrorList^.T_LanguagList[14];	(* 'Rotation speed to high, can not read encoder signal' *)
			16#F810:		sTmpText2:=ptrErrorList^.T_LanguagList[15];	(* 'Can not find the commutation' *)
			16#F811:		sTmpText2:=ptrErrorList^.T_LanguagList[16];	(* 'CAN-Communication broken by Node Guarding' *)
			16#F812:		sTmpText2:=ptrErrorList^.T_LanguagList[17];	(* 'I^2t- Controlling triggered (current limit)' *)
			ELSE
						sTmpText2:=ptrErrorList^.T_LanguagList[38];	(* 'Axis general error' *)
			END_CASE;
		END_IF;
		IF (diErrorNr >= 6000000) AND (diErrorNr < 7000000) THEN
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			16#F000:		sTmpText2:=ptrErrorList^.T_LanguagList[45];	(* 'Cyl. Function not implemented' *)
			16#F201:		sTmpText2:=ptrErrorList^.T_LanguagList[46];	(* 'Sensor down not active' *)
			16#F202:		sTmpText2:=ptrErrorList^.T_LanguagList[47];	(* 'Sensor up not active' *)
			ELSE
						sTmpText2:=ptrErrorList^.T_LanguagList[48];	(* 'Cyl. general error' *)
			END_CASE;
		END_IF;
		IF (diErrorNr >= 7000000) AND (diErrorNr < 8000000) THEN
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			16#F201:		sTmpText2:=ptrErrorList^.T_LanguagList[39];	(* 'ToolLeft: Wrong configuration or Axis missing' *)
			16#F202:		sTmpText2:=ptrErrorList^.T_LanguagList[40];	(* 'ToolCenter: Wrong configuration or Axis missing' *)
			16#F203:		sTmpText2:=ptrErrorList^.T_LanguagList[41];	(* 'ToolRight: Wrong configuration or Axis missing' *)
			16#F204:		sTmpText2:=ptrErrorList^.T_LanguagList[42];	(* 'ToolFeeder: Wrong configuration or Axis missing' *)
			16#F205:		sTmpText2:=ptrErrorList^.T_LanguagList[43];	(* 'GrindFeeder: Wrong configuration or Axis missing' *)
			ELSE
						sTmpText2:=ptrErrorList^.T_LanguagList[44];	(* 'Cyl. general error' *)
			END_CASE;
		END_IF;
		IF (diErrorNr >= 8000000) AND (diErrorNr < 9000000) THEN
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			1:			sTmpText2:=ptrErrorList^.T_LanguagList[60];	(* At least one Axis is busy *)
			2:			sTmpText2:=ptrErrorList^.T_LanguagList[68];
			ELSE
						sTmpText2:=ptrErrorList^.T_LanguagList[61];	(* Undefined Station error *)
			END_CASE;
		END_IF;
		IF (diErrorNr >= 10000000) AND (diErrorNr < 16000000) THEN
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			16#F000:		sTmpText2:=ptrErrorList^.T_LanguagList[45];	(* 'Cyl. Function not implemented' *)
			16#F201:		sTmpText2:=ptrErrorList^.T_LanguagList[46];	(* 'Sensor down not active' *)
			16#F202:		sTmpText2:=ptrErrorList^.T_LanguagList[47];	(* 'Sensor up not active' *)
			ELSE
						sTmpText2:=ptrErrorList^.T_LanguagList[48];	(* 'Cyl. general error' *)
			END_CASE;
		END_IF;

		sTmpErrorText:=CONCAT(sTmpText1,sTmpText2);
		IF (iCounterLanguage = 1) THEN sErrorTextEnglish:=sTmpErrorText;	END_IF;
		IF (iCounterLanguage = 2) THEN sErrorTextDeutsch:=sTmpErrorText;	END_IF;
		IF (iCounterLanguage = 3) THEN sErrorTextFrancais:=sTmpErrorText;	END_IF;
	END_IF;
END_FOR;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_InitErrorList
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_ErrorList:ST_ERROR_LIST;
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock init all the error text in english, german and french                                       ************)
(****************************************************************************************************************************************************)
(* Static English Error List *)
T_ErrorList.asErrorListEnglish.T_LanguagList[1]:='Internal problem, should never appear';
T_ErrorList.asErrorListEnglish.T_LanguagList[2]:='Antivalence error of the motor encoder';
T_ErrorList.asErrorListEnglish.T_LanguagList[3]:='Encoder counter error, >+/- 4 inc';
T_ErrorList.asErrorListEnglish.T_LanguagList[4]:='Mster encoder X7 counter error, >+/- 4 inc';
T_ErrorList.asErrorListEnglish.T_LanguagList[5]:='Heat sink temperature to high (>80°)';
T_ErrorList.asErrorListEnglish.T_LanguagList[6]:='Low voltage (<18V) of the +24V logic supply';
T_ErrorList.asErrorListEnglish.T_LanguagList[7]:='High voltage X10 (>180V) of the motor power supply';
T_ErrorList.asErrorListEnglish.T_LanguagList[8]:='Low voltage X10 (<24V) of the motor power supply';
T_ErrorList.asErrorListEnglish.T_LanguagList[9]:='Short circuit in the motor phase A';
T_ErrorList.asErrorListEnglish.T_LanguagList[10]:='Short circuit in the motor phase B';
T_ErrorList.asErrorListEnglish.T_LanguagList[11]:='Short circuit of a digital output';
T_ErrorList.asErrorListEnglish.T_LanguagList[12]:='Digital input ENABLE going to low level';
T_ErrorList.asErrorListEnglish.T_LanguagList[13]:='Exceed max. countouring error';
T_ErrorList.asErrorListEnglish.T_LanguagList[14]:='Rotation speed to high, can not read encoder signal';
T_ErrorList.asErrorListEnglish.T_LanguagList[15]:='Can not find the commutation';
T_ErrorList.asErrorListEnglish.T_LanguagList[16]:='CAN-Communication broken by Node Guarding';
T_ErrorList.asErrorListEnglish.T_LanguagList[17]:='I^2t- Controlling triggered (current limit)';
T_ErrorList.asErrorListEnglish.T_LanguagList[18]:='ADS communication error';
T_ErrorList.asErrorListEnglish.T_LanguagList[19]:='Axis function time out error';
T_ErrorList.asErrorListEnglish.T_LanguagList[20]:='Axis function not implemented';
T_ErrorList.asErrorListEnglish.T_LanguagList[21]:='No HDD free resource, time out';
T_ErrorList.asErrorListEnglish.T_LanguagList[22]:='HDD error, no file found';
T_ErrorList.asErrorListEnglish.T_LanguagList[23]:='Axis Parameter File, wrong syntax';
T_ErrorList.asErrorListEnglish.T_LanguagList[24]:='Wrong Para Fct: Read Axis Parameter';
T_ErrorList.asErrorListEnglish.T_LanguagList[25]:='Limit End Switch Active';
T_ErrorList.asErrorListEnglish.T_LanguagList[26]:='PDOMapping Para File, wrong syntax';
T_ErrorList.asErrorListEnglish.T_LanguagList[27]:='Wrong Para Fct: Read PDOMapping Parameter';
T_ErrorList.asErrorListEnglish.T_LanguagList[28]:='No Axis Power Supply';
T_ErrorList.asErrorListEnglish.T_LanguagList[29]:='Wrong Para Fct: Move velocity';
T_ErrorList.asErrorListEnglish.T_LanguagList[30]:='Can not move, no power supply';
T_ErrorList.asErrorListEnglish.T_LanguagList[31]:='Wrong Para Fct: Move position absolute';
T_ErrorList.asErrorListEnglish.T_LanguagList[32]:='Wrong Para Fct: Move position relative';
T_ErrorList.asErrorListEnglish.T_LanguagList[33]:='Wrong Para Fct: Move referencing';
T_ErrorList.asErrorListEnglish.T_LanguagList[34]:='Fct CalcAnlgeRefIndex:Ref.Sensor not found';
T_ErrorList.asErrorListEnglish.T_LanguagList[35]:='Wrong Para Fct: Send Axis Parameter';
T_ErrorList.asErrorListEnglish.T_LanguagList[36]:='Wrong Para Fct: Send PDOMapping Parameter';
T_ErrorList.asErrorListEnglish.T_LanguagList[37]:='Wrong Para Fct: Master/Slave';
T_ErrorList.asErrorListEnglish.T_LanguagList[38]:='Axis general error';
T_ErrorList.asErrorListEnglish.T_LanguagList[39]:='ToolLeft: Wrong configuration or Axis missing';
T_ErrorList.asErrorListEnglish.T_LanguagList[40]:='ToolCenter: Wrong configuration or Axis missing';
T_ErrorList.asErrorListEnglish.T_LanguagList[41]:='ToolRight: Wrong configuration or Axis missing';
T_ErrorList.asErrorListEnglish.T_LanguagList[42]:='ToolFeeder: Wrong configuration or Axis missing';
T_ErrorList.asErrorListEnglish.T_LanguagList[43]:='GrindFeeder: Wrong configuration or Axis missing';
T_ErrorList.asErrorListEnglish.T_LanguagList[44]:='BoxId general error';
T_ErrorList.asErrorListEnglish.T_LanguagList[45]:='Cyl. Function not implemented';
T_ErrorList.asErrorListEnglish.T_LanguagList[46]:='Sensor down not active';
T_ErrorList.asErrorListEnglish.T_LanguagList[47]:='Sensor up not active';
T_ErrorList.asErrorListEnglish.T_LanguagList[48]:='Cyl. general error';
T_ErrorList.asErrorListEnglish.T_LanguagList[49]:='File for profile not found';
T_ErrorList.asErrorListEnglish.T_LanguagList[50]:='Profile file not found: ';
T_ErrorList.asErrorListEnglish.T_LanguagList[51]:='--> Load static default parameter';
T_ErrorList.asErrorListEnglish.T_LanguagList[52]:='Machine is not referenced';
T_ErrorList.asErrorListEnglish.T_LanguagList[53]:='Settled parameter for ToolLength is to long';
T_ErrorList.asErrorListEnglish.T_LanguagList[54]:='Settled parameter for ToolLength is to short';
T_ErrorList.asErrorListEnglish.T_LanguagList[55]:='Settled parameter for ToolDiameter is to big';
T_ErrorList.asErrorListEnglish.T_LanguagList[56]:='Settled parameter for ToolDiameter is to small';
T_ErrorList.asErrorListEnglish.T_LanguagList[57]:='Tool is not clamped';
T_ErrorList.asErrorListEnglish.T_LanguagList[58]:='ToolTension is not active';
T_ErrorList.asErrorListEnglish.T_LanguagList[59]:='ToolFeeeder is not on the StartPosition';
T_ErrorList.asErrorListEnglish.T_LanguagList[60]:='At least one Axis is busy';
T_ErrorList.asErrorListEnglish.T_LanguagList[61]:='Undefined Station error';
T_ErrorList.asErrorListEnglish.T_LanguagList[62]:='At least a passage of a section is not equal';
T_ErrorList.asErrorListEnglish.T_LanguagList[63]:='On the MicroWire it is not possible to Referencing';
T_ErrorList.asErrorListEnglish.T_LanguagList[64]:='Undefined Machine Error';
T_ErrorList.asErrorListEnglish.T_LanguagList[65]:='At least one Ecostep CANOpen Controller failed!';
T_ErrorList.asErrorListEnglish.T_LanguagList[66]:='No Air Pressure';
T_ErrorList.asErrorListEnglish.T_LanguagList[67]:='At least one settled diameter is bigger than ToolDiameter';
T_ErrorList.asErrorListEnglish.T_LanguagList[68]:='ToolTension is active';
T_ErrorList.asErrorListEnglish.T_LanguagList[69]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[70]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[71]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[72]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[73]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[74]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[75]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[76]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[77]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[78]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[79]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[80]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[81]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[82]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[83]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[84]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[85]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[86]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[87]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[88]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[89]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[90]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[91]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[92]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[93]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[94]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[95]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[96]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[97]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[98]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[99]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[100]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[101]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[102]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[103]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[104]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[105]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[106]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[107]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[108]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[109]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[110]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[111]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[112]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[113]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[114]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[115]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[116]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[117]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[118]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[119]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[120]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[121]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[122]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[123]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[124]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[125]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[126]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[127]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[128]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[129]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[130]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[131]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[132]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[133]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[134]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[135]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[136]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[137]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[138]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[139]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[140]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[141]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[142]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[143]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[144]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[145]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[146]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[147]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[148]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[149]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[150]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[151]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[152]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[153]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[154]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[155]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[156]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[157]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[158]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[159]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[160]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[161]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[162]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[163]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[164]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[165]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[166]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[167]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[168]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[169]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[170]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[171]:='';
T_ErrorList.asErrorListEnglish.T_LanguagList[172]:='';

(* Static Deutsch Error List *)
T_ErrorList.asErrorListDeutsch.T_LanguagList[1]:='Interne Ursache, darf niemals auftreten';
T_ErrorList.asErrorListDeutsch.T_LanguagList[2]:='Antivalenzfehler der Motorencodersignale';
T_ErrorList.asErrorListDeutsch.T_LanguagList[3]:='Encoder Zählfehler, >+/- 4 ink';
T_ErrorList.asErrorListDeutsch.T_LanguagList[4]:='Master Encoder X7 Zählfehler, >+/- 4 inc';
T_ErrorList.asErrorListDeutsch.T_LanguagList[5]:='Kühlkörpertemperatur zu hoch (> 80°)';
T_ErrorList.asErrorListDeutsch.T_LanguagList[6]:='Unterspannung (<18V) der +24V Logikversorgung';
T_ErrorList.asErrorListDeutsch.T_LanguagList[7]:='Überspannung X10 (>180V) der Leistungsversorgung';
T_ErrorList.asErrorListDeutsch.T_LanguagList[8]:='Unterspannung X10 (<24V) der Leistungsversorgung';
T_ErrorList.asErrorListDeutsch.T_LanguagList[9]:='Kurzschluss in Motorphase A';
T_ErrorList.asErrorListDeutsch.T_LanguagList[10]:='Kurzschluss in Motorphase B';
T_ErrorList.asErrorListDeutsch.T_LanguagList[11]:='Kurzschluss eines digitalen Ausgangs';
T_ErrorList.asErrorListDeutsch.T_LanguagList[12]:='Digital-Eingang ENABLE wurde auf Low-Pegel gesetzt';
T_ErrorList.asErrorListDeutsch.T_LanguagList[13]:='Max. Schleppfehler überschritten';
T_ErrorList.asErrorListDeutsch.T_LanguagList[14]:='Drehzahl zu hoch, Regler kann Encoder nicht mehr auslesen';
T_ErrorList.asErrorListDeutsch.T_LanguagList[15]:='Kommutierung nicht gefunden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[16]:='CAN-Kommunikation unterbrochen bei Node Guarding';
T_ErrorList.asErrorListDeutsch.T_LanguagList[17]:='I^2t- Überwachung ausgelöst (Stromgrenze)';
T_ErrorList.asErrorListDeutsch.T_LanguagList[18]:='ADS communication error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[19]:='Axis function time out error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[20]:='Axis function not implemented';
T_ErrorList.asErrorListDeutsch.T_LanguagList[21]:='No HDD free resource, time out';
T_ErrorList.asErrorListDeutsch.T_LanguagList[22]:='HDD error, no file found';
T_ErrorList.asErrorListDeutsch.T_LanguagList[23]:='Axis Parameter File, wrong syntax';
T_ErrorList.asErrorListDeutsch.T_LanguagList[24]:='Wrong Para Fct: Read Axis Parameter';
T_ErrorList.asErrorListDeutsch.T_LanguagList[25]:='Limit End Switch Active';
T_ErrorList.asErrorListDeutsch.T_LanguagList[26]:='PDOMapping Para File, wrong syntax';
T_ErrorList.asErrorListDeutsch.T_LanguagList[27]:='Wrong Para Fct: Read PDOMapping Parameter';
T_ErrorList.asErrorListDeutsch.T_LanguagList[28]:='No Axis Power Supply';
T_ErrorList.asErrorListDeutsch.T_LanguagList[29]:='Wrong Para Fct: Move velocity';
T_ErrorList.asErrorListDeutsch.T_LanguagList[30]:='Can not move, no power supply';
T_ErrorList.asErrorListDeutsch.T_LanguagList[31]:='Wrong Para Fct: Move position absolute';
T_ErrorList.asErrorListDeutsch.T_LanguagList[32]:='Wrong Para Fct: Move position relative';
T_ErrorList.asErrorListDeutsch.T_LanguagList[33]:='Wrong Para Fct: Move referencing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[34]:='Fct CalcAnlgeRefIndex:Ref.Sensor not found';
T_ErrorList.asErrorListDeutsch.T_LanguagList[35]:='Wrong Para Fct: Send Axis Parameter';
T_ErrorList.asErrorListDeutsch.T_LanguagList[36]:='Wrong Para Fct: Send PDOMapping Parameter';
T_ErrorList.asErrorListDeutsch.T_LanguagList[37]:='Wrong Para Fct: Master/Slave';
T_ErrorList.asErrorListDeutsch.T_LanguagList[38]:='Axis general error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[39]:='ToolLeft: Wrong configuration or Axis missing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[40]:='ToolCenter: Wrong configuration or Axis missing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[41]:='ToolRight: Wrong configuration or Axis missing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[42]:='ToolFeeder: Wrong configuration or Axis missing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[43]:='GrindFeeder: Wrong configuration or Axis missing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[44]:='BoxId general error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[45]:='Cyl. Function not implemented';
T_ErrorList.asErrorListDeutsch.T_LanguagList[46]:='Sensor down not active';
T_ErrorList.asErrorListDeutsch.T_LanguagList[47]:='Sensor up not active';
T_ErrorList.asErrorListDeutsch.T_LanguagList[48]:='Cyl. general error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[49]:='File for profile not found';
T_ErrorList.asErrorListDeutsch.T_LanguagList[50]:='Profile file not found: ';
T_ErrorList.asErrorListDeutsch.T_LanguagList[51]:='--> Load static default parameter';
T_ErrorList.asErrorListDeutsch.T_LanguagList[52]:='Machine is not referenced';
T_ErrorList.asErrorListDeutsch.T_LanguagList[53]:='Settled parameter for ToolLength is to long';
T_ErrorList.asErrorListDeutsch.T_LanguagList[54]:='Settled parameter for ToolLength is to short';
T_ErrorList.asErrorListDeutsch.T_LanguagList[55]:='Settled parameter for ToolDiameter is to big';
T_ErrorList.asErrorListDeutsch.T_LanguagList[56]:='Settled parameter for ToolDiameter is to small';
T_ErrorList.asErrorListDeutsch.T_LanguagList[57]:='Tool is not clamped';
T_ErrorList.asErrorListDeutsch.T_LanguagList[58]:='ToolTension is not active';
T_ErrorList.asErrorListDeutsch.T_LanguagList[59]:='ToolFeeeder is not on the StartPosition';
T_ErrorList.asErrorListDeutsch.T_LanguagList[60]:='At least one Axis is busy';
T_ErrorList.asErrorListDeutsch.T_LanguagList[61]:='Undefined Station error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[62]:='At least a passage of a section is not equal';
T_ErrorList.asErrorListDeutsch.T_LanguagList[63]:='On the MicroWire it is not possible to Referencing';
T_ErrorList.asErrorListDeutsch.T_LanguagList[64]:='Undefined Machine Error';
T_ErrorList.asErrorListDeutsch.T_LanguagList[65]:='At least one Ecostep CANOpen Controller failed!';
T_ErrorList.asErrorListDeutsch.T_LanguagList[66]:='No Air Pressure';
T_ErrorList.asErrorListDeutsch.T_LanguagList[67]:='At least one settled diameter is bigger than ToolDiameter';
T_ErrorList.asErrorListDeutsch.T_LanguagList[68]:='ToolTension is active';
T_ErrorList.asErrorListDeutsch.T_LanguagList[69]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[70]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[71]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[72]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[73]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[74]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[75]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[76]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[77]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[78]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[79]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[80]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[81]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[82]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[83]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[84]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[85]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[86]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[87]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[88]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[89]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[90]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[91]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[92]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[93]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[94]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[95]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[96]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[97]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[98]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[99]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[100]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[101]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[102]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[103]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[104]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[105]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[106]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[107]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[108]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[109]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[110]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[111]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[112]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[113]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[114]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[115]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[116]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[117]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[118]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[119]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[120]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[121]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[122]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[123]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[124]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[125]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[126]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[127]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[128]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[129]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[130]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[131]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[132]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[133]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[134]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[135]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[136]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[137]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[138]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[139]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[140]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[141]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[142]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[143]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[144]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[145]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[146]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[147]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[148]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[149]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[150]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[151]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[152]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[153]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[154]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[155]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[156]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[157]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[158]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[159]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[160]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[161]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[162]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[163]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[164]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[165]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[166]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[167]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[168]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[169]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[170]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[171]:='';
T_ErrorList.asErrorListDeutsch.T_LanguagList[172]:='';

(* Static Francais Error List *)
T_ErrorList.asErrorListFrancais.T_LanguagList[1]:='Internal problem, should never appear';
T_ErrorList.asErrorListFrancais.T_LanguagList[2]:='Antivalence error of the motor encoder';
T_ErrorList.asErrorListFrancais.T_LanguagList[3]:='Encoder counter error, >+/- 4 inc';
T_ErrorList.asErrorListFrancais.T_LanguagList[4]:='Mster encoder X7 counter error, >+/- 4 inc';
T_ErrorList.asErrorListFrancais.T_LanguagList[5]:='Heat sink temperature to high (>80°)';
T_ErrorList.asErrorListFrancais.T_LanguagList[6]:='Low voltage (<18V) of the +24V logic supply';
T_ErrorList.asErrorListFrancais.T_LanguagList[7]:='High voltage X10 (>180V) of the motor power supply';
T_ErrorList.asErrorListFrancais.T_LanguagList[8]:='Low voltage X10 (<24V) of the motor power supply';
T_ErrorList.asErrorListFrancais.T_LanguagList[9]:='Short circuit in the motor phase A';
T_ErrorList.asErrorListFrancais.T_LanguagList[10]:='Short circuit in the motor phase B';
T_ErrorList.asErrorListFrancais.T_LanguagList[11]:='Short circuit of a digital output';
T_ErrorList.asErrorListFrancais.T_LanguagList[12]:='Digital input ENABLE going to low level';
T_ErrorList.asErrorListFrancais.T_LanguagList[13]:='Exceed max. countouring error ';
T_ErrorList.asErrorListFrancais.T_LanguagList[14]:='Rotation speed to high, can not read encoder signal';
T_ErrorList.asErrorListFrancais.T_LanguagList[15]:='Can not find the commutation';
T_ErrorList.asErrorListFrancais.T_LanguagList[16]:='CAN-Communication broken by Node Guarding';
T_ErrorList.asErrorListFrancais.T_LanguagList[17]:='I^2t- Controlling triggered (current limit)';
T_ErrorList.asErrorListFrancais.T_LanguagList[18]:='ADS communication error';
T_ErrorList.asErrorListFrancais.T_LanguagList[19]:='Axis function time out error';
T_ErrorList.asErrorListFrancais.T_LanguagList[20]:='Axis function not implemented';
T_ErrorList.asErrorListFrancais.T_LanguagList[21]:='No HDD free resource, time out';
T_ErrorList.asErrorListFrancais.T_LanguagList[22]:='HDD error, no file found';
T_ErrorList.asErrorListFrancais.T_LanguagList[23]:='Axis Parameter File, wrong syntax';
T_ErrorList.asErrorListFrancais.T_LanguagList[24]:='Wrong Para Fct: Read Axis Parameter';
T_ErrorList.asErrorListFrancais.T_LanguagList[25]:='Limit End Switch Active';
T_ErrorList.asErrorListFrancais.T_LanguagList[26]:='PDOMapping Para File, wrong syntax';
T_ErrorList.asErrorListFrancais.T_LanguagList[27]:='Wrong Para Fct: Read PDOMapping Parameter';
T_ErrorList.asErrorListFrancais.T_LanguagList[28]:='No Axis Power Supply';
T_ErrorList.asErrorListFrancais.T_LanguagList[29]:='Wrong Para Fct: Move velocity';
T_ErrorList.asErrorListFrancais.T_LanguagList[30]:='Can not move, no power supply';
T_ErrorList.asErrorListFrancais.T_LanguagList[31]:='Wrong Para Fct: Move position absolute';
T_ErrorList.asErrorListFrancais.T_LanguagList[32]:='Wrong Para Fct: Move position relative';
T_ErrorList.asErrorListFrancais.T_LanguagList[33]:='Wrong Para Fct: Move referencing';
T_ErrorList.asErrorListFrancais.T_LanguagList[34]:='Fct CalcAnlgeRefIndex:Ref.Sensor not found';
T_ErrorList.asErrorListFrancais.T_LanguagList[35]:='Wrong Para Fct: Send Axis Parameter';
T_ErrorList.asErrorListFrancais.T_LanguagList[36]:='Wrong Para Fct: Send PDOMapping Parameter';
T_ErrorList.asErrorListFrancais.T_LanguagList[37]:='Wrong Para Fct: Master/Slave';
T_ErrorList.asErrorListFrancais.T_LanguagList[38]:='Axis general error';
T_ErrorList.asErrorListFrancais.T_LanguagList[39]:='ToolLeft: Wrong configuration or Axis missing';
T_ErrorList.asErrorListFrancais.T_LanguagList[40]:='ToolCenter: Wrong configuration or Axis missing';
T_ErrorList.asErrorListFrancais.T_LanguagList[41]:='ToolRight: Wrong configuration or Axis missing';
T_ErrorList.asErrorListFrancais.T_LanguagList[42]:='ToolFeeder: Wrong configuration or Axis missing';
T_ErrorList.asErrorListFrancais.T_LanguagList[43]:='GrindFeeder: Wrong configuration or Axis missing';
T_ErrorList.asErrorListFrancais.T_LanguagList[44]:='BoxId general error';
T_ErrorList.asErrorListFrancais.T_LanguagList[45]:='Cyl. Function not implemented';
T_ErrorList.asErrorListFrancais.T_LanguagList[46]:='Sensor down not active';
T_ErrorList.asErrorListFrancais.T_LanguagList[47]:='Sensor up not active';
T_ErrorList.asErrorListFrancais.T_LanguagList[48]:='Cyl. general error';
T_ErrorList.asErrorListFrancais.T_LanguagList[49]:='File for profile not found';
T_ErrorList.asErrorListFrancais.T_LanguagList[50]:='Profile file not found: ';
T_ErrorList.asErrorListFrancais.T_LanguagList[51]:='--> Load static default parameter';
T_ErrorList.asErrorListFrancais.T_LanguagList[52]:='Machine is not referenced';
T_ErrorList.asErrorListFrancais.T_LanguagList[53]:='Settled parameter for ToolLength is to long';
T_ErrorList.asErrorListFrancais.T_LanguagList[54]:='Settled parameter for ToolLength is to short';
T_ErrorList.asErrorListFrancais.T_LanguagList[55]:='Settled parameter for ToolDiameter is to big';
T_ErrorList.asErrorListFrancais.T_LanguagList[56]:='Settled parameter for ToolDiameter is to small';
T_ErrorList.asErrorListFrancais.T_LanguagList[57]:='Tool is not clamped';
T_ErrorList.asErrorListFrancais.T_LanguagList[58]:='ToolTension is not active';
T_ErrorList.asErrorListFrancais.T_LanguagList[59]:='ToolFeeeder is not on the StartPosition';
T_ErrorList.asErrorListFrancais.T_LanguagList[60]:='At least one Axis is busy';
T_ErrorList.asErrorListFrancais.T_LanguagList[61]:='Undefined Station error';
T_ErrorList.asErrorListFrancais.T_LanguagList[62]:='At least a passage of a section is not equal';
T_ErrorList.asErrorListFrancais.T_LanguagList[63]:='On the MicroWire it is not possible to Referencing';
T_ErrorList.asErrorListFrancais.T_LanguagList[64]:='Undefined Machine Error';
T_ErrorList.asErrorListFrancais.T_LanguagList[65]:='At least one Ecostep CANOpen Controller failed!';
T_ErrorList.asErrorListFrancais.T_LanguagList[66]:='No Air Pressure';
T_ErrorList.asErrorListFrancais.T_LanguagList[67]:='At least one settled diameter is bigger than ToolDiameter';
T_ErrorList.asErrorListFrancais.T_LanguagList[68]:='ToolTension is active';
T_ErrorList.asErrorListFrancais.T_LanguagList[69]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[70]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[71]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[72]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[73]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[74]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[75]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[76]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[77]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[78]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[79]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[80]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[81]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[82]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[83]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[84]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[85]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[86]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[87]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[88]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[89]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[90]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[91]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[92]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[93]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[94]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[95]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[96]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[97]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[98]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[99]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[100]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[101]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[102]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[103]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[104]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[105]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[106]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[107]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[108]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[109]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[110]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[111]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[112]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[113]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[114]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[115]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[116]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[117]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[118]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[119]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[120]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[121]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[122]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[123]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[124]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[125]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[126]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[127]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[128]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[129]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[130]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[131]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[132]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[133]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[134]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[135]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[136]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[137]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[138]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[139]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[140]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[141]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[142]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[143]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[144]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[145]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[146]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[147]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[148]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[149]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[150]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[151]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[152]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[153]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[154]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[155]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[156]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[157]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[158]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[159]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[160]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[161]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[162]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[163]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[164]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[165]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[166]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[167]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[168]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[169]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[170]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[171]:='';
T_ErrorList.asErrorListFrancais.T_LanguagList[172]:='';

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PrcAutoGeometry
VAR_INPUT
	xMicroRodActive: BOOL;				(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;			(* choice of the axis Beckhoff or EcoStep *)
	T_NovRAMData:ST_DATA_RETAIN;	(* Novram structure for all Machine parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;							(* start a process *)
	xStop : BOOL;							(* stop a process *)
	xStopCycle : BOOL;					(* stop a process on the end of the cycle *)
	xQuitErr : BOOL;						(* quit an error *)
	xAbord : BOOL;						(* abord a process *)
	T_Station : ST_STATION;				(* data structure of the stationlevel *)
	T_Process : ST_PROCESS;			(* data strucuture of the processlevel *)
	xReset : BOOL;						(* reset the FB *)
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;	(* data structure of the visualisation *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;							(* Endflag of the process *)
	xError : BOOL;							(* Errorflag of the process *)
	diErrorNr : DINT;						(* Error number of the process *)
END_VAR
VAR
	iStepPrc: INT;
	xInitStep: BOOL;
	xSetError: BOOL;
	xSetEnd: BOOL;
	xStartMainCtr: BOOL;
	xStartMainPrc: BOOL;
	xInitMainCtr: BOOL;
	xFreeze: BOOL;
	xInitError: BOOL;
	iStepError: INT;
	xTmpStop: BOOL;
	xSetTmpError: BOOL;
	xTmpAbord: BOOL;
	diTmpErrNr: DINT;
	xSetEndPrc : BOOL;
	iTmpFunctionNr:INT;
	xStopFctStation1: BOOL;
	iStepStop: INT;
	FBCheckToolGeometryPara: FB_CheckToolGeometryPara;
	iTmpStationFunctionNr: INT;
	xStartProcess: BOOL;
	TONStartTimer: TON;
	tStepTime: TIME;
	TONStartTimer1: TON;
	xDoNotMovePositionOfToolFeeder: BOOL;
	xTmp: BOOL;
	xTmpStopCycle: BOOL;
	xProcessHold: BOOL;
(*08.07.2014: KFS	{	*)
	TONWarmUpBreakTimer: TON;
	TONWarmUpTimer: TON;
	xWarmUpCycle:BOOL;
	xWarmUp:BOOL;
(*08.07.2014: KFS	}	*)
	xWarmUpDone: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                      This Functionblock define the process for the AutoGeometry                                                     ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset THEN
	xReset:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xSetError OR T_Station.TControl.xError) AND NOT(xSetEnd) THEN
	IF NOT(xInitError) THEN
		iStepError:=100;
		xInitError:=TRUE;
		T_Station.TControl.iCountDownPlungeCycle:=1;
		IF NOT(xSetError) THEN
			xSetError:=TRUE;
			xSetTmpError:=FALSE;
		ELSE
			xSetTmpError:=TRUE;
		END_IF;
	END_IF;
	CASE iStepError OF
		100:	IF T_Station.TControl.xError THEN
				diErrorNr:=T_Station.TControl.diErrorNr;
			END_IF;
			IF xSetTmpError THEN
				diErrorNr:=diTmpErrNr;
			END_IF;
			iStepError:=200;
		200:	IF xSetTmpError THEN
				xSetTmpError:=FALSE;
				xStopFctStation1:=FALSE;
				iStepError:=300;
			ELSE
				IF NOT(T_Station.TControl.xError) AND NOT(T_Station.TControl.xEnd) THEN
					IF (T_Station.TControl.iFunctNr = 1) THEN
						T_Station.TControl.xStop:=TRUE;
						xStopFctStation1:=TRUE;
					ELSE
						xStopFctStation1:=FALSE;
					END_IF;
				END_IF;
				iStepError:=300;
			END_IF;
		300:	IF xStopFctStation1 THEN
				IF NOT(T_Station.TControl.xStop) THEN
					xStopFctStation1:=FALSE;
				END_IF;
			END_IF;
			IF NOT(xStopFctStation1) THEN
				xError:=TRUE;
				iStepError:=400;
			END_IF;
		400:	IF xQuitErr THEN
				T_Station.TControl.xQuitError:=T_Station.TControl.xError;
				iStepError:=500;
			END_IF;
		500: IF NOT(T_Station.TControl.xQuitError) THEN
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xSetError) THEN
	IF NOT (xInitMainCtr) THEN
		iStepPrc:=10;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xSetEndPrc:=FALSE;
		iTmpFunctionNr:=1;
		xAbord:=FALSE;
		xProcessHold:=FALSE;
		T_ExchgParam.T_InfoValueCommon.iCountDownCycle:=1;
		xDoNotMovePositionOfToolFeeder:=FALSE;
		T_ExchgParam.T_InfoValueCommon.rActualWireFeedPosition:=0.0;
		T_ExchgParam.T_InfoValueCommon.rActualWireFeedSpeed:=0.0;
		(*08.07.2014: KFS	{	*)
		xWarmUp:= xWarmUpCycle:= T_ExchgParam.T_StationCommon.T_AutoGeometryPara.xWarmUp;
		xWarmUpDone:=FALSE;
		(*08.07.2014: KFS	}	*)
	END_IF;
	IF (xStopCycle AND NOT(xTmpStopCycle)) THEN
		IF (T_NovRAMData.T_ProcessImageData.T_AutoGeometryPara.iCycleGeometry <= 1) THEN
			xStopCycle:=xProcessHold:=FALSE;
			RETURN;
		END_IF;
		IF (iStepPrc = 40) AND NOT(xInitStep) THEN
			xTmpStopCycle:=TRUE;
		END_IF;
	END_IF;
	IF xTmpStopCycle THEN
		xStopCycle:=FALSE;
		xProcessHold:=TRUE;
		xTmpStopCycle:=FALSE;
		xInitStep:=xStartMainPrc:=FALSE;
		(*08.07.2014: KFS	{	*)
		xWarmUp:=FALSE;
		(*08.07.2014: KFS	}	*)
		iStepPrc:=100;
		RETURN;
	END_IF;
	IF xStop AND NOT(xTmpStop) THEN
		xTmpStop:=TRUE;
		iStepStop:=1;
	END_IF;
	IF xTmpStop THEN
		CASE iStepStop OF
		1:	IF NOT(T_Station.TControl.xEnd) THEN
				T_Station.TControl.xStop:=TRUE;
				iStepStop:=10;
			ELSE
				iStepStop:=20;
			END_IF;
		10:	IF NOT(T_Station.TControl.xStop) THEN
				iStepStop:=20;
			END_IF;
		20:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				iStepStop:=30;
			END_IF;
		(* Check Active Movement of the Axis *)
		30:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
				iStepStop:=40;
			END_IF;
		40:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
(*08.07.2014: KFS	{	*)
				IF iStepPrc = 105 THEN
					T_Station.THardware.TCylToolTension.T_CtrleCyl.iFunction:=2;
					T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#1s;
					T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute:=TRUE;
					T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.iFunction:= 1;
					T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xExecute:=TRUE;
					T_Station.THardware.TCylToolRightActive.T_CtrleCyl.iFunction:=1;
					T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xExecute:=TRUE;
					T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.iFunction:=1;
					T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xExecute:=TRUE;
					T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.iFunction:=1;
					T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xExecute:=TRUE;
					T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.iFunction:=1;
					T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xExecute:=TRUE;
					iStepStop:=45;
				ELSE
(*08.07.2014: KFS	}	*)
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=0;
					xSetEnd:=TRUE;
					RETURN;
				END_IF
			END_IF;
		45:IF    (NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone ) AND
		             (NOT(T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xDone )		THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
				RETURN;
			END_IF;
		END_CASE;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
(*08.07.2014: KFS	{	*)
IF xWarmUp AND NOT(xWarmUpDone)THEN
	TONWarmUpTimer(IN:=TRUE,PT:=T#45m);
	IF TONWarmUpTimer.Q THEN
		TONWarmUpTimer(IN:=FALSE);
		xWarmUpDone:=TRUE;
	END_IF;
ELSE
	TONWarmUpTimer(IN:=FALSE);
END_IF;
(*08.07.2014: KFS	}	*)
IF xStartProcess THEN
	TONStartTimer(IN:=TRUE,PT:=T#1s);
	IF TONStartTimer.Q THEN
		TONStartTimer(IN:=FALSE);
		IF (T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft >= T#1s) THEN
			T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft:=T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft - T#1s;
		ELSE
			T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft:=T#0s;
		END_IF;
	END_IF;
	tStepTime:=T_ExchgParam.T_InfoValueCommon.tAutoTimeTotal / 100;
	TONStartTimer1(IN:=TRUE,PT:=tStepTime);
	IF TONStartTimer1.Q THEN
		TONStartTimer1(IN:=FALSE);
		T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGeometry:=T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGeometry + 1;
		IF (T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGeometry >= 100) THEN
			T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGeometry:=100;
		END_IF;
	END_IF;
ELSE
	TONStartTimer(IN:=FALSE);
	TONStartTimer1(IN:=FALSE);
END_IF;
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xSetError) THEN
	CASE iStepPrc OF
		(* Check first if the AutoGeometry is available to start it *)
		10:	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
			(* Only for MicroRod, check if the tool is clamped *)
			IF xMicroRodActive THEN
				(*22.12.2009: KFS	{ *)
				(*Added control if all cylinder for the tool are activated*)
				IF ( T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn AND NOT( xWarmUp) )OR
				    T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.T_Standard.xActivOn OR
 				    T_Station.THardware.TCylToolRightActive.T_CtrleCyl.T_Standard.xActivOn OR
				   (* T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.T_Standard.xActivOn OR*)	(* IGS auskommentiert, diesen Zyl gibts auf der M3 nicht *)
				   ( NOT(T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.T_Standard.xActivOn) AND NOT(xWarmUp)) OR
				   ( NOT(T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.T_Standard.xActivOn) AND NOT(xWarmUp))  	THEN
						xSetError:=TRUE;
						diTmpErrNr:=2;			(* Tool is not clamped *)
				END_IF;
				(*22.12.2009: KFS	} *)
			END_IF;
			(* Only for MicroRod, check if the Machine is referenced *)
			IF xMicroRodActive THEN
				IF NOT(T_Station.TControl.xReferenced) THEN
					xSetError:=TRUE;
					diTmpErrNr:=1;	(* Machine is not referenced *)
					RETURN;
				END_IF;
			END_IF;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=11;
		(* Set the ToolTension force *)
		11:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.iFunction:=2;	(* activate the ToolTension *)
				T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
				IF xMicroRodActive THEN
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#1s;
				ELSE
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#0s;
				END_IF;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone THEN
				(* Only for MicroRod, check if the tool is clamped *)
				IF xMicroRodActive THEN
					IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn AND NOT( xWarmUp) THEN
						xSetError:=TRUE;
						diTmpErrNr:=2;			(* Tool is not clamped *)
						RETURN;
					END_IF;
				END_IF;
				iStepPrc:=20;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Switch First all Axis the power supply on *)
		20:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=16;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=30;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iTmpStationFunctionNr:=6;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.rSetPosition:=0.0;
			END_IF;
		(* Reset the Position of the Axis *)
		30:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* 6=ToolLeft, 7=ToolCenter, 8=ToolRight, 9=ToolFeeder *)
				T_Station.TControl.iFunctNr:=iTmpStationFunctionNr;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				IF NOT(xMicroRodActive) AND (iTmpStationFunctionNr = 7) THEN
					iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				END_IF;
				IF xMicroRodActive AND (iTmpStationFunctionNr = 9) THEN
					iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (iTmpStationFunctionNr < 10) THEN
					iStepPrc:=30;
				ELSE
					iStepPrc:=40;
				END_IF;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		40:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				IF xMicroRodActive THEN
					IF xDoNotMovePositionOfToolFeeder THEN
						iStepPrc:=60;
					ELSE
						iStepPrc:=50;
					END_IF;
				ELSE
					iStepPrc:=60;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Only for MicroRod-->Set ToolFeed Absolut to the Zero Position*)
		50:	IF NOT(xInitStep) THEN
(* 04.04.2011: KFS	{ 	Neu wird die Längeneinstellung des ToolFeeders nicht mehr kontrolliert und direkt auf die StartPos gefahren(vormals RefPos)!
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=14;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=0.0;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
 04.04.2011: KFS	}	*)
				(*30.09.2010: KFS	{ *)
				(* Check first settled geometry parameter *)
				FBCheckToolGeometryPara(	iProcessNr:= 1,
											T_GeometryCommon:= T_ExchgParam.T_GeometryCommon,
											T_AutoGeometryPara:= T_NovRAMData.T_ProcessImageData.T_AutoGeometryPara,
											T_AutoGroovePara:= T_NovRAMData.T_ProcessImageData.T_AutoGroovePara,
											T_ProcessPara:= T_NovRamData.T_ProcessImageData.T_ProcessPara,
											rToolDiameter:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
											xMicroRodActive:=xMicroRodActive,
											(*rOffsetMaxToolLength:= T_Station.THardware.TToolFeederWorkLength.T_CtrleCyl.T_Analog.rLengthIn*));
				IF FBCheckToolGeometryPara.xError THEN
					xSetError:=TRUE;
					diTmpErrNr:=FBCheckToolGeometryPara.diErrorNr;
					RETURN;
				END_IF;
				(*30.09.2010: KFS	} *)
				iStepPrc:=55;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Only for MicroRod-->Set ToolFeed Absolut to the StartPosition and if more cycle than only the first time *)
		55:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=14;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=60;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* ToolRotation Start *)
		60:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=2;
				T_Station.TControl.xStart:=TRUE;
				(* ToolLeft --> Master *)
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
				IF xMicroRodActive THEN
					(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearFactor:=(	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearRatio)) * -1.0;

					(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
		 																			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio);
				END_IF;
				IF NOT(xMicroRodActive) THEN
					(* ToolRight --> Slave of ToolRight by MicroWire *)
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;

					(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;
				END_IF;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=70;
			END_IF;
		(* GrindFeeder Set Absolut to ToolDiameter minus the offset with the fast speed *)
		70:  	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_NovRAMData.T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedForwardFastGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=80;
			END_IF;
		(* Working AutoGeometry *)
		80:	IF NOT(xInitStep) THEN
				xStartProcess:=TRUE;
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=19;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=90;
				RETURN;
			END_IF;
			(* Only for MicroRod, check if the tool is clamped *)
			IF xMicroRodActive THEN
				IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn AND NOT( xWarmUp) THEN
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=81;
					RETURN;
				END_IF;
			END_IF;
			T_ExchgParam.T_InfoValueCommon.iCountDownPlungeCycle:=T_Station.TControl.iCountDownPlungeCycle;
		(* Stop the Process, because the Tool is broken *)
		81:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.xStop:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=82;
			END_IF;
		(* Set the GrindFeeder to the security Position *)
		82:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=83;
			END_IF;
		(* Check Active Movement of the Axis *)
		83:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xSetError:=TRUE;
				diTmpErrNr:=2;			(* Tool is not clamped *)
				RETURN;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		90:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (T_NovRAMData.T_ProcessImageData.T_AutoGeometryPara.iCycleGeometry > T_ExchgParam.T_InfoValueCommon.iCountDownCycle) THEN
					IF NOT(xStopCycle) THEN
						T_ExchgParam.T_InfoValueCommon.iCountDownCycle:=T_ExchgParam.T_InfoValueCommon.iCountDownCycle + 1;
					END_IF;
					xDoNotMovePositionOfToolFeeder:=TRUE;
					iStepPrc:=40;	(* Repeat to work the same Geometry *)
				ELSE
					iStepPrc:=100;
				END_IF;
			END_IF;
		(* ToolRotation Stop *)
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=3;
				T_Station.TControl.xStart:=TRUE;
				(* ToolLeft --> Master *)
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
				IF xMicroRodActive THEN
					(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
				END_IF;
				(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
				IF NOT(xMicroRodActive) THEN
					(* ToolRight --> Slave of ToolRight by MicroWire *)
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				END_IF;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF NOT(xWarmUpCycle) THEN
					iStepPrc:=110;
				ELSE
					iStepPrc:=102;
				END_IF;
			END_IF;
(*08.07.2014: KFS	{	*)
		102:	IF NOT(xInitStep) THEN
				T_Station.THardware.TCylToolTension.T_CtrleCyl.iFunction:=1;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.iFunction:= 2;
				T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolRightActive.T_CtrleCyl.iFunction:=2;
				T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.iFunction:=2;
				T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.iFunction:=51;
				T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.iFunction:=51;
				T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xExecute:=TRUE;
				xInitStep:=TRUE;
			END_IF;
			IF(NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xDone )		THEN
				TONWarmUpBreakTimer(IN:=FALSE);
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=105;
			END_IF;
		105: IF xWarmUpDone THEN
				T_ExchgParam.T_StationCommon.T_AutoGeometryPara.xWarmUp:=FALSE;
			END_IF;
			TONWarmUpBreakTimer(IN:=TRUE,PT:=T#20s);
			IF TONWarmUpBreakTimer.Q THEN
				TONWarmUpBreakTimer(IN:=FALSE);
				T_ExchgParam.T_InfoValueCommon.iCountDownCycle:=1;
				xDoNotMovePositionOfToolFeeder:=FALSE;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=107;
			END_IF;
		107:	IF NOT(xInitStep) THEN
				T_Station.THardware.TCylToolTension.T_CtrleCyl.iFunction:=2;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
				T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#1s;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.iFunction:= 1;
				T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolRightActive.T_CtrleCyl.iFunction:=1;
				T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.iFunction:=1;
				T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.iFunction:=51;
				T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xExecute:=TRUE;
				T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.iFunction:=51;
				T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xExecute:=TRUE;
				xInitStep:=TRUE;
			END_IF;
			IF(NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xDone ) AND
			    (NOT(T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xDone )		THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=10;
			END_IF;
(*08.07.2014: KFS	}	*)
		110:	xSetEndPrc:=FALSE;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=0;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStopCycle:=FALSE;
	xTmpStopCycle:=FALSE;
	xStartMainPrc:=FALSE;
	xTmpStop:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xSetError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	diErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xTmpAbord:=FALSE;
	xSetEndPrc:=FALSE;
	xStartProcess:=FALSE;
(*08.07.2014: KFS	{	*)
	xWarmUp:= xWarmUpCycle:= FALSE;
	xWarmUpDone:=FALSE;
(*08.07.2014: KFS	}	*)
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PrcAutoGroove
VAR_INPUT
	xMicroRodActive: BOOL;				(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;			(* choice of the axis Beckhoff or EcoStep *)
	T_NovRAMData:ST_DATA_RETAIN;	(* Novram structure for all Machine parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;							(* start a process *)
	xStop : BOOL;							(* stop a process *)
	xQuitErr : BOOL;						(* quit an error *)
	xAbord : BOOL;						(* abord a process *)
	T_Station : ST_STATION;				(* data structure of the stationlevel *)
	T_Process : ST_PROCESS;			(* data strucuture of the processlevel *)
	xReset : BOOL;						(* reset the FB *)
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;	(* data structure of the visualisation *)
	xDoNotMoveGrindPosition:BOOL;		(* choice of the AutoGroove process, TRUE=override the GrindAxis position with the ToolDiameter, FALSE=no overriding *)
	xPlungeActive:BOOL;					(* TRUE=Plunge on AutoGroove active, FALSE=Plunge on AutoGroove deactivatet *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;							(* Endflag of the process *)
	xError : BOOL;							(* Errorflag of the process *)
	diErrorNr : DINT;						(* Error number of the process *)
END_VAR
VAR
	iStepPrc: INT;
	xInitStep: BOOL;
	xSetError: BOOL;
	xSetEnd: BOOL;
	xStartMainCtr: BOOL;
	xStartMainPrc: BOOL;
	xInitMainCtr: BOOL;
	xFreeze: BOOL;
	xInitError: BOOL;
	iStepError: INT;
	xTmpStop: BOOL;
	xSetTmpError: BOOL;
	xTmpAbord: BOOL;
	diTmpErrNr: DINT;
	xSetEndPrc : BOOL;
	iTmpFunctionNr:INT;
	xStopFctStation1: BOOL;
	iStepStop: INT;
	FBCheckToolGeometryPara: FB_CheckToolGeometryPara;
	iTmpStationFunctionNr: INT;
	xStartProcess: BOOL;
	TONStartTimer: TON;
	tStepTime: TIME;
	TONStartTimer1: TON;
	rCheckStartPosition: REAL;
	(*22.12.2009: KFS	{ *)
	iNumberOfGrooves: INT;
	lrAxisToolLeftActuelPosition: LREAL;
	rStartPosAutoGrooveToolRotation: LREAL;
	rOffsetStartPositionGrooves: REAL;
	xOneTimeCheckGeometry:BOOL;
	(*22.12.2009: KFS	} *)
	rMaxTol: REAL:= 5.0;
	xNotFirstGrooveCycle: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                      This Functionblock define the process for the AutoGroove                                                         ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset THEN
	xReset:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xSetError OR T_Station.TControl.xError) AND NOT(xSetEnd) THEN
	IF NOT(xInitError) THEN
		iStepError:=100;
		xInitError:=TRUE;
		IF NOT(xSetError) THEN
			xSetError:=TRUE;
			xSetTmpError:=FALSE;
		ELSE
			xSetTmpError:=TRUE;
		END_IF;
	END_IF;
	CASE iStepError OF
		100:	IF T_Station.TControl.xError THEN
				diErrorNr:=T_Station.TControl.diErrorNr;
			END_IF;
			IF xSetTmpError THEN
				diErrorNr:=diTmpErrNr;
			END_IF;
			iStepError:=200;
		200:	IF xSetTmpError THEN
				xSetTmpError:=FALSE;
				xStopFctStation1:=FALSE;
				iStepError:=300;
			ELSE
				IF NOT(T_Station.TControl.xError) AND NOT(T_Station.TControl.xEnd) THEN
					IF (T_Station.TControl.iFunctNr = 1) THEN
						T_Station.TControl.xStop:=TRUE;
						xStopFctStation1:=TRUE;
					ELSE
						xStopFctStation1:=FALSE;
					END_IF;
				END_IF;
				iStepError:=300;
			END_IF;
		300:	IF xStopFctStation1 THEN
				IF NOT(T_Station.TControl.xStop) THEN
					xStopFctStation1:=FALSE;
				END_IF;
			END_IF;
			IF NOT(xStopFctStation1) THEN
				xError:=TRUE;
				iStepError:=400;
			END_IF;
		400:	IF xQuitErr THEN
				T_Station.TControl.xQuitError:=T_Station.TControl.xError;
				iStepError:=500;
			END_IF;
		500: IF NOT(T_Station.TControl.xQuitError) THEN
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xSetError) THEN
	IF NOT (xInitMainCtr) THEN
		iStepPrc:=10;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xSetEndPrc:=FALSE;
		iTmpFunctionNr:=1;
		xAbord:=FALSE;
		T_ExchgParam.T_InfoValueCommon.rActualWireFeedPosition:=0.0;
		T_ExchgParam.T_InfoValueCommon.rActualWireFeedSpeed:=0.0;
		(*22.12.2009: KFS 	{ *)
		T_Station.rStartPosAutoGrooveToolRotation:=0.0;
		rStartPosAutoGrooveToolRotation:=0.0;
		lrAxisToolLeftActuelPosition:=0.0;
		(*22.12.2009: KFS 	} *)
	END_IF;
	IF xStop AND NOT(xTmpStop) THEN
		xTmpStop:=TRUE;
		iStepStop:=1;
	END_IF;
	IF xTmpStop THEN
		CASE iStepStop OF
		1:	IF NOT(T_Station.TControl.xEnd) THEN
				T_Station.TControl.xStop:=TRUE;
				iStepStop:=10;
			ELSE
				iStepStop:=20;
			END_IF;
		10:	IF NOT(T_Station.TControl.xStop) THEN
				iStepStop:=20;
			END_IF;
		20:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				iStepStop:=30;
			END_IF;
		(* Check Active Movement of the Axis *)
		30:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
				iStepStop:=40;
			END_IF;
		40:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
				RETURN;
			END_IF;
		END_CASE;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************		               Controlling of the ToolLeft Position                                   *****************************)
(******************************************************************************************************************************************)
IF  T_Station.THardware.TAxisToolLeft.T_LiveValue.lrActualPositionRelativ <> 0THEN
	IF xMicroRodActive THEN
		lrAxisToolLeftActuelPosition:=T_Station.THardware.TAxisToolLeft.T_LiveValue.lrActualPositionRelativ;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartProcess THEN
	TONStartTimer(IN:=TRUE,PT:=T#1s);
	IF TONStartTimer.Q THEN
		TONStartTimer(IN:=FALSE);
		IF (T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft >= T#1s) THEN
			T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft:=T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft - T#1s;
		ELSE
			T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft:=T#0s;
		END_IF;
	END_IF;
	tStepTime:=T_ExchgParam.T_InfoValueCommon.tAutoTimeTotal / 100;
	TONStartTimer1(IN:=TRUE,PT:=tStepTime);
	IF TONStartTimer1.Q THEN
		TONStartTimer1(IN:=FALSE);
		T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGroove:=T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGroove + 1;
		IF (T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGroove >= 100) THEN
			T_ExchgParam.T_InfoValueCommon.bProgressbarAutoGroove:=100;
		END_IF;
	END_IF;
ELSE
	TONStartTimer(IN:=FALSE);
	TONStartTimer1(IN:=FALSE);
END_IF;
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xSetError) THEN
	CASE iStepPrc OF
		(* Check first if the AutoGroove is available to start it *)
		10:	T_ExchgParam.T_InfoValueCommon.iCountDownGrooveCycle:=1;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
			(* Only for MicroRod, check if the tool is clamped *)
			IF xMicroRodActive THEN
				(*22.12.2009: KFS	{ *)
				(*Added control if all cylinder for the tool are activated*)
				IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn OR
				     T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.T_Standard.xActivOn OR
 				     T_Station.THardware.TCylToolRightActive.T_CtrleCyl.T_Standard.xActivOn  OR
				   (* T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.T_Standard.xActivOn OR*)	(* IGS auskommentiert, diesen Zyl gibts auf der M3 nicht *)
				     NOT(T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.T_Standard.xActivOn) OR
				     NOT(T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.T_Standard.xActivOn) 	THEN
					xSetError:=TRUE;
					diTmpErrNr:=2;			(* Tool is not clamped *)
				END_IF;
				(*22.12.2009: KFS	} *)
			END_IF;
			(* Only for MicroRod, check if the Machine is referenced *)
			IF xMicroRodActive THEN
				IF NOT(T_Station.TControl.xReferenced) THEN
					xSetError:=TRUE;
					diTmpErrNr:=1;	(* Machine is not referenced *)
					RETURN;
				END_IF;
			END_IF;
			(* Only for MicroRod, check if the second procedure of AutoGroove is active if the ToolFeeder is on the StartPos *)
			IF xMicroRodActive THEN
				IF xDoNotMoveGrindPosition THEN
					IF xPlungeActive THEN
						(* less than 1mm is alowed of the position of the ToolFeeder from the StartPosition + the ToolFeed lenght by activated Plunge *)
						rCheckStartPosition:=	ABS((T_NovRAMData.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto +
												T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.rPlungeLengthToolFeedGroove) -
												T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition);
						IF (rCheckStartPosition > 1.0) THEN
							xSetError:=TRUE;
							diTmpErrNr:=4;	(* ToolFeeeder is not on the StartPosition *)
							RETURN;
						END_IF;
					ELSE
						(* less than 1mm is alowed of the position of the ToolFeeder from the StartPosition *)
						IF (ABS(T_NovRAMData.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto - T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition) > 1.0) THEN
							xSetError:=TRUE;
							diTmpErrNr:=4;	(* ToolFeeeder is not on the StartPosition *)
							RETURN;
						END_IF;
					END_IF;
				END_IF;
			END_IF;
			(*22.12.2009: KFS	{ *)
			(* Only for MicroRod, set number of grooves and StartPosAutoGrooveToolRotation *)
			IF xMicroRodActive THEN
				iNumberOfGrooves:= T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.iNumberOfGrooves;
				xNotFirstGrooveCycle:=FALSE;
				IF T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.iNumberOfGrooves >0 THEN
					rOffsetStartPositionGrooves:= 360.0 / T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.iNumberOfGrooves;
				END_IF;
			END_IF;
			(*22.12.2009: KFS	}*)
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=11;
		(* Set the ToolTension force *)
		11:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.iFunction:=2;	(* activate the ToolTension *)
				T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
				IF xMicroRodActive THEN
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#1s;
				ELSE
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#0s;
				END_IF;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone THEN
				(* Only for MicroRod, check if the tool is clamped *)
				IF xMicroRodActive THEN
					IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn THEN
						xSetError:=TRUE;
						diTmpErrNr:=2;			(* Tool is not clamped *)
						RETURN;
					END_IF;
				END_IF;
				iStepPrc:=20;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Switch First all Axis the power supply on *)
		20:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=16;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=30;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iTmpStationFunctionNr:=6;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.rSetPosition:=0.0;
			END_IF;
		(* Reset the Position of the Axis *)
		30:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* 6=ToolLeft, 7=ToolCenter, 8=ToolRight, 9=ToolFeeder *)
				T_Station.TControl.iFunctNr:=iTmpStationFunctionNr;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				IF NOT(xMicroRodActive) AND (iTmpStationFunctionNr = 7) THEN
					iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				END_IF;
				IF xMicroRodActive AND (iTmpStationFunctionNr = 9) THEN
					iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (iTmpStationFunctionNr < 10) THEN
					iStepPrc:=30;
				ELSE
					IF NOT(xDoNotMoveGrindPosition) THEN
						iStepPrc:=40;
					ELSE
						iStepPrc:=70;	(* Start with the working without to adjust the GrindFeeder on the Position of the ToolDiameter *)
					END_IF;
					(*10.09.2010: KFS   { Save StartPos of ToolRotation*)
					rStartPosAutoGrooveToolRotation:=T_Station.THardware.TAxisToolLeft.T_LiveValue.lrActualPositionRelativ;
					(*10.09.2010: KFS	} *)
				END_IF;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		40:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				IF xMicroRodActive THEN
					iStepPrc:=50;
				ELSE
					iStepPrc:=60;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Only for MicroRod-->Set ToolFeed Absolut to the Zero Position*)
		50:	IF NOT(xInitStep) THEN
(* 04.04.2011: KFS	{ 	Neu wird die Längeneinstellung des ToolFeeders nicht mehr kontrolliert und direkt auf die StartPos gefahren(vormals RefPos)!
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=14;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=0.0;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
 04.04.2011: KFS	}	*)
				FBCheckToolGeometryPara(	iProcessNr:= 1,
											T_GeometryCommon:= T_ExchgParam.T_GeometryCommon,
											T_AutoGeometryPara:= T_NovRAMData.T_ProcessImageData.T_AutoGeometryPara,
											T_AutoGroovePara:= T_NovRAMData.T_ProcessImageData.T_AutoGroovePara,
											T_ProcessPara:= T_NovRamData.T_ProcessImageData.T_ProcessPara,
											rToolDiameter:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
											xMicroRodActive:= xMicroRodActive,
											(*rOffsetMaxToolLength:= T_Station.THardware.TToolFeederWorkLength.T_CtrleCyl.T_Analog.rLengthIn*));
				IF FBCheckToolGeometryPara.xError THEN
					xSetError:=TRUE;
					diTmpErrNr:=FBCheckToolGeometryPara.diErrorNr;
					RETURN;
				END_IF;
				iStepPrc:=55;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Only for MicroRod-->Set ToolFeed Absolut to the StartPosition *)
		55:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=14;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=60;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* GrindFeeder Set Absolut to ToolDiameter minus the offset with the fast speed *)
		60:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_NovRAMData.T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedForwardFastGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=70;
			END_IF;
		(* Working AutoGroove *)
		70:	IF NOT(xInitStep) THEN
				xStartProcess:=TRUE;
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=12;
				T_Station.TControl.xStart:=TRUE;
				IF xNotFirstGrooveCycle THEN
					T_ExchgParam.T_InfoValueCommon.iCountDownGrooveCycle:=T_ExchgParam.T_InfoValueCommon.iCountDownGrooveCycle +1;
				ELSE
					xNotFirstGrooveCycle:= TRUE;
				END_IF;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=80;
				RETURN;
			END_IF;
			(* Only for MicroRod, check if the tool is clamped *)
			IF xMicroRodActive THEN
				IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn THEN
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=71;
					RETURN;
				END_IF;
			END_IF;
		(* Stop the Process, because the Tool is broken *)
		71:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.xStop:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=72;
			END_IF;
		(* Set the GrindFeeder to the security Position *)
		72:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=73;
			END_IF;
		(* Check Active Movement of the Axis *)
		73:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xSetError:=TRUE;
				diTmpErrNr:=2;			(* Tool is not clamped *)
				RETURN;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		80:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				(*10.09.2010: KFS   { Set next  rStartPosAutoGrooveToolRotation*)
				rStartPosAutoGrooveToolRotation:=  LMOD ( (rStartPosAutoGrooveToolRotation + rOffsetStartPositionGrooves) , 360);
				(*10.09.2010: KFS   } *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=90;
			END_IF;
		(* ToolRotation Stop *)
		90:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=3;
				T_Station.TControl.xStart:=TRUE;
				(* ToolLeft --> Master *)
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
				IF xMicroRodActive THEN
					(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
				END_IF;
				(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
				IF NOT(xMicroRodActive) THEN
					(* ToolRight --> Slave of ToolRight by MicroWire *)
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				END_IF;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				(*10.09.2010: KFS	{ *)
				(*Calculation of the new T_Station.rStartPosAutoGrooveToolRotation*)
				IF xMicroRodActive THEN
					iNumberOfGrooves:=iNumberOfGrooves - 1;
					IF iNumberOfGrooves > 0 THEN
						IF lrAxisToolLeftActuelPosition < rStartPosAutoGrooveToolRotation THEN
							(* Start ToolRotation --> MoveRelativ to rStartPosAutoGrooveToolRotation *)
							T_Station.rStartPosAutoGrooveToolRotation:= rStartPosAutoGrooveToolRotation - lrAxisToolLeftActuelPosition;
						END_IF;
						IF lrAxisToolLeftActuelPosition = rStartPosAutoGrooveToolRotation THEN
							(* Start ToolRotation --> MoveRelativ to rStartPosAutoGrooveToolRotation *)
							T_Station.rStartPosAutoGrooveToolRotation:= 0.0;
						END_IF;
						IF lrAxisToolLeftActuelPosition > rStartPosAutoGrooveToolRotation THEN
							(* Start ToolRotation --> MoveRelativ to rStartPosAutoGrooveToolRotation *)
							T_Station.rStartPosAutoGrooveToolRotation:= 360.0 - ( lrAxisToolLeftActuelPosition - rStartPosAutoGrooveToolRotation);
						END_IF;
						iStepPrc:=55;
					ELSE
		          			iStepPrc:=100;
					END_IF;
				ELSE
					iStepPrc:=100;
				END_IF;
          			xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				(*10.09.2010: KFS	} *)
			END_IF;
		100:	xSetEndPrc:=FALSE;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=0;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xTmpStop:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xSetError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	diErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xTmpAbord:=FALSE;
	xSetEndPrc:=FALSE;
	xStartProcess:=FALSE;
	xDoNotMoveGrindPosition:=FALSE;
	T_ExchgParam.T_StationCommon.T_AutoGroovePara.xBlockGrindFeeder:=xDoNotMoveGrindPosition;
	iNumberOfGrooves:=1;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PrcMachineReference
VAR_INPUT
	xMicroRodActive: BOOL;				(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;			(* choice of the axis Beckhoff or EcoStep *)
	T_NovRAMData:ST_DATA_RETAIN;	(* Novram structure for all Machine parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;							(* start a process *)
	xStop : BOOL;							(* stop a process *)
	xQuitErr : BOOL;						(* quit an error *)
	xAbord : BOOL;						(* abord a process *)
	T_Station : ST_STATION;				(* data structure of the stationlevel *)
	T_Process : ST_PROCESS;			(* data strucuture of the processlevel *)
	xReset : BOOL;						(* reset the FB *)
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;	(* data structure of the visualisation *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;							(* Endflag of the process *)
	xError : BOOL;							(* Errorflag of the process *)
	diErrorNr : DINT;						(* Error number of the process *)
END_VAR
VAR
	iStepPrc: INT;
	xInitStep: BOOL;
	xSetError: BOOL;
	xSetEnd: BOOL;
	xStartMainCtr: BOOL;
	xStartMainPrc: BOOL;
	xInitMainCtr: BOOL;
	xFreeze: BOOL;
	xInitError: BOOL;
	iStepError: INT;
	xTmpStop: BOOL;
	xSetTmpError: BOOL;
	xTmpAbord: BOOL;
	diTmpErrNr: DINT;
	xSetEndPrc : BOOL;
	iTmpFunctionNr:INT;
	xStopFctStation1: BOOL;
	iStepStop: INT;
	iTmpStationFunctionNr: INT;
	xStartProcess: BOOL;
	TONStartTimer: TON;
	tStepTime: TIME;
	TONStartTimer1: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********   This Functionblock define the process for the Machine referencing-->it is needed only for the MicroRod     ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset THEN
	xReset:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xSetError OR T_Station.TControl.xError) AND NOT(xSetEnd) THEN
	IF NOT(xInitError) THEN
		iStepError:=100;
		xInitError:=TRUE;
		IF NOT(xSetError) THEN
			xSetError:=TRUE;
			xSetTmpError:=FALSE;
		ELSE
			xSetTmpError:=TRUE;
		END_IF;
	END_IF;
	CASE iStepError OF
		100:	IF T_Station.TControl.xError THEN
				diErrorNr:=T_Station.TControl.diErrorNr;
			END_IF;
			IF xSetTmpError THEN
				diErrorNr:=diTmpErrNr;
			END_IF;
			iStepError:=200;
		200:	IF xSetTmpError THEN
				xSetTmpError:=FALSE;
				xStopFctStation1:=FALSE;
				iStepError:=300;
			ELSE
				IF NOT(T_Station.TControl.xError) AND NOT(T_Station.TControl.xEnd) THEN
					IF (T_Station.TControl.iFunctNr = 1) THEN
						T_Station.TControl.xStop:=TRUE;
						xStopFctStation1:=TRUE;
					ELSE
						xStopFctStation1:=FALSE;
					END_IF;
				END_IF;
				iStepError:=300;
			END_IF;
		300:	IF xStopFctStation1 THEN
				IF NOT(T_Station.TControl.xStop) THEN
					xStopFctStation1:=FALSE;
				END_IF;
			END_IF;
			IF NOT(xStopFctStation1) THEN
				xError:=TRUE;
				iStepError:=400;
			END_IF;
		400:	IF xQuitErr THEN
				T_Station.TControl.xQuitError:=T_Station.TControl.xError;
				iStepError:=500;
			END_IF;
		500: IF NOT(T_Station.TControl.xQuitError) THEN
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xSetError) THEN
	IF NOT (xInitMainCtr) THEN
		iStepPrc:=10;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xSetEndPrc:=FALSE;
		iTmpFunctionNr:=1;
		xAbord:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpStop) THEN
		xTmpStop:=TRUE;
		iStepStop:=1;
	END_IF;
	IF xTmpStop THEN
		CASE iStepStop OF
		1:	IF NOT(T_Station.TControl.xEnd) THEN
				T_Station.TControl.xStop:=TRUE;
				iStepStop:=10;
			ELSE
				iStepStop:=20;
			END_IF;
		10:	IF NOT(T_Station.TControl.xStop) THEN
				iStepStop:=20;
			END_IF;
		(* Check Active Movement of the Axis *)
		20:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
				iStepStop:=30;
			END_IF;
		30:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
				RETURN;
			END_IF;
		END_CASE;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xSetError) THEN
	CASE iStepPrc OF
		(* Check first if the ToolCalibration is available to start it *)
		10:	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
			(* On the MicroWire it is not possible to start the Reference Procedure *)
			IF NOT(xMicroRodActive) THEN
				xSetError:=TRUE;
				diTmpErrNr:=5;	(* On the MicroWire it is not possible to Referencing *)
				RETURN;
			END_IF;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=20;
		(* Switch First all Axis the power supply on *)
		20:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=16;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=30;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iTmpStationFunctionNr:=6;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.rSetPosition:=0.0;
			END_IF;
		(* Reset the Position of the Axis *)
		30:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* 6=ToolLeft, 7=ToolCenter, 8=ToolRight, 9=ToolFeeder *)
				T_Station.TControl.iFunctNr:=iTmpStationFunctionNr;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (iTmpStationFunctionNr < 10) THEN
					iStepPrc:=30;
				ELSE
					iStepPrc:=40;
				END_IF;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		40:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=50;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Reference the ToolFeeder *)
		50:	IF NOT(xInitStep) THEN
				xStartProcess:=TRUE;
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=1;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=60;
			END_IF;
		60:	xSetEndPrc:=FALSE;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=0;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xTmpStop:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xSetError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	diErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xTmpAbord:=FALSE;
	xSetEndPrc:=FALSE;
	xStartProcess:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PrcToolCalibration
VAR_INPUT
	xMicroRodActive: BOOL;				(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;			(* choice of the axis Beckhoff or EcoStep *)
	T_NovRAMData:ST_DATA_RETAIN;	(* Novram structure for all Machine parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;							(* start a process *)
	xStop : BOOL;							(* stop a process *)
	xQuitErr : BOOL;						(* quit an error *)
	xAbord : BOOL;						(* abord a process *)
	T_Station : ST_STATION;				(* data structure of the stationlevel *)
	T_Process : ST_PROCESS;			(* data strucuture of the processlevel *)
	xReset : BOOL;						(* reset the FB *)
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;	(* data structure of the visualisation *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;							(* Endflag of the process *)
	xError : BOOL;							(* Errorflag of the process *)
	diErrorNr : DINT;						(* Error number of the process *)
END_VAR
VAR
	iStepPrc: INT;
	xInitStep: BOOL;
	xSetError: BOOL;
	xSetEnd: BOOL;
	xStartMainCtr: BOOL;
	xStartMainPrc: BOOL;
	xInitMainCtr: BOOL;
	xFreeze: BOOL;
	xInitError: BOOL;
	iStepError: INT;
	xTmpStop: BOOL;
	xSetTmpError: BOOL;
	xTmpAbord: BOOL;
	diTmpErrNr: DINT;
	xSetEndPrc : BOOL;
	iTmpFunctionNr:INT;
	xStopFctStation1: BOOL;
	iStepStop: INT;
	iTmpStationFunctionNr: INT;
	xStartProcess: BOOL;
	TONStartTimer: TON;
	tStepTime: TIME;
	TONStartTimer1: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                      This Functionblock define the process for the ToolCalibration                                                  ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset THEN
	xReset:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xSetError OR T_Station.TControl.xError) AND NOT(xSetEnd) THEN
	IF NOT(xInitError) THEN
		iStepError:=100;
		xInitError:=TRUE;
		IF NOT(xSetError) THEN
			xSetError:=TRUE;
			xSetTmpError:=FALSE;
		ELSE
			xSetTmpError:=TRUE;
		END_IF;
	END_IF;
	CASE iStepError OF
		100:	IF T_Station.TControl.xError THEN
				diErrorNr:=T_Station.TControl.diErrorNr;
			END_IF;
			IF xSetTmpError THEN
				diErrorNr:=diTmpErrNr;
			END_IF;
			iStepError:=200;
		200:	IF xSetTmpError THEN
				xSetTmpError:=FALSE;
				xStopFctStation1:=FALSE;
				iStepError:=300;
			ELSE
				IF NOT(T_Station.TControl.xError) AND NOT(T_Station.TControl.xEnd) THEN
					IF (T_Station.TControl.iFunctNr = 1) THEN
						T_Station.TControl.xStop:=TRUE;
						xStopFctStation1:=TRUE;
					ELSE
						xStopFctStation1:=FALSE;
					END_IF;
				END_IF;
				iStepError:=300;
			END_IF;
		300:	IF xStopFctStation1 THEN
				IF NOT(T_Station.TControl.xStop) THEN
					xStopFctStation1:=FALSE;
				END_IF;
			END_IF;
			IF NOT(xStopFctStation1) THEN
				xError:=TRUE;
				iStepError:=400;
			END_IF;
		400:	IF xQuitErr THEN
				T_Station.TControl.xQuitError:=T_Station.TControl.xError;
				iStepError:=500;
			END_IF;
		500: IF NOT(T_Station.TControl.xQuitError) THEN
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xSetError) THEN
	IF NOT (xInitMainCtr) THEN
		iStepPrc:=10;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xSetEndPrc:=FALSE;
		iTmpFunctionNr:=1;
		xAbord:=FALSE;
		T_ExchgParam.T_InfoValueCommon.rActualWireFeedPosition:=0.0;
		T_ExchgParam.T_InfoValueCommon.rActualWireFeedSpeed:=0.0;
	END_IF;
	IF xStop AND NOT(xTmpStop) THEN
		xTmpStop:=TRUE;
		iStepStop:=1;
	END_IF;
	IF xTmpStop THEN
		CASE iStepStop OF
		1:	IF NOT(T_Station.TControl.xEnd) THEN
				T_Station.TControl.xStop:=TRUE;
				iStepStop:=10;
			ELSE
				iStepStop:=20;
			END_IF;
		10:	IF NOT(T_Station.TControl.xStop) THEN
				iStepStop:=20;
			END_IF;
		20:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				iStepStop:=30;
			END_IF;
		(* Check Active Movement of the Axis *)
		30:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
				iStepStop:=40;
			END_IF;
		40:	IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
				RETURN;
			END_IF;
		END_CASE;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartProcess THEN
	TONStartTimer(IN:=TRUE,PT:=T#1s);
	IF TONStartTimer.Q THEN
		TONStartTimer(IN:=FALSE);
		IF (T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft >= T#1s) THEN
			T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft:=T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft - T#1s;
		ELSE
			T_ExchgParam.T_InfoValueCommon.tAutoTimeLeft:=T#0s;
		END_IF;
	END_IF;
	tStepTime:=T_ExchgParam.T_InfoValueCommon.tAutoTimeTotal / 100;
	TONStartTimer1(IN:=TRUE,PT:=tStepTime);
	IF TONStartTimer1.Q THEN
		TONStartTimer1(IN:=FALSE);
		T_ExchgParam.T_InfoValueCommon.bProgressbarToolCalibration:=T_ExchgParam.T_InfoValueCommon.bProgressbarToolCalibration + 1;
		IF (T_ExchgParam.T_InfoValueCommon.bProgressbarToolCalibration >= 100) THEN
			T_ExchgParam.T_InfoValueCommon.bProgressbarToolCalibration:=100;
		END_IF;
	END_IF;
ELSE
	TONStartTimer(IN:=FALSE);
	TONStartTimer1(IN:=FALSE);
END_IF;
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xSetError) THEN
	CASE iStepPrc OF
		(* Check first if the ToolCalibration is available to start it *)
		10:	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
			(* Only for MicroRod, check if the tool is clamped *)
			IF xMicroRodActive THEN
				(*22.12.2009: KFS	{ *)
				(*
				IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn THEN
					xSetError:=TRUE;
					diTmpErrNr:=2;			(* Tool is not clamped *)
				END_IF;
				*)
				(*Added control if all cylinder for the tool are activated*)
				IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn OR
				     T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.T_Standard.xActivOn OR
 				     T_Station.THardware.TCylToolRightActive.T_CtrleCyl.T_Standard.xActivOn  OR
				   (* T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.T_Standard.xActivOn OR*)	(* IGS auskommentiert, diesen Zyl gibts auf der M3 nicht *)
				     NOT(T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.T_Standard.xActivOn) OR
				     NOT(T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.T_Standard.xActivOn) 	THEN
					xSetError:=TRUE;
					diTmpErrNr:=2;			(* Tool is not clamped *)
				END_IF;
				(*22.12.2009: KFS	} *)
			END_IF;
			(* Only for MicroRod, check if the Machine is referenced *)
			IF xMicroRodActive THEN
				IF NOT(T_Station.TControl.xReferenced) THEN
					xSetError:=TRUE;
					diTmpErrNr:=1;	(* Machine is not referenced *)
					RETURN;
				END_IF;
			END_IF;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=11;
		(* Set the ToolTension force *)
		11:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.iFunction:=2;	(* activate the ToolTension *)
				T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
				IF xMicroRodActive THEN
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#1s;
				ELSE
					T_Station.THardware.TCylToolTension.T_Config.tDelayOn:=T#0s;
				END_IF;
				T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
			IF NOT(T_Station.THardware.TCylToolTension.T_CtrleCyl.xExecute) AND T_Station.THardware.TCylToolTension.T_CtrleCyl.xDone THEN
				(* Only for MicroRod, check if the tool is clamped *)
				IF xMicroRodActive THEN
					IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn THEN
						xSetError:=TRUE;
						diTmpErrNr:=2;			(* Tool is not clamped *)
						RETURN;
					END_IF;
				END_IF;
				iStepPrc:=20;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Switch First all Axis the power supply on *)
		20:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=16;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=30;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iTmpStationFunctionNr:=6;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.rSetPosition:=0.0;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.rSetPosition:=0.0;
			END_IF;
		(* Reset the Position of the Axis *)
		30:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* 6=ToolLeft, 7=ToolCenter, 8=ToolRight, 9=ToolFeeder *)
				T_Station.TControl.iFunctNr:=iTmpStationFunctionNr;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				IF NOT(xMicroRodActive) AND (iTmpStationFunctionNr = 7) THEN
					iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				END_IF;
				IF xMicroRodActive AND (iTmpStationFunctionNr = 9) THEN
					iTmpStationFunctionNr:=iTmpStationFunctionNr + 1;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (iTmpStationFunctionNr < 10) THEN
					iStepPrc:=30;
				ELSE
					iStepPrc:=40;
				END_IF;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		40:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				IF xMicroRodActive THEN
					iStepPrc:=50;
				ELSE
					iStepPrc:=60;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Only for MicroRod-->Set ToolFeed Absolut to the StartPosition and if more cycle than only the first time *)
		50:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=14;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=T_NovRAMData.T_ProcessImageData.T_CalibrationPara.rStartPosToolFeedCalib;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				iStepPrc:=60;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* ToolRotation Start *)
		60:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=2;
				T_Station.TControl.xStart:=TRUE;
				(* ToolLeft --> Master *)
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
				IF xMicroRodActive THEN
					(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearFactor:=(	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearRatio)) * -1.0;

					(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio);
				END_IF;

				IF NOT(xMicroRodActive) THEN
					(* ToolRight --> Slave of ToolRight by MicroWire *)
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;

					(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																					(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																					T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;
				END_IF;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=70;
			END_IF;
		(* GrindFeeder Set Absolut to ToolDiameter minus the offset with the fast speed *)
		70:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_NovRAMData.T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedForwardFastGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=80;
			END_IF;
		(* Working ToolCalibration *)
		80:	IF NOT(xInitStep) THEN
				xStartProcess:=TRUE;
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=13;
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=90;
				RETURN;
			END_IF;
			(* Only for MicroRod, check if the tool is clamped *)
			IF xMicroRodActive THEN
				IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn THEN
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=81;
					RETURN;
				END_IF;
			END_IF;
		(* Stop the Process, because the Tool is broken *)
		81:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.xStop:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=82;
			END_IF;
		(* Set the GrindFeeder to the security Position *)
		82:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=83;
			END_IF;
		(* Check Active Movement of the Axis *)
		83:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=18;	(* Check Axis Movement, and stop it if moves *)
				T_Station.TControl.xStart:=TRUE;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xSetError:=TRUE;
				diTmpErrNr:=2;			(* Tool is not clamped *)
				RETURN;
			END_IF;
		(* GrindFeeder Set Absolut to Security Position *)
		90:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=4;
				T_Station.TControl.xStart:=TRUE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rAcceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINGrindFeeder.rDeceleration;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_NovRAMData.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																			T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_NovRAMData.T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=100;
			END_IF;
		(* ToolRotation Stop *)
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station.TControl.iFunctNr:=3;
				T_Station.TControl.xStart:=TRUE;
				(* ToolLeft --> Master *)
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rAcceleration;
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolLeft.rDeceleration;
				IF xMicroRodActive THEN
					(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rAcceleration;
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolCenter.rDeceleration;
				END_IF;
				(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rAcceleration;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolRight.rDeceleration;
				IF NOT(xMicroRodActive) THEN
					(* ToolRight --> Slave of ToolRight by MicroWire *)
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rAcceleration;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAMData.T_Standard.T_TeachINToolFeeder.rDeceleration;
				END_IF;
			END_IF;
			IF NOT(T_Station.TControl.xStart) AND T_Station.TControl.xEnd THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=110;
			END_IF;
		110:	xSetEndPrc:=FALSE;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=0;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xTmpStop:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xSetError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	diErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xTmpAbord:=FALSE;
	xSetEndPrc:=FALSE;
	xStartProcess:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PROCESS
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_Process : ST_PROCESS;				(* data structure of the processlevel *)
	T_Station : ST_STATION;					(* data structure of the stationlevel *)
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;	(* data structure of the visualisation *)
	T_NovRAMData:ST_DATA_RETAIN;		(* data structure of the NovRam *)
END_VAR
VAR_OUTPUT
	xStatusRdy : BOOL := FALSE;				(* state of the processlevel if it is ready or not *)
	xStatusEnd : BOOL := FALSE;				(* state of the processlevel if a process is active or not *)
	xStatusStop : BOOL := FALSE;				(* state of the processlevel if a process will be stopped *)
	xStatusRef : BOOL := FALSE;				(* state of the processlevel if the machine is referenced *)
	xError : BOOL := FALSE;					(* state of the processlevel if the machine has an error *)
	iErrorNr : DINT :=0;							(* state of the processlevel if the machine has an error, in this case it will give the errornumber *)
	iStatusFctNr : INT := 0;						(* state of the processlevel, which process is active *)
END_VAR
VAR
	xStartFunction: BOOL;
	xSetEnd: BOOL;
	iPrcFunctionNr: INT;
	xProcessError: BOOL;
	xInitError: BOOL;
	xTmpStart: BOOL;
	xInitStart: BOOL;
	xInitStop: BOOL;
	xTmpStopFunction: BOOL;
	xDisable: BOOL;
	xResetRef: BOOL;
	xInitStopCycle: BOOL;
	xTmpStopCycleFunction: BOOL;
(* end modif test torque *)
	FBErrorMessage : FB_ErrorMessage;
	FBPrcMachineReference: FB_PrcMachineReference;
	FBPrcAutoGeometry: FB_PrcAutoGeometry;
	diTmpErrorNr: DINT;
	xResetAutoGeometry: BOOL;
	FBPrcAutoGroove: FB_PrcAutoGroove;
	xResetAutoGroove: BOOL;
	FBPrcToolCalibration: FB_PrcToolCalibration;
	xResetToolCalibration: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                            This Functionblock manage all the machine process                                                             ************)
(****************************************************************************************************************************************************)
IF NOT(T_Process.xEnable) THEN
	T_Process.xRdy:=FALSE;
	xDisable:=TRUE;
	RETURN;
ELSE
	IF xDisable THEN
		T_Process.xRdy:=TRUE;
		xDisable:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				                  Status Part                                                            *****************************)
(******************************************************************************************************************************************)
xStatusRdy:=T_Process.xRdy;
xStatusEnd:=T_Process.xEnd;
xStatusRef:=T_Station.TControl.xReferenced;
T_Process.xReferenced:=xStatusRef;
xError:=T_Process.xError;
iStatusFctNr:=iPrcFunctionNr;
(******************************************************************************************************************************************)
(****************************				         Error Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
IF xProcessError OR (T_Process.TFctProcess.xError AND T_Process.xRdy AND NOT(xSetEnd)) THEN
	IF NOT(xInitError) THEN
		xInitError:=TRUE;
		xProcessError:=TRUE;
		T_Process.TFctProcess.xQuitErr:=TRUE;
		T_Process.xProcessHold:=FALSE;
		diTmpErrorNr:=T_Process.TFctProcess.diErrorNr;
	END_IF;
	IF NOT(T_Process.TFctProcess.xQuitErr) AND T_Process.TFctProcess.xEnd AND (T_Process.diErrorNr = 0)THEN
		FBErrorMessage(	diErrorNr:=diTmpErrorNr,
						T_ErrorList:=T_ErrorList);
		T_ExchgParam.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
		T_ExchgParam.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
		T_ExchgParam.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
		T_Process.diErrorNr:=diTmpErrorNr;
		T_Process.xError:=TRUE;
	END_IF;
	IF T_Process.xQuitError AND NOT(T_Process.TFctProcess.xQuitErr) THEN
		T_Process.xProcessHold:=FALSE;
		T_ExchgParam.T_Visu.T_Message.sDynamicTextEnglish:='';
		T_ExchgParam.T_Visu.T_Message.sDynamicTextDeutsch:='';
		T_ExchgParam.T_Visu.T_Message.sDynamicTextFrancais:='';
		xInitError:=FALSE;
		T_Process.xQuitError:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				         Main Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
IF (T_Process.xStart OR xTmpStart) AND T_Process.xRdy AND NOT(xSetEnd) THEN
	IF NOT(xInitStart) THEN
		xInitStart:=TRUE;
		xTmpStart:=TRUE;
		T_Process.xStop:=FALSE;
		T_Process.xStopCycle:=FALSE;
		T_Process.xStart:=FALSE;
		T_Process.xEnd:=FALSE;
		T_Process.xProcessHold:=FALSE;
		T_Process.TFctProcess.xStart:=TRUE;
		xStartFunction:=TRUE;
		iPrcFunctionNr:=T_Process.iFunctNr;
	END_IF;
	IF T_Process.xAbord AND (T_Process.xStopCycle OR T_Process.xStop) THEN
		T_Process.xStopCycle:=T_Process.xStop:=FALSE;		(* Prozess ist am abbrechen, diese Flag können nicht mehr berücksichtigt werden *)
	END_IF;
	IF T_Process.xStopCycle THEN
		IF NOT(xInitStopCycle) THEN
			xInitStopCycle:=TRUE;
			T_Process.TFctProcess.xStopCycle:=TRUE;
		END_IF;
		IF NOT(T_Process.TFctProcess.xStopCycle) AND T_Process.TFctProcess.xProcessHold THEN
			xInitStopCycle:=FALSE;
			T_Process.xStopCycle:=FALSE;
			T_Process.xProcessHold:=TRUE;
			xTmpStopCycleFunction:=TRUE;
		END_IF;
		IF NOT(T_Process.TFctProcess.xStopCycle) AND NOT(T_Process.TFctProcess.xProcessHold) THEN
			xInitStopCycle:=FALSE;
			T_Process.xStopCycle:=FALSE;
			T_Process.xProcessHold:=FALSE;
			xTmpStopCycleFunction:=FALSE;
		END_IF;
	END_IF;
	IF T_Process.xStop THEN
		IF NOT(xInitStop) THEN
			xInitStop:=TRUE;
			T_Process.TFctProcess.xStop:=TRUE;
		END_IF;
		IF NOT(T_Process.TFctProcess.xStop) AND T_Process.TFctProcess.xProcessHold THEN
			xInitStop:=FALSE;
			T_Process.xProcessHold:=TRUE;
			T_Process.xStop:=FALSE;
			xTmpStopFunction:=TRUE;
		END_IF;
		IF NOT(T_Process.TFctProcess.xStop) AND NOT(T_Process.TFctProcess.xProcessHold) THEN
			xInitStop:=FALSE;
			T_Process.xStop:=FALSE;
			T_Process.xProcessHold:=FALSE;
			xTmpStopFunction:=FALSE;
		END_IF;
	END_IF;
	IF T_Process.xStart AND (xTmpStopFunction OR xTmpStopCycleFunction) AND NOT(T_Process.xAbord) THEN
		T_Process.xStart:=T_Process.xProcessHold:=FALSE;
		xTmpStopFunction:=FALSE;
		xTmpStopCycleFunction:=FALSE;
		T_Process.TFctProcess.xStart:=TRUE;
	END_IF;
	IF T_Process.xAbord AND (xTmpStopFunction OR xTmpStopCycleFunction) THEN
		T_Process.xProcessHold:=FALSE;
		T_Process.xStart:=FALSE;
		xTmpStopFunction:=FALSE;
		xTmpStopCycleFunction:=FALSE;
		T_Process.TFctProcess.xAbord:=TRUE;
	END_IF;
	IF NOT(T_Process.TFctProcess.xStart) AND T_Process.TFctProcess.xEnd AND NOT(xProcessError) THEN
		xTmpStart:=FALSE;
		xInitStart:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Funktionen                                                               *****************************)
(******************************************************************************************************************************************)
IF xStartFunction AND NOT(xSetEnd) THEN
	IF (iPrcFunctionNr = 10) THEN
	(* Process AutoGeometry *)
		FBPrcAutoGeometry(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
							xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
							xStart:=T_Process.TFctProcess.xStart ,
							xStop:=T_Process.TFctProcess.xStop ,
							xStopCycle:=T_Process.TFctProcess.xStopCycle,
							xQuitErr:=T_Process.TFctProcess.xQuitErr ,
							xAbord:=T_Process.TFctProcess.xAbord ,
							T_Station:= T_Station,
							T_Process:= T_Process,
							xReset:= xResetAutoGeometry,
							T_ExchgParam:= T_ExchgParam,
							T_NovRAMData:=T_NovRAMData,
							xEnd=>T_Process.TFctProcess.xEnd ,
							xError=>T_Process.TFctProcess.xError ,
							diErrorNr=>T_Process.TFctProcess.diErrorNr);
	END_IF;
	IF (iPrcFunctionNr = 20) THEN
	(* Process AutoGroove *)
		FBPrcAutoGroove(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
							xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
							xStart:=T_Process.TFctProcess.xStart ,
							xStop:=T_Process.TFctProcess.xStop ,
							xQuitErr:=T_Process.TFctProcess.xQuitErr ,
							xAbord:=T_Process.TFctProcess.xAbord ,
							T_Station:= T_Station,
							T_Process:= T_Process,
							xReset:= xResetAutoGroove,
							T_ExchgParam:= T_ExchgParam,
							xDoNotMoveGrindPosition:=T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder,
							xPlungeActive:=T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove,
							T_NovRAMData:=T_NovRAMData,
							xEnd=>T_Process.TFctProcess.xEnd ,
							xError=>T_Process.TFctProcess.xError ,
							diErrorNr=>T_Process.TFctProcess.diErrorNr);
	END_IF;
	IF (iPrcFunctionNr = 30) THEN
	(* Process Machine Reference *)
		FBPrcMachineReference(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
								xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
								xStart:=T_Process.TFctProcess.xStart ,
								xStop:=T_Process.TFctProcess.xStop ,
								xQuitErr:=T_Process.TFctProcess.xQuitErr ,
								xAbord:=T_Process.TFctProcess.xAbord ,
								T_Station:= T_Station,
								T_Process:= T_Process,
								xReset:= xResetRef,
								T_ExchgParam:= T_ExchgParam,
								T_NovRAMData:=T_NovRAMData,
								xEnd=>T_Process.TFctProcess.xEnd ,
								xError=>T_Process.TFctProcess.xError ,
								diErrorNr=>T_Process.TFctProcess.diErrorNr);
	END_IF;
	IF (iPrcFunctionNr = 40) THEN
	(* Process ToolCalibration *)
		FBPrcToolCalibration(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
							xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
							xStart:=T_Process.TFctProcess.xStart ,
							xStop:=T_Process.TFctProcess.xStop ,
							xQuitErr:=T_Process.TFctProcess.xQuitErr ,
							xAbord:=T_Process.TFctProcess.xAbord ,
							T_Station:= T_Station,
							T_Process:= T_Process,
							xReset:= xResetAutoGeometry,
							T_ExchgParam:= T_ExchgParam,
							T_NovRAMData:=T_NovRAMData,
							xEnd=>T_Process.TFctProcess.xEnd ,
							xError=>T_Process.TFctProcess.xError ,
							diErrorNr=>T_Process.TFctProcess.diErrorNr);
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				         Init / Reset Hardware                                                 *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xStartFunction:=FALSE;
	xProcessError:=FALSE;
	xInitError:=FALSE;
	xInitStart:=FALSE;
	xInitStop:=FALSE;
	xSetEnd:=FALSE;
	xTmpStart:=FALSE;
	T_Process.xEnd:=TRUE;
	T_Process.xStart:=FALSE;
	T_Process.xStop:=FALSE;
	T_Process.xError:=FALSE;
	T_Process.diErrorNr:=0;
	T_Process.xAbord:=FALSE;
	T_Process.xQuitError:=FALSE;
	T_Process.wStatus:=0;
	T_Process.xAbord:=FALSE;
	T_Process.xStopCycle:=FALSE;
	T_Process.xProcessHold:=FALSE;
	xResetRef:=TRUE;
	FBPrcMachineReference(	xStart:=T_Process.TFctProcess.xStart ,
							xStop:=T_Process.TFctProcess.xStop ,
							xQuitErr:=T_Process.TFctProcess.xQuitErr ,
							xAbord:=T_Process.TFctProcess.xAbord ,
							T_Station:= T_Station,
							T_Process:= T_Process,
							xReset:= xResetRef,
							T_ExchgParam:= T_ExchgParam,
							xEnd=>T_Process.TFctProcess.xEnd ,
							xError=>T_Process.TFctProcess.xError ,
							diErrorNr=>T_Process.TFctProcess.diErrorNr);
	xResetAutoGeometry:=TRUE;
	FBPrcAutoGeometry(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
						xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
						xStart:=T_Process.TFctProcess.xStart ,
						xStop:=T_Process.TFctProcess.xStop ,
						xStopCycle:=T_Process.TFctProcess.xStopCycle,
						xQuitErr:=T_Process.TFctProcess.xQuitErr ,
						xAbord:=T_Process.TFctProcess.xAbord ,
						T_Station:= T_Station,
						T_Process:= T_Process,
						xReset:= xResetAutoGeometry,
						T_ExchgParam:= T_ExchgParam,
						T_NovRAMData:=T_NovRAMData,
						xEnd=>T_Process.TFctProcess.xEnd ,
						xError=>T_Process.TFctProcess.xError ,
						diErrorNr=>T_Process.TFctProcess.diErrorNr);
	xResetAutoGroove:=TRUE;
	FBPrcAutoGroove(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
						xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
						xStart:=T_Process.TFctProcess.xStart ,
						xStop:=T_Process.TFctProcess.xStop ,
						xQuitErr:=T_Process.TFctProcess.xQuitErr ,
						xAbord:=T_Process.TFctProcess.xAbord ,
						T_Station:= T_Station,
						T_Process:= T_Process,
						xReset:= xResetAutoGroove,
						T_ExchgParam:= T_ExchgParam,
						xDoNotMoveGrindPosition:=T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder,
						xPlungeActive:=T_NovRAMData.T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove,
						T_NovRAMData:=T_NovRAMData,
						xEnd=>T_Process.TFctProcess.xEnd ,
						xError=>T_Process.TFctProcess.xError ,
						diErrorNr=>T_Process.TFctProcess.diErrorNr);
	xResetToolCalibration:=TRUE;
	FBPrcToolCalibration(	xMicroRodActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigMachineType = 2),
						xBeckhoffDriveActive:=(T_NovRAMData.T_Standard.T_MachineConfig.iConfigAxisType = 2),
						xStart:=T_Process.TFctProcess.xStart ,
						xStop:=T_Process.TFctProcess.xStop ,
						xQuitErr:=T_Process.TFctProcess.xQuitErr ,
						xAbord:=T_Process.TFctProcess.xAbord ,
						T_Station:= T_Station,
						T_Process:= T_Process,
						xReset:= xResetToolCalibration,
						T_ExchgParam:= T_ExchgParam,
						T_NovRAMData:=T_NovRAMData,
						xEnd=>T_Process.TFctProcess.xEnd ,
						xError=>T_Process.TFctProcess.xError ,
						diErrorNr=>T_Process.TFctProcess.diErrorNr);
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4\/FB_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Fct_ConvertDateToString : STRING
VAR_INPUT
		iFormat:INT;	(* 0=Langes Date-Time Format; 1=Kurzes Date-Time Format; 2=Sehr Kurzes Date-Time Format *)
					(* 0='28.March 2007  08:47:01' *)
					(* 1='28.03.07 08:47' *)
					(* 2='28.03 08:47' *)
		TProcTimeStart:TIMESTRUCT;
END_VAR
VAR
	sTmpData:STRING(255);
	sTmpData1:STRING(255);
	wYear: WORD;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                This Functionblock formate a Date and Time String DD:MM HH:MM:SS                                     ************)
(****************************************************************************************************************************************************)
sTmpData:=sTmpData1:='';
IF (iFormat < 0) OR (iFormat > 2) THEN
	sTmpData1:='Wrong Date';
	Fct_ConvertDateToString:=sTmpData1;
	RETURN;
END_IF;
IF (TProcTimeStart.wDay <> 0) THEN
	IF (TProcTimeStart.wDay >= 0) AND (TProcTimeStart.wDay <= 9) THEN
		sTmpData1:=MUX(TProcTimeStart.wDay,'00','01','02','03','04','05','06','07','08','09');
		sTmpData:=CONCAT(sTmpData,sTmpData1);
	ELSE
		sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wDay));
	END_IF;
	sTmpData:=CONCAT(sTmpData,'.');
ELSE
	sTmpData1:='Wrong Date';
	Fct_ConvertDateToString:=sTmpData1;
	RETURN;
END_IF;
IF (TProcTimeStart.wMonth <> 0) THEN
	IF (iFormat = 0) THEN
		sTmpData1:=MUX(TProcTimeStart.wMonth-1,'January','February','March','April','May','June','July','August','September','October','November','December');
	END_IF;
	IF (iFormat = 1) OR (iFormat = 2) THEN
		sTmpData1:=MUX(TProcTimeStart.wMonth-1,'01','02','03','04','05','06','07','08','09','10','11','12');
	END_IF;
ELSE
	sTmpData1:='Wrong Date';
	Fct_ConvertDateToString:=sTmpData1;
	RETURN;
END_IF;
sTmpData:=CONCAT(sTmpData,sTmpData1);
IF (iFormat = 0) THEN
	sTmpData:=CONCAT(sTmpData,' ');
END_IF;
IF (iFormat = 1) THEN
	sTmpData:=CONCAT(sTmpData,'.');
END_IF;
IF (iFormat = 2) THEN
	sTmpData:=CONCAT(sTmpData,' ');
END_IF;
IF (iFormat = 0) OR (iFormat = 1) THEN
	IF (TProcTimeStart.wYear <> 0) THEN
		IF (iFormat = 0) THEN
			sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wYear));
			sTmpData:=CONCAT(sTmpData,'  ');
		END_IF;
		IF (iFormat = 1) THEN
			IF (TProcTimeStart.wYear >= 1000) AND (TProcTimeStart.wYear < 2000) THEN
				wYear:=TProcTimeStart.wYear - 1000;
			END_IF;
			IF (TProcTimeStart.wYear >= 2000) AND (TProcTimeStart.wYear < 3000) THEN
				wYear:=TProcTimeStart.wYear - 2000;
			END_IF;
			IF (wYear >= 0) AND (wYear < 10) THEN
				sTmpData1:=MUX(wYear,'00','01','02','03','04','05','06','07','08','09');
				sTmpData:=CONCAT(sTmpData,sTmpData1);
			ELSE
				sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(wYear));
			END_IF;
			sTmpData:=CONCAT(sTmpData,' ');
		END_IF;
	ELSE
		sTmpData1:='Wrong Date';
		Fct_ConvertDateToString:=sTmpData1;
		RETURN;
	END_IF;
END_IF;
IF (TProcTimeStart.wHour >= 0) AND (TProcTimeStart.wHour <= 9) THEN
	sTmpData1:=MUX(TProcTimeStart.wHour,'00','01','02','03','04','05','06','07','08','09');
	sTmpData:=CONCAT(sTmpData,sTmpData1);
ELSE
	sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wHour));
END_IF;
sTmpData:=CONCAT(sTmpData,':');
IF (TProcTimeStart.wMinute >= 0) AND (TProcTimeStart.wMinute <= 9) THEN
	sTmpData1:=MUX(TProcTimeStart.wMinute,'00','01','02','03','04','05','06','07','08','09');
	sTmpData:=CONCAT(sTmpData,sTmpData1);
ELSE
	sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wMinute));
END_IF;
IF (iFormat = 0) THEN
	sTmpData:=CONCAT(sTmpData,':');
	IF (TProcTimeStart.wSecond >= 0) AND (TProcTimeStart.wSecond <= 9) THEN
		sTmpData1:=MUX(TProcTimeStart.wSecond,'00','01','02','03','04','05','06','07','08','09');
		sTmpData:=CONCAT(sTmpData,sTmpData1);
	ELSE
		sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wSecond));
	END_IF;
END_IF;
Fct_ConvertDateToString:=sTmpData;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_PROCESS_LAYER4' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_PROCESS
VAR
	FBProcess: FB_PROCESS;
	xReady: BOOL;
	xEnd: BOOL;
	xStop: BOOL;
	xReferenced: BOOL;
	xError: BOOL;
	iErrorNr: DINT;
	iFunctionNr: INT;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 1
_NETWORK

_COMMENT
'PROCESS LEVEL-->LAYER 4'
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBProcess
_BOX_EXPR : 4
_OPERAND
_EXPRESSION
_POSITIV
T_Process
_OPERAND
_EXPRESSION
_POSITIV
T_Station
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data
_EXPRESSION
_POSITIV
FB_PROCESS
_OUTPUTS : 6
_OUTPUT
_POSITIV
_NO_SET
xEnd
_OUTPUT
_POSITIV
_NO_SET
xStop
_OUTPUT
_POSITIV
_NO_SET
xReferenced
_OUTPUT
_POSITIV
_NO_SET
xError
_OUTPUT
_POSITIV
_NO_SET
iErrorNr
_OUTPUT
_POSITIV
_NO_SET
iFunctionNr
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xReady

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctGrindFeedAbsRelPosition
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	iFunctionNr:INT;				(* state of the called function number-->4=move axis absolut, 5=move axis relative *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********       This Functionblock define the function for set the GrindFeeder Axis to the relative or absolut position       ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((TAxisGrindFeeder.T_CtrleSingle.xErr) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;
			TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisGrindFeeder.T_CtrleSingle.xDone)THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				IF NOT(TAxisGrindFeeder.T_CtrleSingle.xPower) THEN
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=3;
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF (iFunctionNr = 4) THEN
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				END_IF;
				IF (iFunctionNr = 5) THEN
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
				END_IF;
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctSetAxisPosition
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	iFunctionNr:INT;				(* state of the called function number-->	6=set position of the ToolLeft axis
																	7=set position of the ToolCenter axis
																	8=set position of the ToolRight axis
																	9=set position of the ToolFeeder axis
																	10=set position of the GrindFeeder axis *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	ptrTAxis: POINTER TO ST_AXIS;
	xReadFirstTime: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********       This Functionblock set a position for the ToolLeft,ToolCenter,ToolRight,ToolFeeder or GrindFeeder       ************)
(****************************************************************************************************************************************************)

IF NOT(xReadFirstTime) THEN
	xReadFirstTime:=TRUE;
	ptrTAxis:=ADR(TAxisToolLeft);
END_IF;
(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	ptrTAxis:=ADR(TAxisToolLeft);
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((ptrTAxis^.T_CtrleSingle.xErr) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(ptrTAxis^.T_CtrleSingle.xExecute) THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		IF (iFunctionNr = 6) THEN
			ptrTAxis:=ADR(TAxisToolLeft);
		ELSIF (iFunctionNr = 7) THEN
			ptrTAxis:=ADR(TAxisToolCenter);
		ELSIF (iFunctionNr = 8) THEN
			ptrTAxis:=ADR(TAxisToolRight);
		ELSIF (iFunctionNr = 9) THEN
			ptrTAxis:=ADR(TAxisToolFeeder);
		ELSIF (iFunctionNr = 10) THEN
			ptrTAxis:=ADR(TAxisGrindFeeder);
		ELSE
			ptrTAxis:=ADR(TAxisToolLeft);
		END_IF;
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	IF NOT(ptrTAxis^.T_CtrleSingle.xDone) THEN
				ptrTAxis^.T_CtrleSingle.xReset:=TRUE;
				iTmp:=200;
			END_IF;
			RETURN;
		200:	IF NOT(ptrTAxis^.T_CtrleSingle.xReset) AND ptrTAxis^.T_CtrleSingle.xDone THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(ptrTAxis^.T_CtrleSingle.xDone)THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				ptrTAxis^.T_CtrleSingle.iFunction:=11;
				ptrTAxis^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxis^.T_CtrleSingle.xExecute) AND ptrTAxis^.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctStopAxisMovement
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram data structure for the process parameter *)
	T_Standard:ST_RETAIN_DATA;							(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	xReadFirstTime: BOOL;
	xTmp1: BOOL;
	rToolRotationSpeed: REAL;
	FBToolCalcul:FB_TOOL_CALCUL;
	rToolFeedLength: REAL;
	rToolDiameter: REAL;
	rGrindFeedPlunge: REAL;
	ii: INT;
	iStartSection: INT;
	iEndSection: INT;
	rSpeedGrindFeed: REAL;
	rSpeedToolFeed: REAL;
	rTimeGrindPlunge: REAL;
	FBCalcGearFactor: FB_CALC_GEARFACTOR;
	lrToolFeederActualPosition: LREAL;
	iTmpStartSection: INT;
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING;
	xResetFB: BOOL;
	xGrindFeedMaster: BOOL;
	xCheckToolFeedPosition: BOOL;
	lrToolFeederPosition: LREAL;
	lrToolRightPosition: LREAL;
	lrSaveToolFeederPosition: LREAL;
	lrSaveToolRightPosition: LREAL;
	rPlungeCycleGrindFeedGeometry: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                               This Functionblock check the movement of all axis and stopp all movement                              ************)
(****************************************************************************************************************************************************)

IF NOT(xReadFirstTime) THEN
	xReadFirstTime:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
xTmp:=	TAxisToolLeft.T_CtrleSingle.xErr OR
		(TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
		TAxisToolRight.T_CtrleSingle.xErr OR
		TAxisToolFeeder.T_CtrleSingle.xErr OR
		TAxisGrindFeeder.T_CtrleSingle.xErr;
xTmp1:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		 NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) AND
		NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute);
IF (xHardwareError OR (xTmp AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF xTmp1 THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
		xCheckToolFeedPosition:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	TAxisToolLeft.T_CtrleSingle.iFunction:=5;
			TAxisToolLeft.T_CtrleSingle.xExecute:=NOT(TAxisToolLeft.T_CtrleSingle.xNotMoving);
			IF xMicroRodActive THEN
				TAxisToolCenter.T_CtrleSingle.iFunction:=5;
				TAxisToolCenter.T_CtrleSingle.xExecute:=NOT(TAxisToolCenter.T_CtrleSingle.xNotMoving);
			END_IF;
			TAxisToolRight.T_CtrleSingle.iFunction:=5;
			TAxisToolRight.T_CtrleSingle.xExecute:=NOT(TAxisToolRight.T_CtrleSingle.xNotMoving);
			TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
			TAxisToolFeeder.T_CtrleSingle.xExecute:=NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving);
			TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;
			TAxisGrindFeeder.T_CtrleSingle.xExecute:=NOT(TAxisGrindFeeder.T_CtrleSingle.xNotMoving);
			iTmp:=200;
			RETURN;
		200:	xTmp:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone AND
					((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
					NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND
					NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone;
			IF xTmp THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	IF xMicroRodActive THEN
				IF TAxisToolCenter.T_CtrleSingle.xSlave THEN
					TAxisToolCenter.T_CtrleSingle.iFunction:=25;
					TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF TAxisToolRight.T_CtrleSingle.xSlave THEN
				TAxisToolRight.T_CtrleSingle.iFunction:=25;
				TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF TAxisToolFeeder.T_CtrleSingle.xSlave THEN
				TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF TAxisGrindFeeder.T_CtrleSingle.xSlave THEN
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=25;
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			iTmp:=400;
			RETURN;
		400:	xTmp:=	((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
					NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND
					NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone;
			IF xTmp THEN
				iTmp:=500;
			END_IF;
			RETURN;
		500:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		(* Initial Procedure *)
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolLeft.T_CtrleSingle.iFunction:=5;
				TAxisToolLeft.T_CtrleSingle.xExecute:=NOT(TAxisToolLeft.T_CtrleSingle.xNotMoving);
				IF xMicroRodActive THEN
					TAxisToolCenter.T_CtrleSingle.iFunction:=5;
					TAxisToolCenter.T_CtrleSingle.xExecute:=NOT(TAxisToolCenter.T_CtrleSingle.xNotMoving);
				END_IF;
				TAxisToolRight.T_CtrleSingle.iFunction:=5;
				TAxisToolRight.T_CtrleSingle.xExecute:=NOT(TAxisToolRight.T_CtrleSingle.xNotMoving);
				TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
				TAxisToolFeeder.T_CtrleSingle.xExecute:=NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving);
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=NOT(TAxisGrindFeeder.T_CtrleSingle.xNotMoving);
			END_IF;
			xTmp:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone AND
					((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
					NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND
					NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone;
			IF xTmp THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xMicroRodActive THEN
					IF TAxisToolCenter.T_CtrleSingle.xSlave THEN
						TAxisToolCenter.T_CtrleSingle.iFunction:=25;
						TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF TAxisToolRight.T_CtrleSingle.xSlave THEN
					TAxisToolRight.T_CtrleSingle.iFunction:=25;
					TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF TAxisToolFeeder.T_CtrleSingle.xSlave THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF TAxisGrindFeeder.T_CtrleSingle.xSlave THEN
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=25;
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			xTmp:=	((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
					NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND
					NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone;
			IF xTmp THEN
				(* Procedure is finished *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
	xCheckToolFeedPosition:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctSwitchOnOffPowerSupply
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	iFunctionNr:INT;				(* state of the called function number-->16=switch current on of all axis, 17=switch current off of all axis *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	xTmp1: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***    This Functionblock switch the axis current on or off for the ToolLeft,ToolCenter,ToolRight,ToolFeeder or GrindFeeder     ***)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
xTmp:=	TAxisToolLeft.T_CtrleSingle.xErr OR
		(TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
		TAxisToolRight.T_CtrleSingle.xErr OR
		TAxisToolFeeder.T_CtrleSingle.xErr OR
		TAxisGrindFeeder.T_CtrleSingle.xErr;
xTmp1:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		 NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND
		NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND
		NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute);
IF (xHardwareError OR (xTmp AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF xTmp1 THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	xTmp:=	NOT(TAxisToolLeft.T_CtrleSingle.xDone) OR
					(NOT(TAxisToolCenter.T_CtrleSingle.xDone) AND xMicroRodActive) OR
					NOT(TAxisToolRight.T_CtrleSingle.xDone) OR
					NOT(TAxisToolFeeder.T_CtrleSingle.xDone) OR
					NOT(TAxisGrindFeeder.T_CtrleSingle.xDone);
			IF xTmp THEN
				iTmp:=300;
				RETURN;
			END_IF;
			TAxisToolLeft.T_CtrleSingle.xReset:=NOT(TAxisToolLeft.T_CtrleSingle.xDone);
			TAxisToolCenter.T_CtrleSingle.xReset:=NOT(TAxisToolCenter.T_CtrleSingle.xDone) AND xMicroRodActive;
			TAxisToolRight.T_CtrleSingle.xReset:=NOT(TAxisToolRight.T_CtrleSingle.xDone);
			TAxisToolFeeder.T_CtrleSingle.xReset:=NOT(TAxisToolFeeder.T_CtrleSingle.xDone);
			TAxisGrindFeeder.T_CtrleSingle.xReset:=NOT(TAxisGrindFeeder.T_CtrleSingle.xDone);
			iTmp:=200;
			RETURN;
		200:	xTmp:=	TAxisToolLeft.T_CtrleSingle.xDone AND
					((NOT(TAxisToolCenter.T_CtrleSingle.xDone) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					TAxisToolRight.T_CtrleSingle.xDone AND
					TAxisToolFeeder.T_CtrleSingle.xDone AND
					TAxisGrindFeeder.T_CtrleSingle.xDone;
			IF xTmp THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xTmp:=	NOT(TAxisToolLeft.T_CtrleSingle.xDone) OR
						(NOT(TAxisToolCenter.T_CtrleSingle.xDone) AND xMicroRodActive) OR
						NOT(TAxisToolRight.T_CtrleSingle.xDone) OR
						NOT(TAxisToolFeeder.T_CtrleSingle.xDone) OR
						NOT(TAxisGrindFeeder.T_CtrleSingle.xDone);
				IF xTmp THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				IF (iFunctionNr = 16) THEN
				(* Switch On all Axis *)
					IF NOT(TAxisToolLeft.T_CtrleSingle.xPower) THEN
						TAxisToolLeft.T_CtrleSingle.iFunction:=3;
						TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF xMicroRodActive THEN
						IF NOT(TAxisToolCenter.T_CtrleSingle.xPower) THEN
							TAxisToolCenter.T_CtrleSingle.iFunction:=3;
							TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
						END_IF;
					END_IF;
					IF NOT(TAxisToolRight.T_CtrleSingle.xPower) THEN
						TAxisToolRight.T_CtrleSingle.iFunction:=3;
						TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xPower) THEN
						TAxisToolFeeder.T_CtrleSingle.iFunction:=3;
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(TAxisGrindFeeder.T_CtrleSingle.xPower) THEN
						TAxisGrindFeeder.T_CtrleSingle.iFunction:=3;
						TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF (iFunctionNr = 17) THEN
				(* Switch Off all Axis *)
					IF TAxisToolLeft.T_CtrleSingle.xPower THEN
						TAxisToolLeft.T_CtrleSingle.iFunction:=4;
						TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF xMicroRodActive THEN
						IF TAxisToolCenter.T_CtrleSingle.xPower THEN
							TAxisToolCenter.T_CtrleSingle.iFunction:=4;
							TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
						END_IF;
					END_IF;
					IF TAxisToolRight.T_CtrleSingle.xPower THEN
						TAxisToolRight.T_CtrleSingle.iFunction:=4;
						TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF TAxisToolFeeder.T_CtrleSingle.xPower THEN
						TAxisToolFeeder.T_CtrleSingle.iFunction:=4;
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF TAxisGrindFeeder.T_CtrleSingle.xPower THEN
						TAxisGrindFeeder.T_CtrleSingle.iFunction:=4;
						TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
			    NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND
			    NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolCalibration
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram data structure for the process parameter *)
	T_Standard:ST_RETAIN_DATA;							(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
	T_WorkTool:ST_WORKTOOL;	(* Tool parameter *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
	lrProcessToolFeederActualPosition:LREAL;	(* gives the calculated position of the ToolFeeder *)
	lrProcessToolFeederSpeed:LREAL;			(* gives the calculated speed of the ToolFeeder *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	xReadFirstTime: BOOL;
	xTmp1: BOOL;
	rToolRotationSpeed: REAL;
	FBToolCalcul:FB_TOOL_CALCUL_NEW;
	rToolFeedLength: REAL;
	rToolDiameter: REAL;
	rGrindFeedPlunge: REAL;
	ii: INT;
	iStartSection: INT;
	iEndSection: INT;
	rSpeedGrindFeed: REAL;
	rSpeedToolFeed: REAL;
	rTimeGrindPlunge: REAL;
	FBCalcGearFactor: FB_CALC_GEARFACTOR;
	lrToolFeederActualPosition: LREAL;
	iTmpStartSection: INT;
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING;
	xResetFB: BOOL;
	xGrindFeedMaster: BOOL;
	xCheckToolFeedPosition: BOOL;
	lrToolFeederPosition: LREAL;
	lrToolRightPosition: LREAL;
	lrSaveToolFeederPosition: LREAL;
	lrSaveToolRightPosition: LREAL;
	rPlungeCycleGrindFeedGeometry: REAL;
	lrToolFeedCalcLengthPosition: REAL;
	lrCalcToolLengthInc: LREAL;
	lrCalcToolLength: LREAL;
	rTimeToolFeed: REAL;
	xReadyToolFeedStop: BOOL;
	xReadyGrindFeedStop: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock define the function for the calibration of the tool                                            ************)
(****************************************************************************************************************************************************)

IF NOT(xReadFirstTime) THEN
	xReadFirstTime:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
xTmp:=	TAxisToolLeft.T_CtrleSingle.xErr OR
		(TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
		TAxisToolRight.T_CtrleSingle.xErr OR
		TAxisToolFeeder.T_CtrleSingle.xErr OR
		TAxisGrindFeeder.T_CtrleSingle.xErr;
xTmp1:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		 NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) AND
		NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute);
IF (xHardwareError OR (xTmp AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF xTmp1 THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
		xCheckToolFeedPosition:=FALSE;
		lrCalcToolLengthInc:=lrCalcToolLength:=0.0;
		rSpeedToolFeed:=0.0;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************		               Controlling of the ToolFeeder Position                            *****************************)
(******************************************************************************************************************************************)
IF xCheckToolFeedPosition THEN
	IF xMicroRodActive THEN
		lrToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo - lrSaveToolFeederPosition;
		lrToolFeederActualPosition:=(lrToolFeederPosition / TAxisToolFeeder.T_CtrleSingle.lrScaleFactor);
		lrCalcToolLength:=lrToolFeederActualPosition;
	END_IF;
	IF NOT(xMicroRodActive) AND (TAxisToolRight.T_CtrleSingle.lrGearRatio <> 0.0) THEN
		lrToolFeedCalcLengthPosition:=((((T_WorkTool.rToolLength * 10.0) / ABS(T_WorkTool.rPitch)) * 24000.0) / TAxisToolRight.T_CtrleSingle.lrScaleFactor);
		lrToolFeederPosition:=lrToolFeederPosition + ABS(ABS(TAxisToolRight.T_LiveValue.lrActualPosition) - (lrSaveToolFeederPosition / TAxisToolRight.T_CtrleSingle.lrScaleFactor));
		lrSaveToolFeederPosition:=ABS(TAxisToolRight.T_LiveValue.lrActualPositionNotModulo);
		lrToolFeederActualPosition:=((T_WorkTool.rToolLength * 10.0) / lrToolFeedCalcLengthPosition) * lrToolFeederPosition;
		lrCalcToolLength:=lrCalcToolLengthInc + lrToolFeederActualPosition;
	END_IF;
ELSE
	IF NOT(xMicroRodActive) AND (TAxisToolRight.T_CtrleSingle.lrGearRatio <> 0.0) THEN
		lrSaveToolFeederPosition:=ABS(TAxisToolRight.T_LiveValue.lrActualPositionNotModulo);
		lrSaveToolRightPosition:=TAxisToolRight.T_LiveValue.lrActualPositionNotModulo * TAxisToolRight.T_CtrleSingle.lrGearRatio;
		lrCalcToolLengthInc:=lrCalcToolLength;
	END_IF;
	IF xMicroRodActive THEN
		lrSaveToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo;
	END_IF;
	lrToolFeederActualPosition:=lrToolFeederPosition:=0.0;
END_IF;
lrProcessToolFeederActualPosition:=lrCalcToolLength;
lrProcessToolFeederSpeed:=rSpeedToolFeed;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	xReadyToolFeedStop:=xReadyGrindFeedStop:=FALSE;
			TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
			TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
			TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
			TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				iTmp:=300;
			END_IF;
			RETURN;
		300:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone AND NOT(xReadyGrindFeedStop) THEN
				xReadyGrindFeedStop:=TRUE;
			END_IF;
			IF (TAxisGrindFeeder.T_LiveValue.lrActualPosition >= (T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess)) AND NOT(xReadyToolFeedStop) THEN
				xReadyToolFeedStop:=TRUE;
				xCheckToolFeedPosition:=FALSE;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					FBCalcGearFactor(	rSpeed:= 0.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
				lrProcessToolFeederSpeed:=0.0;
			END_IF;
			IF xReadyToolFeedStop AND xReadyGrindFeedStop THEN
				iTmp:=400;
			END_IF;
			RETURN;
		400:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=500;
			END_IF;
			RETURN;
		500:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		(* Initial Procedure *)
		100:	rToolFeedLength:=0.0;
			rToolDiameter:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
			rGrindFeedPlunge:=0.0;
			rSpeedGrindFeed:=0.0;
			rSpeedToolFeed:=0.0;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=200;
		(* Calculation first only for the Plunge Procedure *)
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				rToolFeedLength:=0.0;
				rSpeedToolFeed:=0.0;
				IF T_ProcessImageData.T_CalibrationPara.xPlungeActivationCalib THEN
					rToolFeedLength:=T_ProcessImageData.T_CalibrationPara.rPlungeLengthToolFeedCalib;
					T_WorkTool.rToolLength:=rToolFeedLength/10.0;
				ELSE
					T_WorkTool.rToolLength:=0.0;
				END_IF;
				IF T_ProcessImageData.T_CalibrationPara.xPlungeActivationCalib THEN
					T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
					T_WorkTool.rPitch:=T_ProcessImageData.T_CalibrationPara.rPitchCalib * -1.0;
					T_WorkTool.rGrindFeederPlunge:=	T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool,
									rToolFeedAcclDecl:= T_Standard.T_TeachINToolFeeder.rAcceleration);
					rGrindFeedPlunge:=T_WorkTool.rGrindFeederPlunge * -1.0;
					rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
				ELSE
					rSpeedGrindFeed:=T_ProcessImageData.T_CalibrationPara.rPlungeSpeedGrindFeedCalib;
					rGrindFeedPlunge:=T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess * -1.0;
					IF (rToolFeedLength <> 0) THEN
						rTimeGrindPlunge:=ABS(rGrindFeedPlunge) / rSpeedGrindFeed;		(* calc Time in seocnds *)
						rSpeedToolFeed:=rToolFeedLength / rTimeGrindPlunge;	(* calc Speed ToolFeed in mm/s *)
					END_IF;
					T_WorkTool.rPitch:=T_ProcessImageData.T_CalibrationPara.rPitchCalib * -1.0;
				END_IF;
				rToolRotationSpeed:=T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
				(* Start Relative movement of the GrindAxis *)
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				IF (rToolFeedLength <> 0) THEN
					IF xMicroRodActive THEN
						(* Start continuos movement of the ToolFeeder Axis *)
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					ELSE
						FBCalcGearFactor(	rSpeed:= rSpeedToolFeed * -1.0,
											rToolRotationSpeed:= rToolRotationSpeed,
											T_WorkTool:=T_WorkTool );
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					END_IF;
				END_IF;
				IF (rToolFeedLength <> 0) THEN
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
				END_IF;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xCheckToolFeedPosition:=FALSE;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=300;
			END_IF;
		(* Work the cylinder Part for the ToolCalibration *)
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
				T_WorkTool.rPitch:=T_ProcessImageData.T_CalibrationPara.rPitchCalib * -1.0;
				T_WorkTool.rToolLength:=T_ProcessImageData.T_CalibrationPara.rToolLengthCylinderPartCalib;
				rGrindFeedPlunge:=0.0;
				T_WorkTool.rGrindFeederPlunge:=0.0;
				FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
								xBeckhoffDriveActive:=FALSE,
								T_WorkTool:= T_WorkTool,
								rToolFeedAcclDecl:= 0);
				rSpeedGrindFeed:=0.0;
				rToolFeedLength:=T_WorkTool.rToolLength;
				rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
				rToolRotationSpeed:=T_WorkTool.rToolRotationSpeed;
				IF xMicroRodActive THEN
					(* Start continuos movement of the ToolFeeder Axis *)
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed * -1.0;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(T_WorkTool.iToolFeederGearFactor) * -1.0;
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
				xCheckToolFeedPosition:=TRUE;
				RETURN;
			END_IF;
			IF (lrToolFeederActualPosition > (rToolFeedLength * 10.0)) THEN
				xCheckToolFeedPosition:=FALSE;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=400;
			END_IF;
		(* Displace Procedure Calculation *)
		400:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				rToolFeedLength:=0.0;
				rSpeedToolFeed:=0.0;
				IF T_ProcessImageData.T_CalibrationPara.xDisplaceActivationCalib THEN
					rToolFeedLength:=T_ProcessImageData.T_CalibrationPara.rDisplaceLengthToolFeedCalib;
					T_WorkTool.rToolLength:=rToolFeedLength/10.0;
				ELSE
					T_WorkTool.rToolLength:=0.0;
				END_IF;
				IF T_ProcessImageData.T_CalibrationPara.xDisplaceActivationCalib THEN
					T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
					T_WorkTool.rPitch:=T_ProcessImageData.T_CalibrationPara.rPitchCalib * -1.0;
					T_WorkTool.rGrindFeederPlunge:=	T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool,
									rToolFeedAcclDecl:= T_Standard.T_TeachINToolFeeder.rDeceleration);
					rGrindFeedPlunge:=T_WorkTool.rGrindFeederPlunge;
					rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
				ELSE
					rSpeedGrindFeed:=T_ProcessImageData.T_CalibrationPara.rDisplaceSpeedGrindFeedCalib;
					rGrindFeedPlunge:=T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
					IF (rToolFeedLength <> 0) THEN
						rTimeGrindPlunge:=ABS(rGrindFeedPlunge) / rSpeedGrindFeed;		(* calc Time in seocnds *)
						rSpeedToolFeed:=(rToolFeedLength * 10.0) / rTimeGrindPlunge;	(* calc Speed ToolFeed in mm/s *)
					END_IF;
					T_WorkTool.rPitch:=T_ProcessImageData.T_CalibrationPara.rPitchCalib * -1.0;
				END_IF;
				rToolRotationSpeed:=T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
				(* Start Relative movement of the GrindAxis *)
				TAxisGrindFeeder.T_CtrleSingle.xBlockAcclDeclParameter:=TRUE;	(* do not send again the accl and decl parameter-->better performance *)
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				IF (rToolFeedLength = 0) THEN
				(* Stop ToolFeeder Movement *)
					IF xMicroRodActive THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(xMicroRodActive) THEN
						FBCalcGearFactor(	rSpeed:= 0.0,
											rToolRotationSpeed:= rToolRotationSpeed,
											T_WorkTool:=T_WorkTool );
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0);
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					END_IF;
				ELSE
					IF xMicroRodActive THEN
						(* Start continuos movement of the ToolFeeder Axis *)
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					ELSE
						FBCalcGearFactor(	rSpeed:= rSpeedToolFeed * -1.0,
											rToolRotationSpeed:= rToolRotationSpeed,
											T_WorkTool:=T_WorkTool );
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					END_IF;
				END_IF;
				IF (rToolFeedLength <> 0) THEN
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
				END_IF;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xCheckToolFeedPosition:=FALSE;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=500;
			END_IF;
		(* Check if ToolFeeder Moves and stop it if it moves *)
		500:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF (rToolFeedLength <> 0) THEN
				(* Stop ToolFeeder Movement *)
					IF xMicroRodActive THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(xMicroRodActive) THEN
						FBCalcGearFactor(	rSpeed:= 0.0,
											rToolRotationSpeed:= rToolRotationSpeed,
											T_WorkTool:=T_WorkTool );
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0);
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					END_IF;
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=600;
			END_IF;
		(* GrindFeeder go to Security Position *)
		600:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=700;
			END_IF;
		(* Set ToolFeeder to Measure Position *)
		700:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				rToolFeedLength:=0.0;
				T_WorkTool.rToolLength:=(T_ProcessImageData.T_CalibrationPara.rMeasureOffsetToolFeedCalib / 10.0);
				rSpeedToolFeed:=T_ProcessImageData.T_ProcessPara.rSpeedForwardSlowGrindFeed;
				rToolRotationSpeed:=T_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib;
				rTimeToolFeed:=(T_WorkTool.rToolLength * 10.0) / rSpeedToolFeed;		(* calc Time in seocnds *)
				T_WorkTool.rPitch:=(T_WorkTool.rToolLength * 10.0) / ((rToolRotationSpeed/60.0) * rTimeToolFeed);
				IF xMicroRodActive THEN
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					TAxisToolFeeder.T_CtrleSingle.lrPosition:=T_ProcessImageData.T_CalibrationPara.rMeasurePosToolFeedCalib;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
					TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					FBCalcGearFactor(	rSpeed:= T_ProcessImageData.T_ProcessPara.rSpeedForwardSlowGrindFeed * -1.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					xCheckToolFeedPosition:=TRUE;
					RETURN;
				END_IF;

			END_IF;
			IF xMicroRodActive THEN
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
					(* Procedure is finished *)
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=0;
					xSetEnd:=TRUE;
				END_IF;
			END_IF;
			IF NOT(xMicroRodActive) THEN
				IF (lrToolFeederActualPosition > T_ProcessImageData.T_CalibrationPara.rMeasureOffsetToolFeedCalib) THEN
					FBCalcGearFactor(	rSpeed:= 0.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0);
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					xCheckToolFeedPosition:=FALSE;
					(* Procedure is finished *)
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=0;
					xSetEnd:=TRUE;
				END_IF;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
	xCheckToolFeedPosition:=FALSE;
(*	lrProcessToolFeederActualPosition:=0.0;*)
	lrProcessToolFeederSpeed:=0.0;
	rSpeedToolFeed:=0.0;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolFeedAbsRelPosition
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	iFunctionNr:INT;				(* state of the called function number-->14=move axis absolut, 15=move axis relative *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********       This Functionblock define the function for set the ToolFeeder Axis to the relative or absolut position         ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((TAxisToolFeeder.T_CtrleSingle.xErr) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
			TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xDone)THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xPower) THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=3;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF (iFunctionNr = 14) THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				END_IF;
				IF (iFunctionNr = 15) THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
				END_IF;
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolFeedMaxLenReference
VAR_INPUT
	xMicroRodActive: BOOL;			(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;		(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;				(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	T_Standard:ST_RETAIN_DATA;	(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xToolFeederHWLimitPos: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(*******                                This Functionblock define the function for reference the max length of the Tool (ToolFeeder Axis   ********)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((TAxisToolFeeder.T_CtrleSingle.xErr) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) THEN
		IF NOT(xInitError) THEN
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
				iStepError:=100;
			ELSE
				iStepError:=200;
			END_IF;
		END_IF;
		CASE iStepError OF
			100: 	iStepError:=0;
				xError:=TRUE;
			200: IF TAxisToolFeeder.T_CtrleSingle.xHWLimitPos AND (TAxisToolFeeder.T_CtrleSingle.udiErrorID = 16#F213)AND (iStepPrc =400)THEN
					TAxisToolFeeder.T_CtrleSingle.xErr:=FALSE;
					(*TAxisToolFeeder.T_CtrleSingle.xReset:=TRUE;*)
					xToolFeederHWLimitPos:=TRUE;
					iStepError:=0;
					xInitError:=FALSE;
				ELSE
					iStepError:=0;
					xError:=TRUE;
				END_IF;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
			TAxisToolFeeder.T_CtrleSingle.xExecute:=NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving);
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xDone)THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				IF  T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.xActiv THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=2;
					RETURN;
				END_IF;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xPower) THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=3;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		(* Execute Homing of the ToolFeeder Axis *)
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrHomingMethode:=5;
				TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedSwitch:=T_Standard.T_TeachINToolFeeder.rRefSpeed;
				TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedZero:=T_Standard.T_TeachINToolFeeder.rRefSpeed / 10.0;
				TAxisToolFeeder.T_CtrleSingle.lrHomeAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=9;	(* Reference Axis *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xHWLimitPos) THEN
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=300;
				ELSE
					xHardwareError:=TRUE;
					iTmpErrorNr:=3;
					RETURN;
				END_IF;
			END_IF;
		(* Start continuos movement of the ToolFeeder Axis for searching the max. way of ToolFeeder Axis (HWLimitPos)  --> Direction positiv*)
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_Standard.T_TeachINToolFeeder.rRefSpeed;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xToolFeederHWLimitPos:=FALSE; (* ControlFlag for TAxisToolFeeder.T_CtrleSingle.xHWLimitPos*)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=400;
			END_IF;
		(* Control if the HWLimitPos switch of the ToolFeeder Axis is activ and the movement is stoped*)
		400: IF xToolFeederHWLimitPos THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=500;
			END_IF;
		(* Start slow continuos movement of the ToolFeeder Axis for move away from  the HWLimitPos switch  --> Direction negativ *)
		500:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				TAxisToolFeeder.T_CtrleSingle.lrVelocity:= T_Standard.T_TeachINToolFeeder.rRefSpeed/10.0 * -1.0;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=600;
			END_IF;
		(* Control  the HWLimitPos switch of the ToolFeeder Axis until  is inactiv and stop the movement(next step)*)
		600: 	IF NOT(TAxisToolFeeder.T_CtrleSingle.xHWLimitPos) THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=700;
			END_IF;
		(*Stop the movement of  the ToolFeeder Axis *)
		700: IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=800;
			END_IF;
		(*Move fix security offset of 2.0mm for the ToolFeeder Axis --> Direction negativ *)
		800:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* Start continuos movement of the ToolFeeder Axis *)
				TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDistance:= -2.0;
				TAxisToolFeeder.T_CtrleSingle.lrVelocity:= T_Standard.T_TeachINToolFeeder.rRefSpeed/10.0;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=8;	(* Move relative*)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				(*Save .......*)
				(* T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal:= TAxisToolFeeder.T_LiveValue.lrActualPosition * 0.1;*)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolFeedReference
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	T_Standard:ST_RETAIN_DATA;							(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(*******                                This Functionblock define the function for reference the ToolFeeder Axis                                                 ********)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((TAxisToolFeeder.T_CtrleSingle.xErr) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	TAxisToolFeeder.T_CtrleSingle.iFunction:=5;
			TAxisToolFeeder.T_CtrleSingle.xExecute:=NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving);
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=300;
			END_IF;
			RETURN;
		300:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xDone)THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xPower) THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=3;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrHomingMethode:=5;
				TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedSwitch:=T_Standard.T_TeachINToolFeeder.rRefSpeed;
				TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedZero:=T_Standard.T_TeachINToolFeeder.rRefSpeed / 10.0;
				TAxisToolFeeder.T_CtrleSingle.lrHomeAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=9;	(* Reference Axis *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolRotationTorqueStart
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	TONWaitStop: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                      This Functionblock define the function for start the toolrotation                                                    ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((TAxisToolLeft.T_CtrleSingle.xErr OR (TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR TAxisToolRight.T_CtrleSingle.xErr OR (TAxisToolFeeder.T_CtrleSingle.xErr AND NOT(xMicroRodActive))) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	IF TAxisToolLeft.T_CtrleSingle.xDone OR (TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR TAxisToolRight.T_CtrleSingle.xDone OR (TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) THEN
				TAxisToolLeft.T_CtrleSingle.iFunction:=5;
				TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
				iTmp:=200;
			END_IF;
			RETURN;
		200:	IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone THEN
				iTmp:=300;
				TONWaitStop(IN:=FALSE);
			END_IF;
			RETURN;
		300:	xTmp:=	((UINT_TO_WORD(TAxisToolRight.T_TxPdoParameter.uiStatusWord) AND 16#1000) = 16#1000) AND
					((((UINT_TO_WORD(TAxisToolCenter.T_TxPdoParameter.uiStatusWord) AND 16#1000) = 16#1000) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					((((UINT_TO_WORD(TAxisToolFeeder.T_TxPdoParameter.uiStatusWord) AND 16#1000) = 16#1000) AND NOT(xMicroRodActive)) OR xMicroRodActive);
			TONWaitStop(IN:=TRUE,PT:=T#1000ms);
			IF TONWaitStop.Q AND xTmp THEN
				TONWaitStop(IN:=FALSE);
				iTmp:=400;
			END_IF;
			RETURN;
		400:	IF xMicroRodActive THEN
				IF TAxisToolCenter.T_CtrleSingle.xSlave THEN
					TAxisToolCenter.T_CtrleSingle.iFunction:=25;
					TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF TAxisToolRight.T_CtrleSingle.xSlave THEN
				TAxisToolRight.T_CtrleSingle.iFunction:=25;
				TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(xMicroRodActive) THEN
				IF TAxisToolFeeder.T_CtrleSingle.xSlave THEN
					TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			iTmp:=500;
			RETURN;
		500:	IF ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				xTmpInit:=FALSE;
				iTmp:=100;
				xSetEnd:=TRUE;
			END_IF;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolLeft.T_CtrleSingle.xDone) OR (NOT(TAxisToolCenter.T_CtrleSingle.xDone) AND xMicroRodActive) OR NOT(TAxisToolRight.T_CtrleSingle.xDone) OR (NOT(TAxisToolFeeder.T_CtrleSingle.xDone) AND NOT(xMicroRodActive)) THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				IF NOT(TAxisToolLeft.T_CtrleSingle.xPower) THEN
					TAxisToolLeft.T_CtrleSingle.iFunction:=3;
					TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolCenter.T_CtrleSingle.xPower) THEN
						TAxisToolCenter.T_CtrleSingle.iFunction:=3;
						TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(TAxisToolRight.T_CtrleSingle.xPower) THEN
					TAxisToolRight.T_CtrleSingle.iFunction:=3;
					TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xPower) THEN
						TAxisToolFeeder.T_CtrleSingle.iFunction:=3;
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolCenter.T_CtrleSingle.xSlave) THEN
						TAxisToolCenter.T_CtrleSingle.iFunction:=25;
						TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(TAxisToolRight.T_CtrleSingle.xSlave) THEN
					TAxisToolRight.T_CtrleSingle.iFunction:=25;
					TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xSlave) THEN
						TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=300;
			END_IF;
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolLeft.T_CtrleSingle.iFunction:=6;
				TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolRotationTorqueStop
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	TONWaitStop: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                      This Functionblock define the function for stop the toolrotation                                                    ************)
(****************************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xHardwareError OR ((TAxisToolLeft.T_CtrleSingle.xErr OR (TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR TAxisToolRight.T_CtrleSingle.xErr OR (TAxisToolFeeder.T_CtrleSingle.xErr AND NOT(xMicroRodActive))) AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		(* No immediately stopping *)
		100:	xTmpInit:=FALSE;
			iTmp:=100;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolLeft.T_CtrleSingle.xDone) OR (NOT(TAxisToolCenter.T_CtrleSingle.xDone) AND xMicroRodActive) OR NOT(TAxisToolRight.T_CtrleSingle.xDone) OR (NOT(TAxisToolFeeder.T_CtrleSingle.xDone) AND NOT(xMicroRodActive)) THEN
					xHardwareError:=TRUE;
					iTmpErrorNr:=1;
					RETURN;
				END_IF;
				TAxisToolLeft.T_CtrleSingle.iFunction:=5;
				TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=199;
			END_IF;
		199:	xTmp:=	((UINT_TO_WORD(TAxisToolRight.T_TxPdoParameter.uiStatusWord) AND 16#1000) = 16#1000) AND
					((((UINT_TO_WORD(TAxisToolCenter.T_TxPdoParameter.uiStatusWord) AND 16#1000) = 16#1000) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					((((UINT_TO_WORD(TAxisToolFeeder.T_TxPdoParameter.uiStatusWord) AND 16#1000) = 16#1000) AND NOT(xMicroRodActive)) OR xMicroRodActive);
			IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TONWaitStop(IN:=FALSE);
			END_IF;
			TONWaitStop(IN:=TRUE,PT:=T#1000ms);
			IF TONWaitStop.Q AND xTmp THEN
				TONWaitStop(IN:=FALSE);
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xMicroRodActive THEN
					IF TAxisToolCenter.T_CtrleSingle.xSlave THEN
						TAxisToolCenter.T_CtrleSingle.iFunction:=25;
						TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF TAxisToolRight.T_CtrleSingle.xSlave THEN
					TAxisToolRight.T_CtrleSingle.iFunction:=25;
					TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					IF TAxisToolFeeder.T_CtrleSingle.xSlave THEN
						TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolWorkingGeometry
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram data structure for the process parameter *)
	T_Standard:ST_RETAIN_DATA;							(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
	T_WorkTool:ST_WORKTOOL;	(* Tool parameter *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
	bActivePartNumber:BYTE;		(* gives the active number of the worked section of the geometry *)
	lrProcessToolFeederActualPosition:LREAL;	(* gives the calculated position of the ToolFeeder *)
	lrProcessToolFeederSpeed:LREAL;			(* gives the calculated speed of the ToolFeeder *)
	iCountDownPlungeCycle:INT;
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	xReadFirstTime: BOOL;
	xTmp1: BOOL;
	rToolRotationSpeed: REAL;
	FBToolCalcul:FB_TOOL_CALCUL_NEW;

	rToolFeedLength: REAL;
	rToolDiameter: REAL;
	rGrindFeedPlunge: REAL;
	ii: INT;
	iStartSection: INT;
	iEndSection: INT;
	rSpeedGrindFeed: REAL;
	rSpeedToolFeed: REAL;
	rTimeGrindPlunge: REAL;
	FBCalcGearFactor: FB_CALC_GEARFACTOR;
	lrToolFeederActualPosition: LREAL;
	iTmpStartSection: INT;
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING;
	xResetFB: BOOL;
	xGrindFeedMaster: BOOL;
	xCheckToolFeedPosition: BOOL;
	lrToolFeederPosition: LREAL;
	lrToolRightPosition: LREAL;
	lrSaveToolFeederPosition: LREAL;
	lrSaveToolRightPosition: LREAL;
	rPlungeCycleGrindFeedGeometry: REAL;
	lrGearFactor: LREAL;
	xPositionReached: BOOL;
	lrToolFeedCalcLengthPosition: REAL;
	lrCalcToolLengthInc: LREAL;
	lrCalcToolLength: LREAL;
	xReadyToolFeedStop: BOOL;
	xReadyGrindFeedStop: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                This Functionblock define the function for work a geometry on the tool                                          ************)
(****************************************************************************************************************************************************)

IF NOT(xReadFirstTime) THEN
	xReadFirstTime:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
xTmp:=	TAxisToolLeft.T_CtrleSingle.xErr OR
		(TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
		TAxisToolRight.T_CtrleSingle.xErr OR
		TAxisToolFeeder.T_CtrleSingle.xErr OR
		TAxisGrindFeeder.T_CtrleSingle.xErr;
xTmp1:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		 NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) AND
		NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute);
IF (xHardwareError OR (xTmp AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF xTmp1 THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
		xCheckToolFeedPosition:=FALSE;
		bActivePartNumber:=0;
		lrCalcToolLengthInc:=lrCalcToolLength:=0.0;
		rSpeedToolFeed:=0.0;
		iCountDownPlungeCycle:=1;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************		               Controlling of the ToolFeeder Position                            *****************************)
(******************************************************************************************************************************************)
IF xCheckToolFeedPosition THEN
	IF xMicroRodActive THEN
		lrToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo - lrSaveToolFeederPosition;
		lrToolFeederActualPosition:=(lrToolFeederPosition / TAxisToolFeeder.T_CtrleSingle.lrScaleFactor);
		lrCalcToolLength:=lrToolFeederActualPosition;
	END_IF;
	IF NOT(xMicroRodActive) AND (TAxisToolRight.T_CtrleSingle.lrGearRatio <> 0.0) THEN
		lrToolFeedCalcLengthPosition:=((((T_WorkTool.rToolLength * 10.0) / ABS(T_WorkTool.rPitch)) * 24000.0) / TAxisToolRight.T_CtrleSingle.lrScaleFactor);
		lrToolFeederPosition:=lrToolFeederPosition + ABS(ABS(TAxisToolRight.T_LiveValue.lrActualPosition) - (lrSaveToolFeederPosition / TAxisToolRight.T_CtrleSingle.lrScaleFactor));
		lrSaveToolFeederPosition:=ABS(TAxisToolRight.T_LiveValue.lrActualPositionNotModulo);
		lrToolFeederActualPosition:=((T_WorkTool.rToolLength * 10.0) / lrToolFeedCalcLengthPosition) * lrToolFeederPosition;
		lrCalcToolLength:=lrCalcToolLengthInc + lrToolFeederActualPosition;
	END_IF;
ELSE
	IF NOT(xMicroRodActive) AND (TAxisToolRight.T_CtrleSingle.lrGearRatio <> 0.0) THEN
		lrSaveToolFeederPosition:=ABS(TAxisToolRight.T_LiveValue.lrActualPositionNotModulo);
		lrSaveToolRightPosition:=TAxisToolRight.T_LiveValue.lrActualPositionNotModulo * TAxisToolRight.T_CtrleSingle.lrGearRatio;
		lrCalcToolLengthInc:=lrCalcToolLength;
	END_IF;
	IF xMicroRodActive THEN
		lrSaveToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo;
	END_IF;
	lrToolFeederActualPosition:=lrToolFeederPosition:=0.0;
END_IF;
lrProcessToolFeederActualPosition:=lrCalcToolLength;
lrProcessToolFeederSpeed:=rSpeedToolFeed;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	xReadyToolFeedStop:=xReadyGrindFeedStop:=FALSE;
			TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
			TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
			TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
			TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				iTmp:=300;
			END_IF;
			RETURN;
		300:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone AND NOT(xReadyGrindFeedStop) THEN
				xReadyGrindFeedStop:=TRUE;
			END_IF;
			IF (TAxisGrindFeeder.T_LiveValue.lrActualPosition >= (T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess)) AND NOT(xReadyToolFeedStop) THEN
				xReadyToolFeedStop:=TRUE;
				xCheckToolFeedPosition:=FALSE;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					FBCalcGearFactor(	rSpeed:= 0.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
				lrProcessToolFeederSpeed:=0.0;
			END_IF;
			IF xReadyToolFeedStop AND xReadyGrindFeedStop THEN
				iTmp:=400;
			END_IF;
			RETURN;
		400:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=500;
			END_IF;
			RETURN;
		500:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		(* Initial Procedure *)
		100:	rToolFeedLength:=0.0;
			rToolDiameter:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
			rGrindFeedPlunge:=0.0;
			rSpeedGrindFeed:=0.0;
			rSpeedToolFeed:=0.0;
			iStartSection:=1;
			(* Check Start and End Section of the ToolGeometry *)
			FOR ii:=1 TO 4 DO
				IF T_ProcessImageData.T_GeometryPara.axActiveSection[ii] THEN
					IF (iStartSection = 0) THEN
						iStartSection:=ii;
					END_IF;
					iEndSection:=ii;
				END_IF;
			END_FOR;
			xResetFB:=TRUE;
			FBCalcPlungeGrinding(	rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
									rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
									xReset:= xResetFB);
			IF xMicroRodActive THEN
				rPlungeCycleGrindFeedGeometry:=T_ProcessImageData.T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry;
			END_IF;
			IF NOT(xMicroRodActive) THEN
			(* MicroWire is not aloved to work in more cycle *)
				rPlungeCycleGrindFeedGeometry:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
			END_IF;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			(* Start with AutoGeometry working *)
			iStepPrc:=200;
		(* Calculation of Grind plunge of all section, include Plunge procedure and Displace procedure *)
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB);
			END_IF;
			IF xInitStep THEN
				bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF FBCalcPlungeGrinding.xEndWorking THEN
					iStepPrc:=400;
				ELSE
					iStepPrc:=300;
				END_IF;
			END_IF;
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xGrindFeedMaster:=FALSE;
	(********************************                              Plunge Procedure                         *******************************)
				IF (FBCalcPlungeGrinding.iStepSectionWork = 0) THEN
					rToolFeedLength:=0.0;
					rSpeedToolFeed:=0.0;
					IF T_ProcessImageData.T_AutoGeometryPara.xPlungeActivationGeometry THEN
						rToolFeedLength:=T_ProcessImageData.T_AutoGeometryPara.rPlungeLengthToolFeedGeometry;
						T_WorkTool.rToolLength:=rToolFeedLength/10.0;
					ELSE
						T_WorkTool.rToolLength:=0.0;
					END_IF;
					IF T_ProcessImageData.T_AutoGeometryPara.xPlungeActivationGeometry THEN
						T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
						T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iStartSection] * -1.0;
						T_WorkTool.rGrindFeederPlunge:=	FBCalcPlungeGrinding.rGrindingRelativePosition;
						FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
										xBeckhoffDriveActive:=FALSE,
										T_WorkTool:= T_WorkTool,
										rToolFeedAcclDecl:= T_Standard.T_TeachINToolFeeder.rAcceleration);
						rGrindFeedPlunge:=T_WorkTool.rGrindFeederPlunge * -1.0;
						rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
						rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
					ELSE
						rSpeedGrindFeed:=T_ProcessImageData.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry;
						rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
						IF (rToolFeedLength <> 0) THEN
							rTimeGrindPlunge:=ABS(rGrindFeedPlunge) / rSpeedGrindFeed;		(* calc Time in seocnds *)
							rSpeedToolFeed:=rToolFeedLength / rTimeGrindPlunge;	(* calc Speed ToolFeed in mm/s *)
						END_IF;
						T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iStartSection] * -1.0;
					END_IF;
					rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
				END_IF;
	(********************************                              Geometry Procedure                         *******************************)
				IF (FBCalcPlungeGrinding.iStepSectionWork > 0) AND (FBCalcPlungeGrinding.iStepSectionWork < 5) THEN
					(* Check first active section *)
					iTmpStartSection:=iStartSection + (FBCalcPlungeGrinding.iStepSectionWork - 1);
					T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
					T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iTmpStartSection] * -1.0;
					T_WorkTool.rToolLength:=T_ProcessImageData.T_GeometryPara.arSectionLength[iTmpStartSection];
					rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
					T_WorkTool.rGrindFeederPlunge:=rGrindFeedPlunge;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool,
									rToolFeedAcclDecl:= 0);
					rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
					rToolFeedLength:=T_WorkTool.rToolLength;
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
					rToolRotationSpeed:=T_WorkTool.rToolRotationSpeed;
				END_IF;
	(********************************                              Displace Procedure                         *******************************)
				IF (FBCalcPlungeGrinding.iStepSectionWork = 5) THEN
					rToolFeedLength:=0.0;
					rSpeedToolFeed:=0.0;
					IF T_ProcessImageData.T_AutoGeometryPara.xDisplaceActivationGeometry THEN
						rToolFeedLength:=T_ProcessImageData.T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry;
						T_WorkTool.rToolLength:=rToolFeedLength/10.0;
					ELSE
						T_WorkTool.rToolLength:=0.0;
					END_IF;
					IF T_ProcessImageData.T_AutoGeometryPara.xDisplaceActivationGeometry THEN
						T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
						T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iEndSection] * -1.0;
						T_WorkTool.rGrindFeederPlunge:=	FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
						FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
										xBeckhoffDriveActive:=FALSE,
										T_WorkTool:= T_WorkTool,
										rToolFeedAcclDecl:= 0);
						rGrindFeedPlunge:=T_WorkTool.rGrindFeederPlunge;
						rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
						rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
					ELSE
						rSpeedGrindFeed:=T_ProcessImageData.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry;
						rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
						IF (rToolFeedLength <> 0) THEN
							rTimeGrindPlunge:=ABS(rGrindFeedPlunge) / rSpeedGrindFeed;		(* calc Time in seocnds *)
							rSpeedToolFeed:=(rToolFeedLength * 10.0) / rTimeGrindPlunge;	(* calc Speed ToolFeed in mm/s *)
						END_IF;
						T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iEndSection] * -1.0;
					END_IF;
					rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
				END_IF;
	(********************************                              Drive Procedure                             *******************************)
				IF xMicroRodActive THEN
					IF (*TAxisToolFeeder.T_CtrleSingle.xNotMoving AND*) (rToolFeedLength <> 0) THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						IF (FBCalcPlungeGrinding.iStepSectionWork > 0) AND (FBCalcPlungeGrinding.iStepSectionWork < 5) THEN
							TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed * -1.0;
						ELSE
							TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed;
						END_IF;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) AND (rToolFeedLength = 0) THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					IF (FBCalcPlungeGrinding.iStepSectionWork < 1) OR (FBCalcPlungeGrinding.iStepSectionWork > 4) THEN
						FBCalcGearFactor(	rSpeed:= rSpeedToolFeed * -1.0,
											rToolRotationSpeed:= rToolRotationSpeed,
											T_WorkTool:=T_WorkTool );
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					ELSE
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(T_WorkTool.iToolFeederGearFactor) * -1.0;
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iToolFeederGearDivider);
					END_IF;
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
				(* Start GrindFeeder *)
				IF (rGrindFeedPlunge <> 0) THEN
					xGrindFeedMaster:=TRUE;
					IF (rToolFeedLength <> 0) THEN
						xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
					END_IF;
					IF (FBCalcPlungeGrinding.iStepSectionWork > 0) THEN
						TAxisGrindFeeder.T_CtrleSingle.xBlockAcclDeclParameter:=TRUE;	(* do not send again the accl and decl parameter-->better performance *)
					END_IF;
					TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
					TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					xGrindFeedMaster:=FALSE;
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
				END_IF;
			END_IF;
	(********************************                              Wait end active section                             *******************************)
			IF xGrindFeedMaster THEN
			(* This is active by plunge procedure or displace procedure or by work a cone section *)
				IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					IF (FBCalcPlungeGrinding.iStepSectionWork <> 5) THEN
						iStepPrc:=200;
					ELSE
						IF xMicroRodActive THEN
							iStepPrc:=400;
						ELSE
							iStepPrc:=200;
						END_IF;
					END_IF;
				END_IF;
			END_IF;
			IF NOT(xGrindFeedMaster) THEN
			(* This is only active if it is work a cylinder section *)
				IF (lrToolFeederActualPosition > (rToolFeedLength * 10.0)) THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					IF (FBCalcPlungeGrinding.iStepSectionWork <> 5) THEN
						iStepPrc:=200;
					ELSE
						IF xMicroRodActive THEN
							iStepPrc:=400;
						ELSE
							iStepPrc:=200;
						END_IF;
					END_IF;
				END_IF;
			END_IF;
		(* Check if ToolFeeder Moves and stop it if it moves *)
		400:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					FBCalcGearFactor(	rSpeed:= 0.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				rSpeedToolFeed:=0.0;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=500;
			END_IF;
		(* GrindFeeder go to Security Position *)
		500:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				IF FBCalcPlungeGrinding.xEndWorking THEN
					(* Procedure is finished *)
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=900;
				ELSE
					(* Only for MicroRod --> Work next cycle *)
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=600;
				END_IF;
			END_IF;
		(* Calculation of Grind plunge of all section, include Plunge procedure and Displace procedure *)
		600:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB);
			END_IF;
			IF xInitStep THEN
				bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF FBCalcPlungeGrinding.xEndWorking THEN
					iStepPrc:=400;
				ELSE
					iStepPrc:=700;
				END_IF;
			END_IF;
		(* ToolFeeder go to Start Position *)
		700:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				TAxisToolFeeder.T_CtrleSingle.lrPosition:=T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
				TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				(* Only for MicroRod --> Work next cycle *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=800;
			END_IF;
		(* GrindFeeder Set Absolut to ToolDiameter minus the offset with the fast speed *)
		800:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedForwardFastGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* Only for MicroRod --> Work next cycle *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=801;
			END_IF;
		(* GrindFeeder Set Absolut to ToolDiameter with the slow speed *)
		801:	(*IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedForwardSlowGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* Only for MicroRod --> Work next cycle *)*)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=300;
				iCountDownPlungeCycle:=iCountDownPlungeCycle + 1;
			(*END_IF;*)
		900:	xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=0;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
	xCheckToolFeedPosition:=FALSE;
	bActivePartNumber:=0;
(*	lrProcessToolFeederActualPosition:=0.0;*)
	lrProcessToolFeederSpeed:=0.0;
	rSpeedToolFeed:=0.0;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolWorkingGeometryMultiCycle
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram data structure for the process parameter *)
	T_Standard:ST_RETAIN_DATA;							(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
	T_WorkTool:ST_WORKTOOL;	(* Tool parameter *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
	bActivePartNumber:BYTE;		(* gives the active number of the worked section of the geometry *)
	lrProcessToolFeederActualPosition:LREAL;	(* gives the calculated position of the ToolFeeder *)
	lrProcessToolFeederSpeed:LREAL;			(* gives the calculated speed of the ToolFeeder *)
	iCountDownPlungeCycle:INT;
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	xReadFirstTime: BOOL;
	xTmp1: BOOL;
	rToolRotationSpeed: REAL;
	FBToolCalcul:FB_TOOL_CALCUL_NEW;

	rToolFeedLength: REAL;
	rToolDiameter: REAL;
	rGrindFeedPlunge: REAL;
	ii: INT;
	iStartSection: INT;
	iEndSection: INT;
	rSpeedGrindFeed: REAL;
	rSpeedToolFeed: REAL;
	rTimeGrindPlunge: REAL;
	FBCalcGearFactor: FB_CALC_GEARFACTOR;
	lrToolFeederActualPosition: LREAL;
	iTmpStartSection: INT;
(*22.12.2009: KFS 	{    *)
	(*
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING;
	*)
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING_MultiCycle;
	xFirstCountDownPlungeCycle:BOOL;
	xInitFB:BOOL;
	lrToolFeederStartSectionOffset: LREAL;
	xCalculationGrindingSection:BOOL;
(*22.12.2009: KFS 	}    *)
	xResetFB: BOOL;
	xGrindFeedMaster: BOOL;
	xCheckToolFeedPosition: BOOL;
	lrToolFeederPosition: LREAL;
	lrToolRightPosition: LREAL;
	lrSaveToolFeederPosition: LREAL;
	lrSaveToolRightPosition: LREAL;
	rPlungeCycleGrindFeedGeometry: REAL;
	lrGearFactor: LREAL;
	xPositionReached: BOOL;
	lrToolFeedCalcLengthPosition: REAL;
	lrCalcToolLengthInc: LREAL;
	lrCalcToolLength: LREAL;
	xReadyToolFeedStop: BOOL;
	xReadyGrindFeedStop: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                This Functionblock define the function for work a geometry on the tool                                          ************)
(****************************************************************************************************************************************************)

IF NOT(xReadFirstTime) THEN
	xReadFirstTime:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
xTmp:=	TAxisToolLeft.T_CtrleSingle.xErr OR
		(TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
		TAxisToolRight.T_CtrleSingle.xErr OR
		TAxisToolFeeder.T_CtrleSingle.xErr OR
		TAxisGrindFeeder.T_CtrleSingle.xErr;
xTmp1:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		 NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) AND
		NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute);
IF (xHardwareError OR (xTmp AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF xTmp1 THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
		xCheckToolFeedPosition:=FALSE;
		bActivePartNumber:=0;
		lrCalcToolLengthInc:=lrCalcToolLength:=0.0;
		rSpeedToolFeed:=0.0;
		iCountDownPlungeCycle:=1;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************		               Controlling of the ToolFeeder Position                            *****************************)
(******************************************************************************************************************************************)
IF xCheckToolFeedPosition THEN
	lrToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo - lrSaveToolFeederPosition;
	lrToolFeederActualPosition:=(lrToolFeederPosition / TAxisToolFeeder.T_CtrleSingle.lrScaleFactor);
	lrCalcToolLength:=lrToolFeederActualPosition;
ELSE
	lrSaveToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo;
	lrToolFeederActualPosition:=lrToolFeederPosition:=0.0;
END_IF;
lrProcessToolFeederActualPosition:=lrCalcToolLength;
lrProcessToolFeederSpeed:=rSpeedToolFeed;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	xReadyToolFeedStop:=xReadyGrindFeedStop:=FALSE;
			TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
			TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
			TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
			TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				iTmp:=300;
			END_IF;
			RETURN;
		300:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone AND NOT(xReadyGrindFeedStop) THEN
				xReadyGrindFeedStop:=TRUE;
			END_IF;
			IF (TAxisGrindFeeder.T_LiveValue.lrActualPosition >= (T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess)) AND NOT(xReadyToolFeedStop) THEN
				xReadyToolFeedStop:=TRUE;
				xCheckToolFeedPosition:=FALSE;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				lrProcessToolFeederSpeed:=0.0;
			END_IF;
			IF xReadyToolFeedStop AND xReadyGrindFeedStop THEN
				iTmp:=400;
			END_IF;
			RETURN;
		400:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=500;
			END_IF;
			RETURN;
		500:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		(* Initial Procedure *)
		100:	rToolFeedLength:=0.0;
			rToolDiameter:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
			rGrindFeedPlunge:=0.0;
			rSpeedGrindFeed:=0.0;
			rSpeedToolFeed:=0.0;
			lrToolFeederStartSectionOffset:=0.0;
			iStartSection:=1;
			xInitFB:=FALSE;
			xFirstCountDownPlungeCycle:=FALSE;
			(* Check Start and End Section of the ToolGeometry *)
			FOR ii:=1 TO 4 DO
				IF T_ProcessImageData.T_GeometryPara.axActiveSection[ii] THEN
					IF (iStartSection = 0) THEN
						iStartSection:=ii;
					END_IF;
					iEndSection:=ii;
				END_IF;
			END_FOR;
			xResetFB:=TRUE;
			FBCalcPlungeGrinding(	rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
									rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
									xReset:= xResetFB,
									xInit:= xInitFB);
			rPlungeCycleGrindFeedGeometry:=T_ProcessImageData.T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry;
			xInitFB:=TRUE;
			FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
									T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
									rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
									rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
									rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
									iStartSection:= iStartSection,
									iEndSection:= iEndSection,
									xReset:= xResetFB,
									xInit:= xInitFB);

			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=120;
		(* Calculat the actual Start Position of ToolFeeder *)
		120:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB,
										xInit:= xInitFB);
				xCalculationGrindingSection:=TRUE;
			END_IF;
			IF xInitStep THEN
				iTmpStartSection:=iStartSection + (FBCalcPlungeGrinding.iStepSectionWork-1);
				lrToolFeederStartSectionOffset:= 0.0;

				FOR ii:= iTmpStartSection TO  iEndSection BY 1 DO
					IF xCalculationGrindingSection THEN
						FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
												T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
												rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
												rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
												rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
												iStartSection:= iStartSection,
												iEndSection:= iEndSection,
												xReset:= xResetFB,
												xInit:= xInitFB);
						IF ( FBCalcPlungeGrinding.rActualPositionGrindFeedEnd[ii+1] <  FBCalcPlungeGrinding.rToolDiameterWithOffset ) THEN
							xCalculationGrindingSection:= FALSE;
						ELSE
							lrToolFeederStartSectionOffset:= lrToolFeederStartSectionOffset + (T_ProcessImageData.T_GeometryPara.arSectionLength[ii+1] * 10); (* Vorgabe in cm! Übergabe in mm!  --> *10 *)
						END_IF;
					END_IF;
				END_FOR;
				IF FBCalcPlungeGrinding.xEndWorking THEN
					iStepPrc:=400;
				ELSE
					IF xFirstCountDownPlungeCycle THEN
						iCountDownPlungeCycle:=iCountDownPlungeCycle + 1;
					END_IF;
					bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
					iStepPrc:=140;
				END_IF;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* ToolFeeder go to actual Start Position *)
		140:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				TAxisToolFeeder.T_CtrleSingle.lrPosition:=T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto + lrToolFeederStartSectionOffset;
				TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=160;
			END_IF;
		(* GrindFeeder Set Absolut to ToolDiameter minus the offset with the fast speed *)
		160:  IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedForwardFastGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* Move GrindFeed to StartPosition of actual section *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=180;
			END_IF;
		(* GrindFeeder Move to Relativ to StartDiameter of the actuel section with the slow speed *)
		180:  IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* StartPosition GrindFeeder wird nur solange Angefahren bis die Position direkt aus dem FBCalcPlungeGrinding berechnet wird -> iStepSection = 0 *)
				IF FBCalcPlungeGrinding.iStepSectionWork >0 THEN
					iTmpStartSection:=iStartSection + (FBCalcPlungeGrinding.iStepSectionWork - 1);
					(* Calculation of the Offset *)
					rGrindFeedPlunge:= ( FBCalcPlungeGrinding.rToolDiameterWithOffset - FBCalcPlungeGrinding.rActualPositionGrindFeedStart[iTmpStartSection] )* -1.0;
					TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
					TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedForwardSlowGrindFeed;
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relativ *)
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* Start with AutoGeometry working *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=300;
			END_IF;
		(* Calculation of Grind plunge of all section, include Plunge procedure and Displace procedure *)
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB,
										xInit:= xInitFB);
			END_IF;
			IF xInitStep THEN
				bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF FBCalcPlungeGrinding.xEndWorking THEN
					iStepPrc:=400;
				ELSE
					iStepPrc:=300;
				END_IF;
			END_IF;
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xGrindFeedMaster:=FALSE;
	(********************************                              Plunge Procedure                         *******************************)
				IF (FBCalcPlungeGrinding.iStepSectionWork = 0) THEN
(*22.12.2009: KFS 	{   *)
					rToolFeedLength:=0.0;
					rSpeedToolFeed:=0.0;
					T_WorkTool.rToolLength:=0.0;

					rSpeedGrindFeed:=T_ProcessImageData.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry;
					rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;

					T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iStartSection] * -1.0;
					rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
(*22.12.2009: KFS 	}   *)
				END_IF;
	(********************************                              Geometry Procedure                         *******************************)
				IF (FBCalcPlungeGrinding.iStepSectionWork > 0) AND (FBCalcPlungeGrinding.iStepSectionWork < 5) THEN
					(* Check first active section *)
					iTmpStartSection:=iStartSection + (FBCalcPlungeGrinding.iStepSectionWork - 1);
					T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
					T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iTmpStartSection] * -1.0;
					T_WorkTool.rToolLength:=T_ProcessImageData.T_GeometryPara.arSectionLength[iTmpStartSection];
					rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
					T_WorkTool.rGrindFeederPlunge:=rGrindFeedPlunge;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool,
									rToolFeedAcclDecl:= 0);
					rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
					rToolFeedLength:=T_WorkTool.rToolLength;
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
					rToolRotationSpeed:=T_WorkTool.rToolRotationSpeed;
				END_IF;
	(********************************                              Displace Procedure                         *******************************)
				IF (FBCalcPlungeGrinding.iStepSectionWork = 5) THEN
(*22.12.2009: KFS 	{   *)
					rToolFeedLength:=0.0;
					rSpeedToolFeed:=0.0;
					T_WorkTool.rToolLength:=0.0;

					rSpeedGrindFeed:=T_ProcessImageData.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry;
					rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;

					T_WorkTool.rPitch:=T_ProcessImageData.T_GeometryPara.arSectionPitch[iEndSection] * -1.0;
					rToolRotationSpeed:=T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
(*22.12.2009: KFS 	}   *)
				END_IF;
	(********************************                              Drive Procedure                             *******************************)
				IF (*TAxisToolFeeder.T_CtrleSingle.xNotMoving AND*) (rToolFeedLength <> 0) THEN
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					IF (FBCalcPlungeGrinding.iStepSectionWork > 0) AND (FBCalcPlungeGrinding.iStepSectionWork < 5) THEN
						TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed * -1.0;
					ELSE
						TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed;
					END_IF;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) AND (rToolFeedLength = 0) THEN
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				(* Start GrindFeeder *)
				IF (rGrindFeedPlunge <> 0) THEN
					xGrindFeedMaster:=TRUE;
					IF (rToolFeedLength <> 0) THEN
						xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
					END_IF;
					IF (FBCalcPlungeGrinding.iStepSectionWork > 0) THEN
						TAxisGrindFeeder.T_CtrleSingle.xBlockAcclDeclParameter:=TRUE;	(* do not send again the accl and decl parameter-->better performance *)
					END_IF;
					TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
					TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					xGrindFeedMaster:=FALSE;
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
				END_IF;
			END_IF;
	(********************************                              Wait end active section                             *******************************)
			IF xGrindFeedMaster THEN
			(* This is active by plunge procedure or displace procedure or by work a cone section *)
				IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					IF (FBCalcPlungeGrinding.iStepSectionWork <> 5) THEN
						iStepPrc:=200;
					ELSE
						iStepPrc:=400;
					END_IF;
				END_IF;
			END_IF;
			IF NOT(xGrindFeedMaster) THEN
			(* This is only active if it is work a cylinder section *)
				IF (lrToolFeederActualPosition > (rToolFeedLength * 10.0)) THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					IF (FBCalcPlungeGrinding.iStepSectionWork <> 5) THEN
						iStepPrc:=200;
					ELSE
						iStepPrc:=400;
					END_IF;
				END_IF;
			END_IF;
		(* Check if ToolFeeder Moves and stop it if it moves *)
		400:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				rSpeedToolFeed:=0.0;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=500;
			END_IF;
		(* GrindFeeder go to Security Position *)
		500:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				IF FBCalcPlungeGrinding.xEndWorking THEN
					(* Procedure is finished *)
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=600;
				ELSE
(*					iCountDownPlungeCycle:=iCountDownPlungeCycle + 1;*)
					xFirstCountDownPlungeCycle:=TRUE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=120;
				END_IF;
			END_IF;
		600:	xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
			iStepPrc:=0;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
	xCheckToolFeedPosition:=FALSE;
	bActivePartNumber:=0;
(*	lrProcessToolFeederActualPosition:=0.0;*)
	lrProcessToolFeederSpeed:=0.0;
	rSpeedToolFeed:=0.0;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_FctToolWorkingGroove
VAR_INPUT
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	xBeckhoffDriveActive: BOOL;	(* choice of the axis Beckhoff or EcoStep *)
	xSafetyCircuitOn:BOOL;			(* state of the safety circuit-->TRUE=Machine current ON, FALSE=Machine current OFF *)
	xDoNotMoveGrindPosition:BOOL;							(* TRUE=override the position of the GrindAxis with the ToolDiameter, FALSE=no overriding *)
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram data structure for the process parameter *)
	T_Standard:ST_RETAIN_DATA;							(* Novram data structure for the standard process parameter *)
END_VAR
VAR_IN_OUT
	xStart : BOOL;					(* start the function *)
	xReset : BOOL;				(* reset the function *)
	xStop : BOOL;					(* stop the active function *)
	xQuitErr : BOOL;				(* quit the error caused of the active function *)
	xAbord : BOOL;				(* abord the active function *)
	TAxisToolLeft:ST_AXIS;		(* data structure for the ToolLeft axis *)
	TAxisToolCenter:ST_AXIS;		(* data structure for the ToolCenter axis *)
	TAxisToolRight:ST_AXIS;		(* data structure for the ToolRight axis *)
	TAxisToolFeeder:ST_AXIS;		(* data structure for the ToolFeeder axis *)
	TAxisGrindFeeder:ST_AXIS;	(* data structure for the GrindFeeder axis *)
	T_WorkTool:ST_WORKTOOL;	(* Tool parameter *)
	(* KFS 03.09.2010* { *)
	rStartPosAutoGrooveToolRotation:REAL;
	(* KFS 03.09.2010* { *)
END_VAR
VAR_OUTPUT
	xEnd : BOOL;					(* state of the function if a active function is ended *)
	xError : BOOL;					(* state of the function if a active function caused an error *)
	iErrorNr : INT;					(* state of the function if a active function caused an error, in this case give the error number *)
	bActivePartNumber:BYTE;		(* gives the active number of the worked section of the geometry *)
	lrProcessToolFeederActualPosition:LREAL;	(* gives the calculated position of the ToolFeeder *)
	lrProcessToolFeederSpeed:LREAL;			(* gives the calculated speed of the ToolFeeder *)
END_VAR
VAR
	xHardwareError: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	iStepError: INT := 0;
	xStartMainCtr: BOOL := FALSE;
	xStartMainPrc: BOOL := FALSE;
	xInitMainCtr: BOOL := FALSE;
	iStepPrc: INT := 0;
	xSetEnd: BOOL := FALSE;
	xInitStep: BOOL := FALSE;
	xFreeze: BOOL := FALSE;
	iTmpErrorNr:INT:=0;
	xTmpInit:BOOL;
	iTmp:INT;
	xTmp: BOOL;
	xReadFirstTime: BOOL;
	xTmp1: BOOL;
	rToolRotationSpeed: REAL;
	FBToolCalcul:FB_TOOL_CALCUL_NEW;

	rToolFeedLength: REAL;
	rToolDiameter: REAL;
	rGrindFeedPlunge: REAL;
	ii: INT;
	iStartSection: INT;
	iEndSection: INT;
	rSpeedGrindFeed: REAL;
	rSpeedToolFeed: REAL;
	rTimeGrindPlunge: REAL;
	FBCalcGearFactor: FB_CALC_GEARFACTOR;
	lrToolFeederActualPosition: LREAL;
	iTmpStartSection: INT;
	FBCalcPlungeGrinding: FB_CALC_PLUNGE_GRINDING;
	xResetFB: BOOL;
	xGrindFeedMaster: BOOL;
	xCheckToolFeedPosition: BOOL;
	lrToolFeederPosition: LREAL;
	lrToolRightPosition: LREAL;
	lrSaveToolFeederPosition: LREAL;
	lrSaveToolRightPosition: LREAL;
	rPlungeCycleGrindFeedGeometry: REAL;
	lrToolFeedCalcLengthPosition: REAL;
	lrCalcToolLengthInc: LREAL;
	lrCalcToolLength: LREAL;
	xReadyToolFeedStop: BOOL;
	xReadyGrindFeedStop: BOOL;
	xCheckWithoutToolRotation: BOOL;
	lrSavePos: LREAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                    This Functionblock define the function for work a groove on the tool                                          ************)
(****************************************************************************************************************************************************)

IF NOT(xReadFirstTime) THEN
	xReadFirstTime:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Reset Function Part                                                 *****************************)
(******************************************************************************************************************************************)
IF xReset AND NOT(xSetEnd) THEN
	xEnd:=FALSE;
	xSetEnd:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Error Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
xTmp:=	TAxisToolLeft.T_CtrleSingle.xErr OR
		(TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
		TAxisToolRight.T_CtrleSingle.xErr OR
		TAxisToolFeeder.T_CtrleSingle.xErr OR
		TAxisGrindFeeder.T_CtrleSingle.xErr;
xTmp1:=	NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		 NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND
		((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND NOT(xMicroRodActive)) OR xMicroRodActive) AND
		NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute);
IF (xHardwareError OR (xTmp AND xStartMainPrc)) AND NOT(xSetEnd) THEN
	IF xTmp1 THEN
		IF NOT(xInitError) THEN
			iStepError:=100;
			xInitError:=TRUE;
			IF xHardwareError THEN
				iErrorNr:=iTmpErrorNr;
			ELSE
				xHardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStepError OF
			100:	iStepError:=0;
				xError:=TRUE;
		END_CASE;
		IF xQuitErr THEN
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Main Controlling Part                                            *****************************)
(******************************************************************************************************************************************)
IF (xStart OR xStartMainCtr) AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	IF NOT (xInitMainCtr) THEN
		iTmpErrorNr:=0;
		iStepPrc:=100;
		xInitMainCtr:=TRUE;
		xStartMainCtr:=TRUE;
		xStart:=FALSE;
		xEnd:=FALSE;
		xAbord:=FALSE;
		xTmpInit:=FALSE;
		xCheckToolFeedPosition:=FALSE;
		xCheckWithoutToolRotation:=FALSE;
		bActivePartNumber:=0;
		lrCalcToolLengthInc:=lrCalcToolLength:=0.0;
		rSpeedToolFeed:=0.0;
	END_IF;
	IF xStop AND NOT(xTmpInit) THEN
		xTmpInit:=TRUE;
		iTmp:=100;
		RETURN;
	END_IF;
	IF xFreeze THEN
		IF xStart AND NOT(xAbord) THEN
			xFreeze:=FALSE;
			xStart:=FALSE;
		END_IF;
		IF xAbord THEN
			xAbord:=FALSE;
			xFreeze:=FALSE;
			xStart:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStartMainPrc) AND NOT(xSetEnd) THEN
		xStartMainPrc:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************		               Controlling of the ToolFeeder Position                            *****************************)
(******************************************************************************************************************************************)
IF xCheckToolFeedPosition THEN
	IF xMicroRodActive THEN
		lrToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo - lrSaveToolFeederPosition;
		lrToolFeederActualPosition:=(lrToolFeederPosition / TAxisToolFeeder.T_CtrleSingle.lrScaleFactor);
		lrCalcToolLength:=lrToolFeederActualPosition;
	END_IF;
	IF NOT(xMicroRodActive) AND (TAxisToolRight.T_CtrleSingle.lrGearRatio <> 0.0) THEN
		IF NOT(xCheckWithoutToolRotation) THEN
			lrToolFeedCalcLengthPosition:=((((T_WorkTool.rToolLength * 10.0) / ABS(T_WorkTool.rPitch)) * 24000.0) / TAxisToolRight.T_CtrleSingle.lrScaleFactor);
			lrToolFeederPosition:=lrToolFeederPosition + ABS(ABS(TAxisToolRight.T_LiveValue.lrActualPosition) - (lrSaveToolFeederPosition / TAxisToolRight.T_CtrleSingle.lrScaleFactor));
			lrSaveToolFeederPosition:=ABS(TAxisToolRight.T_LiveValue.lrActualPositionNotModulo);
			lrToolFeederActualPosition:=((T_WorkTool.rToolLength * 10.0) / lrToolFeedCalcLengthPosition) * lrToolFeederPosition;
			lrCalcToolLength:=lrCalcToolLengthInc + lrToolFeederActualPosition;
		ELSE
			lrCalcToolLength:=ABS(TAxisToolFeeder.T_LiveValue.lrActualPosition);
		END_IF;
	END_IF;
ELSE
	xCheckWithoutToolRotation:=FALSE;
	IF NOT(xMicroRodActive) AND (TAxisToolRight.T_CtrleSingle.lrGearRatio <> 0.0) THEN
		lrSaveToolFeederPosition:=ABS(TAxisToolRight.T_LiveValue.lrActualPositionNotModulo);
		lrSaveToolRightPosition:=TAxisToolRight.T_LiveValue.lrActualPositionNotModulo * TAxisToolRight.T_CtrleSingle.lrGearRatio;
		lrCalcToolLengthInc:=lrCalcToolLength;
	END_IF;
	IF xMicroRodActive THEN
		lrSaveToolFeederPosition:=TAxisToolFeeder.T_LiveValue.lrActualPositionNotModulo;
	END_IF;
	lrToolFeederActualPosition:=lrToolFeederPosition:=0.0;
END_IF;
lrProcessToolFeederActualPosition:=lrCalcToolLength;
lrProcessToolFeederSpeed:=rSpeedToolFeed;
(******************************************************************************************************************************************)
(****************************				             immediate Stop Part                                              *****************************)
(******************************************************************************************************************************************)
IF xTmpInit AND NOT(xSetEnd) THEN
	IF NOT(xSafetyCircuitOn) THEN
		xTmpInit:=FALSE;
		iTmp:=100;
		xSetEnd:=TRUE;
		RETURN;
	END_IF;
	CASE iTmp OF
		100:	xReadyToolFeedStop:=xReadyGrindFeedStop:=FALSE;
			TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
			TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
			TAxisGrindFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
			TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			iTmp:=200;
			RETURN;
		200:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				iTmp:=300;
			END_IF;
			RETURN;
		300:	IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone AND NOT(xReadyGrindFeedStop) THEN
				xReadyGrindFeedStop:=TRUE;
			END_IF;
			IF (TAxisGrindFeeder.T_LiveValue.lrActualPosition >= (T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess)) AND NOT(xReadyToolFeedStop) THEN
				xReadyToolFeedStop:=TRUE;
				xCheckToolFeedPosition:=FALSE;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
						TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
						TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
						TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					FBCalcGearFactor(	rSpeed:= 0.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0;
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
				lrProcessToolFeederSpeed:=0.0;
			END_IF;
			IF xReadyToolFeedStop AND xReadyGrindFeedStop THEN
				iTmp:=400;
			END_IF;
			RETURN;
		400:	IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				iTmp:=500;
			END_IF;
			RETURN;
		500:	xTmpInit:=FALSE;
			iTmp:=100;
			xSetEnd:=TRUE;
			RETURN;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				             Main Procedure Part                                             *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) AND NOT(xHardwareError) THEN
	CASE iStepPrc OF
		(* Initial Procedure *)
		100:	rToolFeedLength:=0.0;
			rToolDiameter:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
			rGrindFeedPlunge:=0.0;
			rSpeedGrindFeed:=0.0;
			rSpeedToolFeed:=0.0;
			iStartSection:=1;
			(* Check Start and End Section of the ToolGeometry *)
			FOR ii:=1 TO 4 DO
				IF T_ProcessImageData.T_GeometryPara.axActiveSection[ii] THEN
					IF (iStartSection = 0) THEN
						iStartSection:=ii;
					END_IF;
					iEndSection:=ii;
				END_IF;
			END_FOR;
			xResetFB:=TRUE;
			FBCalcPlungeGrinding(	rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
									rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
									xReset:= xResetFB);
			(* AutoGroove is not aloved to work in more cycle *)
			rPlungeCycleGrindFeedGeometry:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
			xStartMainPrc:=FALSE;
			xInitStep:=FALSE;
(*08.09.2010: KFS	{ *)
(*			iStepPrc:=200;*)
			iStepPrc:=120;
		(* Switch the Axis as Slave for Move ToolRotation to StartPositionGroove*)
		120:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF rStartPosAutoGrooveToolRotation<> 0 THEN
					IF NOT(TAxisToolCenter.T_CtrleSingle.xSlave) THEN
						TAxisToolCenter.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
						TAxisToolCenter.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(T_WorkTool.iBaseGearDivider) /
																				(TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																				TAxisToolCenter.T_CtrleSingle.lrGearRatio) ) * -1.0;
						TAxisToolCenter.T_CtrleSingle.iFunction:=25;
						TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(TAxisToolRight.T_CtrleSingle.xSlave) THEN
						TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
						TAxisToolRight.T_CtrleSingle.lrGearFactor:=	INT_TO_LREAL(T_WorkTool.iBaseGearDivider) /
																				(TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																				TAxisToolRight.T_CtrleSingle.lrGearRatio);
						TAxisToolRight.T_CtrleSingle.iFunction:=25;
						TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone  AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone  THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=150;
			END_IF
		(*Rotate Tool to the StartPositionGroove*)
		150:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF rStartPosAutoGrooveToolRotation<> 0 THEN
					lrSavePos:=TAxisToolLeft.T_LiveValue.lrActualPositionRelativ;
					TAxisToolLeft.T_CtrleSingle.lrDistance:= rStartPosAutoGrooveToolRotation;
					TAxisToolLeft.T_CtrleSingle.lrVelocity:=T_WorkTool.rToolRotationSpeed;
					TAxisToolLeft.T_CtrleSingle.iFunction:=8;
					TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisToolLeft.T_CtrleSingle.xExecute) AND TAxisToolLeft.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=200;
			END_IF;
(*08.09.2010: KFS	} *)
		(* Calculation first only for the Plunge Procedure *)
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB);
			END_IF;
			IF xInitStep THEN
				bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF xDoNotMoveGrindPosition THEN
					iStepPrc:=500;
				ELSE
					iStepPrc:=300;
				END_IF;
			END_IF;
		(* start with the plunge procedure *)
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				rToolFeedLength:=0.0;
				rSpeedToolFeed:=0.0;
				IF T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove THEN
					rToolFeedLength:=T_ProcessImageData.T_AutoGroovePara.rPlungeLengthToolFeedGroove;
					T_WorkTool.rToolLength:=rToolFeedLength/10.0;
				ELSE
					T_WorkTool.rToolLength:=0.0;
				END_IF;
				IF T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove THEN
					T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
					T_WorkTool.rPitch:=T_ProcessImageData.T_AutoGroovePara.rPitchGroove * -1.0;
					T_WorkTool.rGrindFeederPlunge:=	FBCalcPlungeGrinding.rGrindingRelativePosition;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
									xBeckhoffDriveActive:=FALSE,
									T_WorkTool:= T_WorkTool,
									rToolFeedAcclDecl:= T_Standard.T_TeachINToolFeeder.rAcceleration);
					rGrindFeedPlunge:=T_WorkTool.rGrindFeederPlunge * -1.0;
					rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
				ELSE
					rSpeedGrindFeed:=T_ProcessImageData.T_AutoGroovePara.rPlungeSpeedGrindFeedGroove;
					rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
					IF (rToolFeedLength <> 0) THEN
						rTimeGrindPlunge:=ABS(rGrindFeedPlunge) / rSpeedGrindFeed;		(* calc Time in seocnds *)
						rSpeedToolFeed:=rToolFeedLength / rTimeGrindPlunge;	(* calc Speed ToolFeed in mm/s *)
					END_IF;
					T_WorkTool.rPitch:=T_ProcessImageData.T_AutoGroovePara.rPitchGroove * -1.0;
				END_IF;
				rToolRotationSpeed:=T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
				(* Start Relative movement of the GrindAxis *)
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				IF (rToolFeedLength <> 0) THEN
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
					xCheckWithoutToolRotation:=TRUE;
					(* Start continuos movement of the ToolFeeder Axis *)
					TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
					TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
					TAxisToolFeeder.T_CtrleSingle.lrVelocity:=rSpeedToolFeed;
					TAxisToolFeeder.T_CtrleSingle.iFunction:=6;	(* Move continue velocity *)
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xCheckToolFeedPosition:=FALSE;
				xCheckWithoutToolRotation:=FALSE;
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (rToolFeedLength <> 0) THEN
					iStepPrc:=400;
				ELSE
					iStepPrc:=600;
				END_IF;
			END_IF;
		(* Stop the movement of the ToolFeeder *)
		400:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				TAxisToolFeeder.T_CtrleSingle.iFunction:=5;	(* Stop Movement *)
				TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				 iStepPrc:=600;
			END_IF;
		(* Override the Position of the GrindFeeder Axis with the Diameter of the first working section *)
		500:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=T_ProcessImageData.T_GeometryPara.arStartDiameter[iStartSection];
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=11;
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
			END_IF;
		(* Switch the Axis as Slave *)
		600:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB);
				(* Check first active section *)
				bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
				iTmpStartSection:=iStartSection + (FBCalcPlungeGrinding.iStepSectionWork - 1);
				T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
				T_WorkTool.rPitch:=T_ProcessImageData.T_AutoGroovePara.rPitchGroove * -1.0;
				T_WorkTool.rToolLength:=T_ProcessImageData.T_GeometryPara.arSectionLength[iTmpStartSection];
				rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
				T_WorkTool.rGrindFeederPlunge:=rGrindFeedPlunge;
				FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
								xBeckhoffDriveActive:=FALSE,
								T_WorkTool:= T_WorkTool,
								rToolFeedAcclDecl:= 0.0	);
				rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
				rToolFeedLength:=T_WorkTool.rToolLength;
				rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
				rToolRotationSpeed:=T_WorkTool.rToolRotationSpeed;
				IF xMicroRodActive THEN
					IF NOT(TAxisToolCenter.T_CtrleSingle.xSlave) THEN
						TAxisToolCenter.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
						TAxisToolCenter.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(T_WorkTool.iBaseGearDivider) /
																				(TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																				TAxisToolCenter.T_CtrleSingle.lrGearRatio) ) * -1.0;
						TAxisToolCenter.T_CtrleSingle.iFunction:=25;
						TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
					IF NOT(TAxisToolRight.T_CtrleSingle.xSlave) THEN
						TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
						TAxisToolRight.T_CtrleSingle.lrGearFactor:=	INT_TO_LREAL(T_WorkTool.iBaseGearDivider) /
																				(TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																				TAxisToolRight.T_CtrleSingle.lrGearRatio);
						TAxisToolRight.T_CtrleSingle.iFunction:=25;
						TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT xMicroRodActive THEN
					IF NOT(TAxisToolRight.T_CtrleSingle.xSlave) THEN
						TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
						TAxisToolRight.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_WorkTool.iBaseGearDivider) /
																				(TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																				TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;
						TAxisToolRight.T_CtrleSingle.iFunction:=25;
						TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(TAxisToolFeeder.T_CtrleSingle.xSlave) THEN
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(T_WorkTool.iToolFeederGearFactor) * -1.0);
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
					TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF ((NOT(TAxisToolCenter.T_CtrleSingle.xExecute) AND TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(TAxisToolRight.T_CtrleSingle.xExecute) AND TAxisToolRight.T_CtrleSingle.xDone AND
			    ((NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=700;
			END_IF;
		(* Start ToolRotation and the ToolFeeder as Slave from the ToolRotation and the Grinding if it work a cone Section *)
		700:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* Start ToolRotation *)
				TAxisToolLeft.T_CtrleSingle.lrVelocity:=T_WorkTool.rToolRotationSpeed;
				TAxisToolLeft.T_CtrleSingle.iFunction:=6;
				TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
				(*Check if it work a Cone section*)
				IF (rGrindFeedPlunge <> 0) THEN
					xGrindFeedMaster:=TRUE;
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
					IF (TAxisGrindFeeder.T_CtrleSingle.iFunction <> 11) THEN
						TAxisGrindFeeder.T_CtrleSingle.xBlockAcclDeclParameter:=TRUE;	(* do not send again the accl and decl parameter-->better performance *)
					END_IF;
					TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
					TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					xGrindFeedMaster:=FALSE;
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
				END_IF;
			END_IF;
			IF xGrindFeedMaster THEN
				(* This is active by work a cone section *)
				IF (NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone) THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=800;
				END_IF;
			END_IF;
			IF NOT(xGrindFeedMaster) THEN
				(* This is only active if it is work a cylinder section *)
				IF (lrToolFeederActualPosition > (rToolFeedLength * 10.0)) THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=800;
				END_IF;
			END_IF;
		(* Init the next Section *)
		800:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				FBCalcPlungeGrinding(	T_Geometry:= T_ProcessImageData.T_GeometryPara,
										T_AutoGeometryPara:= T_ProcessImageData.T_AutoGeometryPara,
										rToolDiameter:= T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
										rToolDiameterWithOffset:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess + T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
										rPlungeCycleGrindFeedGeometry:=rPlungeCycleGrindFeedGeometry,
										iStartSection:= iStartSection,
										iEndSection:= iEndSection,
										xReset:= xResetFB);
				(* Check first active section *)
				bActivePartNumber:=INT_TO_BYTE(FBCalcPlungeGrinding.iStepSectionWork);
				iTmpStartSection:=iStartSection + (FBCalcPlungeGrinding.iStepSectionWork - 1);
				T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
				T_WorkTool.rPitch:=T_ProcessImageData.T_AutoGroovePara.rPitchGroove * -1.0;
				T_WorkTool.rToolLength:=T_ProcessImageData.T_GeometryPara.arSectionLength[iTmpStartSection];
				rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
				T_WorkTool.rGrindFeederPlunge:=rGrindFeedPlunge;
				FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
								xBeckhoffDriveActive:=FALSE,
								T_WorkTool:= T_WorkTool,
								rToolFeedAcclDecl:= 0.0	);
				rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
				rToolFeedLength:=T_WorkTool.rToolLength;
				rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit;
				rToolRotationSpeed:=T_WorkTool.rToolRotationSpeed;
			END_IF;
			IF xInitStep THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				IF (FBCalcPlungeGrinding.iStepSectionWork <> 5) THEN
					iStepPrc:=900;	(* Work the Geometry Section *)
				ELSE
					iStepPrc:=1000;	(* Work the Displace Procedure *)
				END_IF;
			END_IF;
		(* Work the next Section *)
		900:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(*Check if it work a Cone section*)
				IF (rGrindFeedPlunge <> 0) THEN
					xGrindFeedMaster:=TRUE;
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
					TAxisGrindFeeder.T_CtrleSingle.xBlockAcclDeclParameter:=TRUE;	(* do not send again the accl and decl parameter-->better performance *)
					TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
					TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
					TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
					TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
					TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					xGrindFeedMaster:=FALSE;
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
					IF NOT(xMicroRodActive) THEN
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=INT_TO_LREAL(T_WorkTool.iToolFeederGearFactor) * -1.0;
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iToolFeederGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					END_IF;
				END_IF;
			END_IF;
			IF xGrindFeedMaster THEN
				(* This is active by work a cone section *)
				IF (NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone) THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=800;
				END_IF;
			END_IF;
			IF NOT(xGrindFeedMaster) THEN
				(* This is only active if it is work a cylinder section *)
				IF (lrToolFeederActualPosition > (rToolFeedLength * 10.0)) THEN
					xCheckToolFeedPosition:=FALSE;
					xStartMainPrc:=FALSE;
					xInitStep:=FALSE;
					iStepPrc:=800;
				END_IF;
			END_IF;
		(* start with the displace procedure *)
		1000:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				rToolFeedLength:=0.0;
				rSpeedToolFeed:=0.0;
				IF T_ProcessImageData.T_AutoGroovePara.xDisplaceActivationGroove THEN
					rToolFeedLength:=T_ProcessImageData.T_AutoGroovePara.rDisplaceLengthToolFeedGroove;
					T_WorkTool.rToolLength:=rToolFeedLength/10.0;
				ELSE
					T_WorkTool.rToolLength:=0.0;
				END_IF;
				IF T_ProcessImageData.T_AutoGroovePara.xDisplaceActivationGroove THEN
					T_WorkTool.rToolRotationSpeed:=T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
					T_WorkTool.rPitch:=T_ProcessImageData.T_AutoGroovePara.rPitchGroove * -1.0;
					T_WorkTool.rGrindFeederPlunge:=	FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
					FBToolCalcul(	xMicroRodActive:=xMicroRodActive,
								  	xBeckhoffDriveActive:=FALSE,
								  	T_WorkTool:= T_WorkTool,
								  	rToolFeedAcclDecl:= T_Standard.T_TeachINToolFeeder.rDeceleration	);
					rGrindFeedPlunge:=T_WorkTool.rGrindFeederPlunge;
					rSpeedGrindFeed:=T_WorkTool.rGrindFeederSpeedUnit;
					rSpeedToolFeed:=T_WorkTool.rToolFeederSpeedUnit * -1.0;
				ELSE
					rSpeedGrindFeed:=T_ProcessImageData.T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove;
					rGrindFeedPlunge:=FBCalcPlungeGrinding.rGrindingRelativePosition * -1.0;
					IF (rToolFeedLength <> 0) THEN
						rTimeGrindPlunge:=ABS(rGrindFeedPlunge) / rSpeedGrindFeed;		(* calc Time in seocnds *)
						rSpeedToolFeed:=(rToolFeedLength * 10.0) / rTimeGrindPlunge;	(* calc Speed ToolFeed in mm/s *)
					END_IF;
					T_WorkTool.rPitch:=T_ProcessImageData.T_AutoGroovePara.rPitchGroove * -1.0;
				END_IF;
				rToolRotationSpeed:=T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
				(* Start Relative movement of the GrindAxis *)
				TAxisGrindFeeder.T_CtrleSingle.xBlockAcclDeclParameter:=TRUE;	(* do not send again the accl and decl parameter-->better performance *)
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDistance:=rGrindFeedPlunge;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=rSpeedGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=8;	(* Move Relative *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				IF (rToolFeedLength = 0) THEN
				(* Stop ToolFeeder Movement *)
					IF xMicroRodActive THEN
						IF TAxisToolFeeder.T_CtrleSingle.xSlave THEN
							TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(T_WorkTool.iBaseGearDivider) * -1.0);
							TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
							(* Set Gear Value with PDO Object *)
							TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=(LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor) * -1);
							TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
							TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
							TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
						END_IF;
					END_IF;
					IF NOT(xMicroRodActive) THEN
						FBCalcGearFactor(	rSpeed:= 0.0,
											rToolRotationSpeed:= rToolRotationSpeed,
											T_WorkTool:=T_WorkTool );
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0);
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
					END_IF;
				ELSE
					xCheckToolFeedPosition:=TRUE;	(* Start Measure Relative Position of the ToolFeeder *)
				END_IF;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=1100;
			END_IF;
		(* Check if ToolFeeder Moves and stop it if it moves *)
		1100:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xCheckToolFeedPosition:=FALSE;
				IF xMicroRodActive THEN
					IF TAxisToolFeeder.T_CtrleSingle.xSlave THEN
						TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(T_WorkTool.iBaseGearDivider) * -1.0);
						TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_WorkTool.iBaseGearDivider);
						(* Set Gear Value with PDO Object *)
						TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=(LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor) * -1);
						TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
						TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
						TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					FBCalcGearFactor(	rSpeed:= 0.0,
										rToolRotationSpeed:= rToolRotationSpeed,
										T_WorkTool:=T_WorkTool );
					TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=(INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearFactor) * -1.0);
					TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(FBCalcGearFactor.T_WorkTool.iToolFeederGearDivider);
					(* Set Gear Value with PDO Object *)
					TAxisToolFeeder.T_RxPdoParameter.iGearFactor:=LREAL_TO_INT(TAxisToolFeeder.T_CtrleSingle.lrGearFactor);
					TAxisToolFeeder.T_RxPdoParameter.uiGearDivider:=LREAL_TO_UINT(TAxisToolFeeder.T_CtrleSingle.lrGearDivider);
				END_IF;
			END_IF;
			IF NOT(TAxisToolFeeder.T_CtrleSingle.xExecute) AND TAxisToolFeeder.T_CtrleSingle.xDone THEN
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=1200;
			END_IF;
		(* GrindFeeder go to Security Position *)
		1200:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				TAxisGrindFeeder.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				TAxisGrindFeeder.T_CtrleSingle.lrPosition:=	T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				TAxisGrindFeeder.T_CtrleSingle.lrVelocity:=T_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed;
				TAxisGrindFeeder.T_CtrleSingle.iFunction:=7;	(* Move Absolut *)
				TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(TAxisGrindFeeder.T_CtrleSingle.xExecute) AND TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* Procedure is finished *)
				xStartMainPrc:=FALSE;
				xInitStep:=FALSE;
				iStepPrc:=0;
				xSetEnd:=TRUE;
			END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				           Parallel Procedure Part                                          *****************************)
(******************************************************************************************************************************************)
(******************************************************************************************************************************************)
(****************************				             	Init / Reset Part                                                   *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xEnd:=TRUE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xStop:=FALSE;
	xStartMainPrc:=FALSE;
	xInitMainCtr:=FALSE;
	xStartMainCtr:=FALSE;
	xStart:=FALSE;
	xHardwareError:=FALSE;
	xQuitErr:=FALSE;
	xError:=FALSE;
	iErrorNr:=0;
	xInitError:=FALSE;
	xFreeze:=FALSE;
	xAbord:=FALSE;
	xReset:=FALSE;
	xCheckToolFeedPosition:=FALSE;
	bActivePartNumber:=0;
(*	lrProcessToolFeederActualPosition:=0.0;*)
	lrProcessToolFeederSpeed:=0.0;
	rSpeedToolFeed:=0.0;
	xCheckWithoutToolRotation:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3\/FB_STATIONEN\/FB_FUNCTION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_STATION
VAR_INPUT
	iConfigMachineType:INT;
	iConfigAxisType:INT;
	iConfigVisuNavigation:INT;
	rConfigMaxToolLength:REAL;
	xSafetyCircuitOn1:BOOL;
	xSafetyCircuitOn2:BOOL;
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;
	T_Standard:ST_RETAIN_DATA;
	xActiveProcess:BOOL;
	iSelectToolTensionForce:INT;
END_VAR
VAR_IN_OUT
	TStation:ST_STATION;
	T_StartUp:ST_STARTUP;
END_VAR
VAR_OUTPUT
	xActive : BOOL :=FALSE;
	xStatusRdy : BOOL := FALSE;
	xStatusEnd : BOOL := FALSE;
	xStatusStop : BOOL := FALSE;
	xStatusRef : BOOL := FALSE;
	xError : BOOL := FALSE;
	iErrorNr : DINT :=0;
	iStatusFctNr : INT := 0;
	bActivePartNumber:BYTE;
	lrProcessToolFeederActualPosition:LREAL;
	lrProcessToolFeederSpeed:LREAL;
END_VAR
VAR
(* Pointer auf Actuatoren *)
	ptrTAxisToolLeft:POINTER TO ST_AXIS;
	ptrTAxisToolCenter:POINTER TO ST_AXIS;
	ptrTAxisToolRight:POINTER TO ST_AXIS;
	ptrTAxisToolFeeder:POINTER TO ST_AXIS;
	ptrTAxisGrindFeeder:POINTER TO ST_AXIS;
	ptrTCylToolTension:POINTER TO ST_CYLINDER;
(*22.12.2009: KFS {    *)
	ptrTCylToolLeftActive:POINTER TO ST_CYLINDER;
	ptrTCylToolRightActive:POINTER TO ST_CYLINDER;
	ptrTCylToolCenterActive:POINTER TO ST_CYLINDER;
	ptrTCylToolPrismaLeftActive:POINTER TO ST_CYLINDER;
	ptrTCylToolPrismaRightActive:POINTER TO ST_CYLINDER;
	ptrTToolFeederWorkLength:POINTER TO ST_CYLINDER;
(*22.12.2009: KFS }   *)
	ptrTFunction:POINTER TO ST_CTRL_FUNCTION;
	xSetEnableConfig: BOOL;
	iEnableConfigMachineType:INT;
	iTmpConfigMachineType:INT;
	iEnableConfigAxisType:INT;
	iTmpConfigAxisType:INT;
	iEnableConfigVisuNavigation:INT;
	iTmpConfigVisuNavigation:INT;
	rEnableConfigMaxToolLength:REAL;
	rTmpConfigMaxToolLength:REAL;
	xMicroRodActive: BOOL;
	xBeckhoffDriveActive: BOOL;
	xTmpStopFunction: BOOL;
	iStationFunctionNr: INT;
	xStartFunction: BOOL := FALSE;
	xTmpStart: BOOL := FALSE;
	xInitStart: BOOL := FALSE;
	xSetEnd: BOOL := FALSE;
	xInitError: BOOL := FALSE;
	xInitStop: BOOL := FALSE;
	xInitSetEnable: BOOL := FALSE;
	iStepEnable: INT := 0;
	xInitStep: BOOL := FALSE;
	iAxisFunctionNr: INT :=0;
	xInitDelEnable: BOOL := FALSE;
	xStationError: BOOL := FALSE;
	xStepError: BOOL;
	iStepError: INT;
	xTmpStationError: BOOL;
	xRdyDisableStation: BOOL;
	xReadyChkError: BOOL;
	xDontDeleteErrorFlag: BOOL;
	xSetError: BOOL;
(* Trigger *)
	fbFTrig: F_TRIG;
	fbRTrig: R_TRIG;
	xTmp: BOOL;
	diErrorNumber: DINT;
	iCountCycle: INT;
	xSecurityCircuitOn: BOOL;
	xSecurityCircuitOff: BOOL;
	iStepSecCircuit: INT;
	xInitSecCircuit: BOOL;
	TONCheckTimeOut: TON;
	xPowerSwitchedOn: BOOL;
	xChkConfigStation: BOOL;
	FBFctToolRotationTorqueStart: FB_FctToolRotationTorqueStart;
	FBFctToolRotationTorqueStop: FB_FctToolRotationTorqueStop;
	FBFctGrindFeedAbsRelPosition: FB_FctGrindFeedAbsRelPosition;
	FBFctSetAxisPosition: FB_FctSetAxisPosition;
	FBFctToolWorkingGeometry: FB_FctToolWorkingGeometry;
	FBFctToolWorkingGeometryMultiCycle: FB_FctToolWorkingGeometryMultiCycle;
	FBFctToolWorkingGroove: FB_FctToolWorkingGroove;
	FBFctToolCalibration: FB_FctToolCalibration;
	iMaxFunctionNr:INT:=20;
	(* 17.11.2010 KFS : iMaxFunctionNr:INT:=19*)
	FBFctToolFeedAbsRelPosition: FB_FctToolFeedAbsRelPosition;
	FBFctSwitchOnOffPowerSupply: FB_FctSwitchOnOffPowerSupply;
	(* 17.11.2010: KFS 	{	*)
	FBFctToolFeedMaxLenReference:FB_FctToolFeedMaxLenReference;
	(* 17.11.2010: KFS 	}	*)
	FBFctToolFeedReference: FB_FctToolFeedReference;
	xCheckAxisError: BOOL;
	xFirstTimeBooting: BOOL:=FALSE;
	FBFctStopAxisMovement: FB_FctStopAxisMovement;
	xAxisErrorActive: BOOL;
	xWaitSetError: BOOL;
	TONWaitSetError: TON;
	xForceHWError: BOOL;
	xCheckActiveFunction: BOOL;
	xForceResetAxis: BOOL;
	xReadyToQuitErr: BOOL;
	TONWaitReset: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                 This Functionblock manage all the station funtion and synchronizing of the Hardware                           ************)
(****************************************************************************************************************************************************)
xActive:=TStation.TControl.xActiveStation;
IF NOT(TStation.TControl.xActiveStation) THEN
	(*TStation:=TDeleteStationStruct;*)
	RETURN;
ELSE
	IF xSetEnableConfig THEN
		IF (iEnableConfigMachineType <> iConfigMachineType) THEN
			iTmpConfigMachineType:=iEnableConfigMachineType;
		ELSE
			iTmpConfigMachineType:=iConfigMachineType;
		END_IF;
		IF (iEnableConfigAxisType <> iConfigAxisType) THEN
			iTmpConfigAxisType:=iEnableConfigAxisType;
		ELSE
			iTmpConfigAxisType:=iConfigAxisType;
		END_IF;
		IF (iEnableConfigVisuNavigation <> iConfigVisuNavigation) THEN
			iTmpConfigVisuNavigation:=iEnableConfigVisuNavigation;
		ELSE
			iTmpConfigVisuNavigation:=iConfigVisuNavigation;
		END_IF;
		IF (rEnableConfigMaxToolLength <> rConfigMaxToolLength) THEN
			rTmpConfigMaxToolLength:=rEnableConfigMaxToolLength;
		ELSE
			rTmpConfigMaxToolLength:=rConfigMaxToolLength;
		END_IF;
		(*08.12.2010 KFS:	{	*)
		IF T_Station.xOverwriteMaxToolLength THEN
			rEnableConfigMaxToolLength:=rConfigMaxToolLength;
			rTmpConfigMaxToolLength:=rConfigMaxToolLength;
		END_IF;
		(*08.12.2010 KFS:	}	*)
	ELSE
		iTmpConfigMachineType:=iConfigMachineType;
		iTmpConfigAxisType:=iConfigAxisType;
		iTmpConfigVisuNavigation:=iConfigVisuNavigation;
		rTmpConfigMaxToolLength:=rConfigMaxToolLength;
	END_IF;
	(* Zuweisung der Datenstrukturen der Aktuatoren als Pointer *)
	ptrTAxisToolLeft:=ADR(TStation.THardware.TAxisToolLeft);
	ptrTAxisToolCenter:=ADR(TStation.THardware.TAxisToolCenter);
	ptrTAxisToolRight:=ADR(TStation.THardware.TAxisToolRight);
	ptrTAxisToolFeeder:=ADR(TStation.THardware.TAxisToolFeeder);
	ptrTAxisGrindFeeder:=ADR(TStation.THardware.TAxisGrindFeeder);
	ptrTCylToolTension:=ADR(TStation.THardware.TCylToolTension);
(*22.12.2009: KFS {    *)
	ptrTCylToolLeftActive:=ADR(TStation.THardware.TCylToolLeftActive);
	ptrTCylToolRightActive:=ADR(TStation.THardware.TCylToolRightActive);
	ptrTCylToolCenterActive:=ADR(TStation.THardware.TCylToolCenterActive);
	ptrTCylToolPrismaLeftActive:=ADR(TStation.THardware.TCylToolPrismaLeftActive);
	ptrTCylToolPrismaRightActive:=ADR(TStation.THardware.TCylToolPrismaRightActive);
	ptrTToolFeederWorkLength:=ADR(TStation.THardware.TToolFeederWorkLength);
(*22.12.2009: KFS }   *)
	ptrTFunction:=ADR(TStation.TCtrlFunction);
	IF (iConfigMachineType = 2) THEN
		xMicroRodActive:=TRUE;
	ELSE
		xMicroRodActive:=FALSE;
	END_IF;
	IF (iConfigAxisType = 2) THEN
		xBeckhoffDriveActive:=TRUE;
	ELSE
		xBeckhoffDriveActive:=FALSE;
	END_IF;
	IF xSafetyCircuitOn1 AND xSafetyCircuitOn2 THEN
		xPowerSwitchedOn:=TRUE;
	ELSE
		xPowerSwitchedOn:=FALSE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				                  Status Part                                                            *****************************)
(******************************************************************************************************************************************)
xStatusRdy:=TStation.TControl.xRdy;
xStatusEnd:=TStation.TControl.xEnd;
xStatusStop:=xTmpStopFunction;
IF xMicroRodActive THEN
	TStation.TControl.xReferenced:=ptrTAxisToolFeeder^.T_CtrleSingle.xRef;
ELSE
	TStation.TControl.xReferenced:=TRUE;
END_IF;
xStatusRef:=TStation.TControl.xReferenced;
xError:= TStation.TControl.xError;
iErrorNr := TStation.TControl.diErrorNr;
iStatusFctNr:=iStationFunctionNr;
(******************************************************************************************************************************************)
(****************************				                Enable Part                                                            *****************************)
(******************************************************************************************************************************************)
(* Check Active of the Axis Drives *)
xTmp:=	(NOT(ptrTAxisToolLeft^.T_CtrleSingle.xErr) AND NOT(ptrTAxisToolLeft^.T_CtrleSingle.xDone)) OR
		(NOT(ptrTAxisToolCenter^.T_CtrleSingle.xErr) AND NOT(ptrTAxisToolCenter^.T_CtrleSingle.xDone) AND xMicroRodActive) OR
		(NOT(ptrTAxisToolRight^.T_CtrleSingle.xErr) AND NOT(ptrTAxisToolRight^.T_CtrleSingle.xDone)) OR
		(NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xErr) AND NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xDone)) OR
		(NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xErr) AND NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xDone));
fbFTrig(CLK:=TStation.TControl.xEnable);
IF fbFTrig.Q THEN
	xInitSetEnable:=FALSE;
	xInitDelEnable:=FALSE;
	xRdyDisableStation:=FALSE;
END_IF;
IF (fbFTrig.Q OR xInitDelEnable) THEN
	IF NOT(xInitDelEnable) OR fbFTrig.Q THEN
		xReadyChkError:=FALSE;
		TStation.TControl.xEnd:=FALSE;
		IF NOT(xDontDeleteErrorFlag) THEN
			TStation.TControl.xError:=FALSE;
		END_IF;
		xInitDelEnable:=TRUE;
		TStation.TControl.xRdy:=FALSE;
		iStepEnable:=100;
		iAxisFunctionNr:=1;
		iStationFunctionNr:=1;
		xInitStep:=FALSE;
	END_IF;
	CASE iStepEnable OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xSetEnableConfig:=FALSE;
				xStartFunction:=TRUE;
				ptrTFunction^.xReset:=TRUE;
			END_IF;
			IF NOT(ptrTFunction^.xReset) AND ptrTFunction^.xEnd THEN
				(* Alle Funktionen Resetten *)
				IF (iStationFunctionNr < iMaxFunctionNr) THEN
					iStationFunctionNr:=iStationFunctionNr + 1;
					ptrTFunction^.xReset:=TRUE;
				ELSE
					xInitStep:=FALSE;
					xStartFunction:=FALSE;
					iStepEnable:=200;
				END_IF;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF TStation.TControl.xHardwareConfigError THEN
					TStation.TControl.xHardwareConfigError:=FALSE;
					TStation.TControl.xActiveHardware:=FALSE;
				ELSE
					xInitStep:=FALSE;
					iStepEnable:=300;
				END_IF;
				RETURN;
			END_IF;
			IF NOT(TStation.TControl.xError) OR xDontDeleteErrorFlag THEN
				TStation.TControl.xActiveHardware:=TRUE;
				xInitStep:=FALSE;
				iStepEnable:=300;
				RETURN;
			END_IF;
		300:	IF NOT(xInitStep) THEN	(* Alle Hardware Bausteine resetten *)
				xInitStep:=TRUE;
				ptrTCylToolTension^.T_CtrleCyl.xFBActiv:=FALSE;
				(*22.12.2009: KFS {    *)
				IF xMicroRodActive THEN
					ptrTCylToolLeftActive^.T_CtrleCyl.xFBActiv:=FALSE;
					ptrTCylToolRightActive^.T_CtrleCyl.xFBActiv:=FALSE;
					ptrTCylToolCenterActive^.T_CtrleCyl.xFBActiv:=FALSE;
					ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xFBActiv:=FALSE;
					ptrTCylToolPrismaRightActive^.T_CtrleCyl.xFBActiv:=FALSE;
					ptrTToolFeederWorkLength^.T_CtrleCyl.xFBActiv:=FALSE;
				END_IF;
				(*22.12.2009: KFS }   *)
				IF xBeckhoffDriveActive THEN
					ptrTAxisToolLeft^.T_CtrleSingle.xReset:=TRUE;
					IF xMicroRodActive THEN
						ptrTAxisToolCenter^.T_CtrleSingle.xReset:=TRUE;
					END_IF;
					ptrTAxisToolRight^.T_CtrleSingle.xReset:=TRUE;
					ptrTAxisToolFeeder^.T_CtrleSingle.xReset:=TRUE;
					ptrTAxisGrindFeeder^.T_CtrleSingle.xReset:=TRUE;
				ELSE
					TStation.TControl.xResetHardware:=TRUE;
					iStepEnable:=399;
					RETURN;
				END_IF;
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF (NOT(ptrTAxisToolLeft^.T_CtrleSingle.xReset) AND ptrTAxisToolLeft^.T_CtrleSingle.xErr) OR
			    (((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xReset) AND ptrTAxisToolCenter^.T_CtrleSingle.xErr AND xMicroRodActive) OR NOT(xMicroRodActive))) OR
			    (NOT(ptrTAxisToolRight^.T_CtrleSingle.xReset) AND ptrTAxisToolRight^.T_CtrleSingle.xErr) OR
			    (NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xReset) AND ptrTAxisToolFeeder^.T_CtrleSingle.xErr)OR
			    (NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xReset) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xErr) THEN
				xInitStep:=FALSE;
				iStepEnable:=400;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xReset) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xReset) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xReset) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xReset) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xReset) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				TStation.TControl.xActiveHardware:=FALSE;
				xInitStep:=FALSE;
				xInitDelEnable:=FALSE;
				xSetEnd:=TRUE;
				xRdyDisableStation:=TRUE;
			END_IF;
		399:	IF NOT(TStation.TControl.xResetHardware) THEN
				TStation.TControl.xActiveHardware:=FALSE;
				xInitStep:=FALSE;
				xInitDelEnable:=FALSE;
				xSetEnd:=TRUE;
				xRdyDisableStation:=TRUE;
			END_IF;
		400:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=ptrTAxisToolLeft^.T_CtrleSingle.xErr;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=1;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=ptrTAxisToolCenter^.T_CtrleSingle.xErr;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=ptrTAxisToolRight^.T_CtrleSingle.xErr;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=ptrTAxisToolFeeder^.T_CtrleSingle.xErr;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=1;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=ptrTAxisGrindFeeder^.T_CtrleSingle.xErr;
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xErr AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xErr AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xErr AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xErr AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xErr THEN
				xInitStep:=FALSE;
				iStepEnable:=500;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				TStation.TControl.xActiveHardware:=FALSE;
				xInitStep:=FALSE;
				xInitDelEnable:=FALSE;
				xSetEnd:=TRUE;
				xRdyDisableStation:=TRUE;
			END_IF;
		500:	TStation.TControl.xActiveHardware:=FALSE;
			TStation.TControl.diErrorNr:=8000000 + 10;	(* Station Disable Fehlerhaft *)
			TStation.TControl.xError:=TRUE;
			xDontDeleteErrorFlag:=TRUE;
			xInitStep:=FALSE;
			xInitDelEnable:=FALSE;
			xSetEnd:=TRUE;
			xRdyDisableStation:=TRUE;
	END_CASE;
END_IF;
fbRTrig(CLK:=TStation.TControl.xEnable);
IF fbRTrig.Q THEN
	xInitSetEnable:=FALSE;
	xInitDelEnable:=FALSE;
END_IF;
IF (fbRTrig.Q OR xInitSetEnable) THEN
	IF NOT(fbRTrig.Q) AND xReadyChkError THEN
		IF xSetError OR ptrTAxisToolLeft^.T_CtrleSingle.xErr OR (ptrTAxisToolCenter^.T_CtrleSingle.xErr AND xMicroRodActive) OR
		     ptrTAxisToolRight^.T_CtrleSingle.xErr OR ptrTAxisToolFeeder^.T_CtrleSingle.xErr OR ptrTAxisGrindFeeder^.T_CtrleSingle.xErr THEN
			IF (xTmp OR (NOT(T_BoxID.T_Ctrle.xErr) AND NOT(T_BoxID.T_Ctrle.xDone))) AND NOT(xSetError) THEN
				RETURN;	(* Wait until all Actuators are not working *)
			END_IF;
			IF xSetError THEN
				xSetError:=FALSE;
				TStation.TControl.diErrorNr:=8000000 + diErrorNumber;
			ELSE
				ptrTAxisToolLeft^.T_CtrleSingle.xReset:=ptrTAxisToolLeft^.T_CtrleSingle.xErr;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.xReset:=ptrTAxisToolCenter^.T_CtrleSingle.xErr;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.xReset:=ptrTAxisToolRight^.T_CtrleSingle.xErr;
				ptrTAxisToolFeeder^.T_CtrleSingle.xReset:=ptrTAxisToolFeeder^.T_CtrleSingle.xErr;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xReset:=ptrTAxisGrindFeeder^.T_CtrleSingle.xErr;
				T_BoxID.T_Ctrle.xReset:=T_BoxID.T_Ctrle.xErr;
				IF ptrTAxisToolLeft^.T_CtrleSingle.xErr THEN TStation.TControl.diErrorNr:=1000000 + ptrTAxisToolLeft^.T_CtrleSingle.udiErrorID; END_IF;
				IF xMicroRodActive THEN
					IF ptrTAxisToolCenter^.T_CtrleSingle.xErr THEN TStation.TControl.diErrorNr:=2000000 + ptrTAxisToolCenter^.T_CtrleSingle.udiErrorID; END_IF;
				END_IF;
				IF ptrTAxisToolRight^.T_CtrleSingle.xErr THEN TStation.TControl.diErrorNr:=3000000 + ptrTAxisToolRight^.T_CtrleSingle.udiErrorID; END_IF;
				IF ptrTAxisToolFeeder^.T_CtrleSingle.xErr THEN TStation.TControl.diErrorNr:=4000000 + ptrTAxisToolFeeder^.T_CtrleSingle.udiErrorID; END_IF;
				IF ptrTAxisGrindFeeder^.T_CtrleSingle.xErr THEN TStation.TControl.diErrorNr:=5000000 + ptrTAxisGrindFeeder^.T_CtrleSingle.udiErrorID; END_IF;
				IF T_BoxID.T_Ctrle.xErr THEN TStation.TControl.diErrorNr:=7000000 + T_BoxID.T_Ctrle.udiErrorID; END_IF;
			END_IF;
			TStation.TControl.xEnable:=FALSE;
			TStation.TControl.xError:=TRUE;
			xDontDeleteErrorFlag:=TRUE;
			RETURN;
		END_IF;
	END_IF;
	IF NOT(xInitSetEnable) OR fbRTrig.Q THEN
		xSetEnd:=FALSE;
		xInitSetEnable:=TRUE;
		TStation.TControl.xRdy:=FALSE;
		TStation.TControl.xEnd:=FALSE;
		TStation.TControl.xError:=FALSE;
		TStation.TControl.diErrorNr:=0;
		iStepEnable:=100;
		iAxisFunctionNr:=1;
		iStationFunctionNr:=1;
		xSetEnableConfig:=FALSE;
		xInitStep:=FALSE;
		RETURN;
	END_IF;
	CASE iStepEnable OF
		100:	IF NOT(xRdyDisableStation) THEN
				iStepEnable:=110;
				RETURN;
			END_IF;
			IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xStartFunction:=TRUE;
				ptrTFunction^.xReset:=TRUE;
				(* Initialisierung der HW *)
				TStation.TControl.xActiveHardware:=TRUE;
				TStation.T_MachineConfig.iConfigMachineType:=iConfigMachineType;
				TStation.T_MachineConfig.iConfigAxisType:=iConfigAxisType;
				TStation.T_MachineConfig.iConfigVisuNavigation:=iConfigVisuNavigation;
				TStation.T_MachineConfig.rConfigMaxToolLength:=rConfigMaxToolLength;
				(* Initialisierung der Aktuatoren *)

			(* Config Cyl ToolTension *)
				ptrTCylToolTension^.T_CtrleCyl.xFBActiv:=TRUE;
				ptrTCylToolTension^.T_Config.xActivState:=TRUE;
				(*22.12.2009: KFS {    *)
				IF xMicroRodActive THEN
				(* Config Cyl ToolLeftActive*)
					ptrTCylToolLeftActive^.T_CtrleCyl.xFBActiv:=TRUE;
					ptrTCylToolLeftActive^.T_Config.xActivState:=TRUE;
				(* Config Cyl ToolRightActive*)
					ptrTCylToolRightActive^.T_CtrleCyl.xFBActiv:=TRUE;
					ptrTCylToolRightActive^.T_Config.xActivState:=TRUE;
				(* Config Cyl ToolCenterActive*)
					ptrTCylToolCenterActive^.T_CtrleCyl.xFBActiv:=TRUE;
					ptrTCylToolCenterActive^.T_Config.xActivState:=TRUE;
				(* Config Cyl ToolPrismaLeftActive*)
					ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xFBActiv:=TRUE;
					ptrTCylToolPrismaLeftActive^.T_Config.xActivState:=TRUE;
				(* Config Cyl ToolPrismaRightActive*)
					ptrTCylToolPrismaRightActive^.T_CtrleCyl.xFBActiv:=TRUE;
					ptrTCylToolPrismaRightActive^.T_Config.xActivState:=TRUE;
				(* Config Cyl ToolWorkLength*)
					ptrTToolFeederWorkLength^.T_CtrleCyl.xFBActiv:=TRUE;
					ptrTToolFeederWorkLength^.T_Config.xActivState:=TRUE;
				END_IF;
				(*22.12.2009: KFS }   *)
			(* Config ToolLeft Axis *)
				ptrTAxisToolLeft^.T_Config_Gen.iTyp:=1;
				ptrTAxisToolLeft^.T_Config_Gen.iMachineType:=iConfigMachineType;
				ptrTAxisToolLeft^.T_Config_ObjFileValue.xSWLimitNeg:=FALSE;
				ptrTAxisToolLeft^.T_Config_ObjFileValue.xSWLimitPos:=FALSE;
				ptrTAxisToolLeft^.T_Config_ObjFileValue.xHWLimitNeg:=FALSE;
				ptrTAxisToolLeft^.T_Config_ObjFileValue.xHWLimitPos:=FALSE;
			(* Config ToolCenter Axis *)
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_Config_Gen.iTyp:=2;
					ptrTAxisToolCenter^.T_Config_Gen.iMachineType:=iConfigMachineType;
					ptrTAxisToolCenter^.T_Config_ObjFileValue.xSWLimitNeg:=FALSE;
					ptrTAxisToolCenter^.T_Config_ObjFileValue.xSWLimitPos:=FALSE;
					ptrTAxisToolCenter^.T_Config_ObjFileValue.xHWLimitNeg:=FALSE;
					ptrTAxisToolCenter^.T_Config_ObjFileValue.xHWLimitPos:=FALSE;
				END_IF;
			(* Config ToolRight Axis *)
				ptrTAxisToolRight^.T_Config_Gen.iTyp:=3;
				ptrTAxisToolRight^.T_Config_Gen.iMachineType:=iConfigMachineType;
				ptrTAxisToolRight^.T_Config_ObjFileValue.xSWLimitNeg:=FALSE;
				ptrTAxisToolRight^.T_Config_ObjFileValue.xSWLimitPos:=FALSE;
				ptrTAxisToolRight^.T_Config_ObjFileValue.xHWLimitNeg:=FALSE;
				ptrTAxisToolRight^.T_Config_ObjFileValue.xHWLimitPos:=FALSE;
			(* Config ToolFeeder Axis *)
				ptrTAxisToolFeeder^.T_Config_Gen.iTyp:=4;
				ptrTAxisToolFeeder^.T_Config_Gen.iMachineType:=iConfigMachineType;
				IF xMicroRodActive THEN
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xSWLimitNeg:=FALSE;
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xSWLimitPos:=FALSE;
				   	ptrTAxisToolFeeder^.T_Config_ObjFileValue.xHWLimitNeg:=TRUE;
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xHWLimitPos:=TRUE;
				ELSE
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xSWLimitNeg:=FALSE;
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xSWLimitPos:=FALSE;
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xHWLimitNeg:=FALSE;
					ptrTAxisToolFeeder^.T_Config_ObjFileValue.xHWLimitPos:=FALSE;
				END_IF;
			(* Config GrindFeeder Axis *)
				ptrTAxisGrindFeeder^.T_Config_Gen.iTyp:=5;
				ptrTAxisGrindFeeder^.T_Config_Gen.iMachineType:=iConfigMachineType;
				ptrTAxisGrindFeeder^.T_Config_ObjFileValue.xSWLimitNeg:=TRUE;
				ptrTAxisGrindFeeder^.T_Config_ObjFileValue.xSWLimitPos:=TRUE;
				ptrTAxisGrindFeeder^.T_Config_ObjFileValue.xHWLimitNeg:=FALSE;
				ptrTAxisGrindFeeder^.T_Config_ObjFileValue.xHWLimitPos:=FALSE;
			END_IF;
			IF NOT(ptrTFunction^.xReset) AND ptrTFunction^.xEnd THEN
				(* Alle Funktionen Resetten *)
				IF (iStationFunctionNr < iMaxFunctionNr) THEN
					iStationFunctionNr:=iStationFunctionNr + 1;
					ptrTFunction^.xReset:=TRUE;
				ELSE
					xInitStep:=FALSE;
					xStartFunction:=FALSE;
					iStepEnable:=200;
				END_IF;
			END_IF;
		110:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF TStation.TControl.xHardwareConfigError THEN
					TStation.TControl.xHardwareConfigError:=FALSE;
					TStation.TControl.xActiveHardware:=FALSE;
				ELSE
					xRdyDisableStation:=TRUE;
					xInitStep:=FALSE;
					iStepEnable:=100;
				END_IF;
				RETURN;
			END_IF;
			IF NOT(TStation.TControl.xError) THEN
				TStation.TControl.xActiveHardware:=TRUE;
				xRdyDisableStation:=TRUE;
				xInitStep:=FALSE;
				iStepEnable:=100;
				RETURN;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTCylToolTension^.T_CtrleCyl.xReset:=TRUE;
				(*22.12.2009: KFS {    *)
				IF xMicroRodActive THEN
					ptrTCylToolLeftActive^.T_CtrleCyl.xReset:=TRUE;
					ptrTCylToolRightActive^.T_CtrleCyl.xReset:=TRUE;
					ptrTCylToolCenterActive^.T_CtrleCyl.xReset:=TRUE;
					ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xReset:=TRUE;
					ptrTCylToolPrismaRightActive^.T_CtrleCyl.xReset:=TRUE;
					ptrTToolFeederWorkLength^.T_CtrleCyl.xReset:=TRUE;
				END_IF;
				(*22.12.2009: KFS }   *)
				ptrTAxisToolLeft^.T_CtrleSingle.xReset:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.xReset:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.xReset:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.xReset:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xReset) AND NOT(ptrTAxisToolCenter^.T_CtrleSingle.xReset) AND ((NOT(ptrTAxisToolRight^.T_CtrleSingle.xReset) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			     NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xReset) AND NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xReset) THEN
				xInitStep:=FALSE;
				IF NOT(xBeckhoffDriveActive) THEN
					iStepEnable:=300;
				ELSE
					iStepEnable:=500;
				END_IF;
			END_IF;
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolLeft.rAcceleration;
				ptrTAxisToolLeft^.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolLeft.rDeceleration;
				ptrTAxisToolCenter^.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolCenter.rAcceleration;
				ptrTAxisToolCenter^.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolCenter.rDeceleration;
				ptrTAxisToolRight^.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolRight.rAcceleration;
				ptrTAxisToolRight^.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolRight.rDeceleration;
				ptrTAxisToolFeeder^.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINToolFeeder.rAcceleration;
				ptrTAxisToolFeeder^.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINToolFeeder.rDeceleration;
				ptrTAxisGrindFeeder^.T_CtrleSingle.lrAcceleration:=T_Standard.T_TeachINGrindFeeder.rAcceleration;
				ptrTAxisGrindFeeder^.T_CtrleSingle.lrDecceleration:=T_Standard.T_TeachINGrindFeeder.rDeceleration;
				ptrTAxisToolLeft^.T_Config_Gen.sFileNamePDOMapping:='PDOMapping_ToolLeft';
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=22;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_Config_Gen.sFileNamePDOMapping:='PDOMapping_ToolCenter';
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=22;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_Config_Gen.sFileNamePDOMapping:='PDOMapping_ToolRight';
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=22;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_Config_Gen.sFileNamePDOMapping:='PDOMapping_ToolFeeder';
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=22;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_Config_Gen.sFileNamePDOMapping:='PDOMapping_GrindFeeder';
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=22;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
				iCountCycle:=0;
			END_IF;
			iCountCycle:=iCountCycle + 1;
			IF (iCountCycle >= 50) THEN
				xReadyChkError:=TRUE;	(* 50 SPS Zyklen warten bis die Übewachung der HW Error freigeschaltet werden kann *)
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xReadyChkError:=TRUE;
				xInitStep:=FALSE;
				iStepEnable:=400;
			END_IF;
		400:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=23;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=23;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=23;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=23;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=23;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=500;
			END_IF;
		500:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=1;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=1;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=600;
			END_IF;
		600:	IF NOT(xInitStep) THEN	(* Read Axis Parameter File *)
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_Config_Gen.sDeviceFileName:='EcoStep23S21_ToolLeft';
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=2;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_Config_Gen.sDeviceFileName:='EcoStep23S21_ToolCenter';
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=2;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_Config_Gen.sDeviceFileName:='EcoStep23S21_ToolRight';
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=2;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_Config_Gen.sDeviceFileName:='EcoStep23S21_ToolFeeder';
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=2;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_Config_Gen.sDeviceFileName:='EcoStep23S21_GrindFeeder';
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=2;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=700;
			END_IF;
		700:	IF NOT(xInitStep) THEN	(* Read Axis Parameter File *)
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=21;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=21;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=21;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=21;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=21;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				IF NOT(xBeckhoffDriveActive) THEN
					iStepEnable:=1000;
				ELSE
					iStepEnable:=800;
				END_IF;
			END_IF;
		800:	IF NOT(xInitStep) THEN
				IF NOT(T_BoxID.T_Ctrle.xLocked) THEN
					xInitStep:=TRUE;
					(* Box ID-->Beckhoff drive *)
					T_BoxID.T_Ctrle.iMachineType:=iConfigMachineType;
					T_BoxID.T_Servo_ToolLeft.sBoxName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolLeft.sDeviceName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolLeft.xDeviceOption:=TRUE;
					T_BoxID.T_Servo_ToolCenter.sBoxName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolCenter.sDeviceName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolCenter.xDeviceOption:=TRUE;
					T_BoxID.T_Servo_ToolRight.sBoxName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolRight.sDeviceName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolRight.xDeviceOption:=TRUE;
					T_BoxID.T_Servo_ToolFeeder.sBoxName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolFeeder.sDeviceName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_ToolFeeder.xDeviceOption:=TRUE;
					T_BoxID.T_Servo_GrindFeeder.sBoxName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_GrindFeeder.sDeviceName:='AX25xx_Slide_St1';
					T_BoxID.T_Servo_GrindFeeder.xDeviceOption:=TRUE;
					T_BoxID.T_Ctrle.xLocked:=TRUE;
					T_BoxID.T_Ctrle.xExecute:=TRUE;
				END_IF;
				RETURN;
			END_IF;
			IF NOT(T_BoxID.T_Ctrle.xExecute) AND T_BoxID.T_Ctrle.xDone AND T_BoxID.T_Ctrle.xLocked THEN
				T_BoxID.T_Ctrle.xLocked:=FALSE;
				xInitStep:=FALSE;
				iStepEnable:=900;
			END_IF;
		900:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF (T_BoxID.T_Servo_ToolLeft.wAddrBox = 0) OR (T_BoxID.T_Servo_ToolLeft.wAddrBox <> ptrTAxisToolLeft^.T_Config_Gen.udiNC_TaskIdxGrp) THEN
					xSetError:=TRUE;
					diErrorNumber:=16#F201;	(* ToolLeft-->Falsche Konfiguration oder Achse nicht vorhanden *)
					RETURN;
				ELSIF ((T_BoxID.T_Servo_ToolCenter.wAddrBox = 0) OR (T_BoxID.T_Servo_ToolCenter.wAddrBox <> ptrTAxisToolCenter^.T_Config_Gen.udiNC_TaskIdxGrp)) AND xMicroRodActive THEN
					xSetError:=TRUE;
					diErrorNumber:=16#F202;	(* ToolCenter-->Falsche Konfiguration oder Achse nicht vorhanden *)
					RETURN;
				ELSIF (T_BoxID.T_Servo_ToolRight.wAddrBox = 0) OR (T_BoxID.T_Servo_ToolRight.wAddrBox <> ptrTAxisToolRight^.T_Config_Gen.udiNC_TaskIdxGrp) THEN
					xSetError:=TRUE;
					diErrorNumber:=16#F203;	(* ToolRight-->Falsche Konfiguration oder Achse nicht vorhanden *)
					RETURN;
				ELSIF (T_BoxID.T_Servo_ToolFeeder.wAddrBox = 0) OR (T_BoxID.T_Servo_ToolFeeder.wAddrBox <> ptrTAxisToolFeeder^.T_Config_Gen.udiNC_TaskIdxGrp) THEN
					xSetError:=TRUE;
					diErrorNumber:=16#F204;	(* ToolFeeder-->Falsche Konfiguration oder Achse nicht vorhanden *)
					RETURN;
				ELSIF (T_BoxID.T_Servo_GrindFeeder.wAddrBox = 0) OR (T_BoxID.T_Servo_GrindFeeder.wAddrBox <> ptrTAxisGrindFeeder^.T_Config_Gen.udiNC_TaskIdxGrp) THEN
					xSetError:=TRUE;
					diErrorNumber:=16#F205;	(* GrindFeeder-->Falsche Konfiguration oder Achse nicht vorhanden *)
					RETURN;
				ELSE
				(* Achsenparameterisierung erfolgreich *)
					;
				END_IF;
				xInitStep:=FALSE;
				iStepEnable:=1100;
			END_IF;
		(* Read Axis Firmware Information *)
		1000:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=27;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=27;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=27;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=27;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=27;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=1100;
			END_IF;
		1100:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=4;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=4;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=4;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=4;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=4;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=1200;
			END_IF;
		1200:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=3;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=3;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=3;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=3;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=3;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				IF NOT(xFirstTimeBooting) THEN
					xFirstTimeBooting:=TRUE;
					iStepEnable:=1300;
				ELSE
					iStepEnable:=1400;
				END_IF;
				xInitStep:=FALSE;
			END_IF;
		(* Set the Position of the GrindFeeder on the Settled ToolDiameter, but only on the first time on booting of the machine *)
		1300:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.rSetPosition:=T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=11;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=1400;
			END_IF;
		(* Set the SW Limit position for the GrindFeeder Axis *)
		1400:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.lrSWNegLimitSwitch:=T_ProcessImageData.T_PrismPara.rToolDiameterMin;
				ptrTAxisGrindFeeder^.T_CtrleSingle.lrSWPosLimitSwitch:=T_ProcessImageData.T_PrismPara.rToolDiameterMax + T_Standard.T_TeachINGrindFeeder.rOffsetSWPosEndSwitch;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=28;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				IF NOT(xMicroRodActive) THEN
					(* Only for MicroWire activate the ToolTension *)
					iStepEnable:=1500;
				ELSE
					iStepEnable:=1600;
				END_IF;
			END_IF;
		1500:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTCylToolTension^.T_CtrleCyl.iFunction:=2;
				ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
				ptrTCylToolTension^.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTCylToolTension^.T_CtrleCyl.xExecute) AND ptrTCylToolTension^.T_CtrleCyl.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=1600;
			END_IF;
		1600:xReadyChkError:=FALSE;
			xInitStep:=FALSE;
			xSetEnableConfig:=TRUE;
			iEnableConfigMachineType:=iConfigMachineType;
			iEnableConfigAxisType:=iConfigAxisType;
			iEnableConfigVisuNavigation:=iConfigVisuNavigation;
			rEnableConfigMaxToolLength:=rConfigMaxToolLength;
			xInitSetEnable:=FALSE;
			TStation.TControl.xRdy:=TRUE;
			xSetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				       Security Circuit Switch ON/OFF                                          *****************************)
(******************************************************************************************************************************************)
IF (TStation.TControl.xSecurityCircuitOn OR TStation.TControl.xSecurityCircuitOff OR xSecurityCircuitOn OR xSecurityCircuitOff) AND NOT(xInitSetEnable) AND NOT(xInitDelEnable) THEN
	IF NOT(xSecurityCircuitOn) AND NOT(xSecurityCircuitOff) THEN
		xSecurityCircuitOn:=TStation.TControl.xSecurityCircuitOn;
		xSecurityCircuitOff:=TStation.TControl.xSecurityCircuitOff;
		iStepSecCircuit:=1;
		xInitSecCircuit:=FALSE;
		TStation.TControl.xRdy:=FALSE;
		TStation.TControl.xEnd:=FALSE;
		TONCheckTimeOut(IN:=FALSE);
	END_IF;
	IF xSecurityCircuitOn THEN
		IF TStation.TControl.xSecurityCircuitOff THEN
			TStation.TControl.xSecurityCircuitOn:=FALSE;
			xSecurityCircuitOn:=FALSE;
		END_IF;
	END_IF;
	IF xSecurityCircuitOff THEN
		IF TStation.TControl.xSecurityCircuitOn THEN
			TStation.TControl.xSecurityCircuitOff:=FALSE;
			xSecurityCircuitOff:=FALSE;
		END_IF;
	END_IF;
	TONCheckTimeOut(IN:=TRUE,PT:=T#0.5s);
	xCheckAxisError:=FALSE;
	IF TONCheckTimeOut.Q THEN
		IF ptrTAxisToolLeft^.T_CtrleSingle.xErr THEN
			ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
			xCheckAxisError:=TRUE;
		END_IF;
		IF xMicroRodActive THEN
			IF ptrTAxisToolCenter^.T_CtrleSingle.xErr THEN
				ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				xCheckAxisError:=TRUE;
			END_IF;
		END_IF;
		IF ptrTAxisToolRight^.T_CtrleSingle.xErr THEN
			ptrTAxisToolRight^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
			xCheckAxisError:=TRUE;
		END_IF;
		IF ptrTAxisToolFeeder^.T_CtrleSingle.xErr THEN
			ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
			xCheckAxisError:=TRUE;
		END_IF;
		IF ptrTAxisGrindFeeder^.T_CtrleSingle.xErr THEN
			ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=1;
			ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			xCheckAxisError:=TRUE;
		END_IF;
		TStation.TControl.xRdy:=TRUE;
		IF xCheckAxisError THEN
			TStation.TControl.xSecurityCircuitOn:=FALSE;
			TStation.TControl.xSecurityCircuitOff:=FALSE;
			xSecurityCircuitOn:=FALSE;
			xSecurityCircuitOff:=FALSE;
			iStepSecCircuit:=1;
			xInitSecCircuit:=FALSE;
			xSetEnd:=TRUE;
			RETURN;
		END_IF;
	END_IF;
	CASE iStepSecCircuit OF
	1:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			ptrTFunction^.xReset:=TRUE;
			iStationFunctionNr:=1;
			xStartFunction:=TRUE;
		END_IF;
		IF NOT(ptrTFunction^.xReset) AND ptrTFunction^.xEnd THEN
			(* Alle Funktionen Resetten *)
			IF (iStationFunctionNr < iMaxFunctionNr) THEN
				iStationFunctionNr:=iStationFunctionNr + 1;
				ptrTFunction^.xReset:=TRUE;
			ELSE
				xInitSecCircuit:=FALSE;
				iStepSecCircuit:=10;
				xStartFunction:=FALSE;
			END_IF;
		END_IF;
	10:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			ptrTAxisToolLeft^.T_CtrleSingle.xReset:=TRUE;
			IF xMicroRodActive THEN
				ptrTAxisToolCenter^.T_CtrleSingle.xReset:=TRUE;
			END_IF;
			ptrTAxisToolRight^.T_CtrleSingle.xReset:=TRUE;
			ptrTAxisToolFeeder^.T_CtrleSingle.xReset:=TRUE;
			ptrTAxisGrindFeeder^.T_CtrleSingle.xReset:=TRUE;
		END_IF;
		IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xReset) AND ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xReset) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND NOT(ptrTAxisToolRight^.T_CtrleSingle.xReset) AND
		    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xReset) AND NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xReset) THEN
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=20;
		END_IF;
	20:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
			IF xMicroRodActive THEN
				ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			ptrTAxisToolRight^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
			ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
			ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=1;
			ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
		    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
		    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
		    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone THEN
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=30;
		END_IF;
	30:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			(* Resetten der Aktuatoren *)
			ptrTCylToolTension^.T_CtrleCyl.xReset:=TRUE;
			(*22.12.2009: KFS {    *)
			IF xMicroRodActive THEN
				ptrTCylToolLeftActive^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylToolRightActive^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylToolCenterActive^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylToolPrismaRightActive^.T_CtrleCyl.xReset:=TRUE;
			END_IF;
			(*22.12.2009: KFS }   *)
		END_IF;
		IF NOT(ptrTCylToolTension^.T_CtrleCyl.xReset) AND ptrTCylToolTension^.T_CtrleCyl.xDone AND
		     ( NOT(xMicroRodActive) OR
		         ( NOT(ptrTCylToolLeftActive^.T_CtrleCyl.xReset) AND ptrTCylToolLeftActive^.T_CtrleCyl.xDone AND
		           NOT(ptrTCylToolRightActive^.T_CtrleCyl.xReset) AND ptrTCylToolRightActive^.T_CtrleCyl.xDone AND
		           NOT(ptrTCylToolCenterActive^.T_CtrleCyl.xReset) AND ptrTCylToolCenterActive^.T_CtrleCyl.xDone AND
 		           NOT(ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xReset) AND ptrTCylToolPrismaLeftActive^.T_CtrleCyl.xDone AND
                              NOT(ptrTCylToolPrismaRightActive^.T_CtrleCyl.xReset) AND ptrTCylToolPrismaRightActive^.T_CtrleCyl.xDone )  )  THEN
			xInitSecCircuit:=FALSE;
			IF xSecurityCircuitOn THEN
				iStepSecCircuit:=40;
			ELSE
				iStepSecCircuit:=50;
			END_IF;
		END_IF;
	40:	IF NOT(xInitSecCircuit) THEN
				xInitSecCircuit:=TRUE;
				ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=3;
				ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
				IF xMicroRodActive THEN
					ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=3;
					ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				ptrTAxisToolRight^.T_CtrleSingle.iFunction:=3;
				ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=3;
				ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=3;
				ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
				IF NOT(xMicroRodActive) THEN
					ptrTCylToolTension^.T_CtrleCyl.iFunction:=2;
					IF (iSelectToolTensionForce < 2) THEN
						ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
					END_IF;
					IF (iSelectToolTensionForce > 1) THEN
						ptrTCylToolTension^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_Standard.T_Cyl_ToolTension.rForce;
					END_IF
					ptrTCylToolTension^.T_CtrleCyl.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xExecute) AND ptrTAxisToolCenter^.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
			    NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisToolFeeder^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute) AND ptrTAxisGrindFeeder^.T_CtrleSingle.xDone AND
			    ((NOT(ptrTCylToolTension^.T_CtrleCyl.xExecute) AND ptrTCylToolTension^.T_CtrleCyl.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				xInitSecCircuit:=FALSE;
				iStepSecCircuit:=50;
			END_IF;
	50:	TStation.TControl.xRdy:=TRUE;
		TStation.TControl.xSecurityCircuitOn:=FALSE;
		TStation.TControl.xSecurityCircuitOff:=FALSE;
		xSecurityCircuitOn:=FALSE;
		xSecurityCircuitOff:=FALSE;
		iStepSecCircuit:=1;
		xInitSecCircuit:=FALSE;
		xSetEnd:=TRUE;
	END_CASE;
ELSE
	TStation.TControl.xSecurityCircuitOn:=FALSE;
	TStation.TControl.xSecurityCircuitOff:=FALSE;
	xSecurityCircuitOn:=FALSE;
	xSecurityCircuitOff:=FALSE;
	iStepSecCircuit:=1;
	xInitSecCircuit:=FALSE;
	TONCheckTimeOut(IN:=FALSE);
END_IF;
(******************************************************************************************************************************************)
(****************************				         Error Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
IF xActiveProcess THEN
	IF (ptrTAxisToolLeft^.T_CtrleSingle.xErr OR (ptrTAxisToolCenter^.T_CtrleSingle.xErr AND xMicroRodActive) OR ptrTAxisToolRight^.T_CtrleSingle.xErr OR
              ptrTAxisToolFeeder^.T_CtrleSingle.xErr OR ptrTAxisGrindFeeder^.T_CtrleSingle.xErr) AND NOT(xWaitSetError) THEN
		xWaitSetError:=TRUE;
		TONWaitSetError(IN:=FALSE);
	END_IF;
	IF xWaitSetError THEN
		TONWaitSetError(IN:=TRUE,PT:=T#50ms);
		IF TONWaitSetError.Q THEN
			xForceHWError:=TRUE;
		END_IF;
	END_IF;
ELSE
	xWaitSetError:=FALSE;
	xForceHWError:=FALSE;
	TONWaitSetError(IN:=FALSE);
END_IF;
IF xStationError OR xForceHWError OR (ptrTFunction^.xError AND TStation.TControl.xRdy AND NOT(xSetEnd)) THEN
	IF NOT(xInitError) THEN
		xForceHWError:=FALSE;
		xStationError:=TRUE;
		xTmpStationError:=TRUE;
		xInitError:=TRUE;
		xAxisErrorActive:=FALSE;
		TStation.TControl.diErrorNr:=0;
		IF ptrTAxisToolLeft^.T_CtrleSingle.xErr THEN
			TStation.TControl.diErrorNr:=1000000 + ptrTAxisToolLeft^.T_CtrleSingle.udiErrorID;
			ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
			xAxisErrorActive:=TRUE;
		END_IF;
		IF xMicroRodActive THEN
			IF ptrTAxisToolCenter^.T_CtrleSingle.xErr THEN
				TStation.TControl.diErrorNr:=2000000 + ptrTAxisToolCenter^.T_CtrleSingle.udiErrorID;
				ptrTAxisToolCenter^.T_CtrleSingle.iFunction:=1;
				ptrTAxisToolCenter^.T_CtrleSingle.xExecute:=TRUE;
				xAxisErrorActive:=TRUE;
			END_IF;
		END_IF;
		IF ptrTAxisToolRight^.T_CtrleSingle.xErr THEN
			TStation.TControl.diErrorNr:=3000000 + ptrTAxisToolRight^.T_CtrleSingle.udiErrorID;
			ptrTAxisToolRight^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
			xAxisErrorActive:=TRUE;
		END_IF;
		IF ptrTAxisToolFeeder^.T_CtrleSingle.xErr THEN
			TStation.TControl.diErrorNr:=4000000 + ptrTAxisToolFeeder^.T_CtrleSingle.udiErrorID;
			ptrTAxisToolFeeder^.T_CtrleSingle.iFunction:=1;
			ptrTAxisToolFeeder^.T_CtrleSingle.xExecute:=TRUE;
			xAxisErrorActive:=TRUE;
		END_IF;
		IF ptrTAxisGrindFeeder^.T_CtrleSingle.xErr THEN
			TStation.TControl.diErrorNr:=5000000 + ptrTAxisGrindFeeder^.T_CtrleSingle.udiErrorID;
			ptrTAxisGrindFeeder^.T_CtrleSingle.iFunction:=1;
			ptrTAxisGrindFeeder^.T_CtrleSingle.xExecute:=TRUE;
			xAxisErrorActive:=TRUE;
		END_IF;
		IF ptrTCylToolTension^.T_CtrleCyl.xErr THEN
			TStation.TControl.diErrorNr:=6000000 + ptrTCylToolTension^.T_CtrleCyl.udiErrorID;
			ptrTCylToolTension^.T_CtrleCyl.xReset:=TRUE;
		END_IF;
		IF (TStation.TControl.diErrorNr = 0) THEN	(* General Error-->No Hardware Error  7000 - 7999*)
			TStation.TControl.diErrorNr:=8000000 + ptrTFunction^.iErrorNr;
		END_IF;
		ptrTFunction^.xQuitErr:=NOT(ptrTFunction^.xEnd) AND ptrTFunction^.xError;
		IF NOT(ptrTFunction^.xQuitErr) AND NOT(ptrTFunction^.xEnd) THEN
			xForceResetAxis:=TRUE;
			ptrTFunction^.xReset:=TRUE;
		END_IF;
		TONWaitReset(IN:=FALSE);
	END_IF;
	IF (ptrTFunction^.xEnd OR xForceResetAxis) AND xTmpStationError THEN
		IF NOT(ptrTAxisToolLeft^.T_CtrleSingle.xErr) AND ((NOT(ptrTAxisToolCenter^.T_CtrleSingle.xErr) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
		     NOT(ptrTAxisToolRight^.T_CtrleSingle.xErr) AND NOT(ptrTAxisToolFeeder^.T_CtrleSingle.xErr) AND NOT(ptrTAxisGrindFeeder^.T_CtrleSingle.xErr) THEN
			TStation.TControl.xError:=TRUE;
			xForceResetAxis:=FALSE;
		END_IF;
		TONWaitReset(IN:=TRUE,PT:=T#100ms);
		IF TONWaitReset.Q THEN
			IF xAxisErrorActive THEN
				T_StartUp.T_Ctrle.xSetSecurityStateON:=TRUE;
			END_IF;
			xStepError:=FALSE;
			xStartFunction:=FALSE;
			xTmpStationError:=FALSE;
			xReadyToQuitErr:=TRUE;
		END_IF;
	END_IF;
	IF TStation.TControl.xQuitError AND NOT(ptrTFunction^.xQuitErr) AND xReadyToQuitErr THEN
		xInitError:=FALSE;
		TStation.TControl.xQuitError:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				         Main Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
IF (TStation.TControl.xStart OR xTmpStart) AND TStation.TControl.xRdy AND NOT(xSetEnd) THEN
	IF NOT(xInitStart) THEN
		xInitStart:=TRUE;
		xTmpStart:=TRUE;
		TStation.TControl.xStart:=FALSE;
		TStation.TControl.xEnd:=FALSE;
		ptrTFunction^.xStart:=TRUE;
		xStartFunction:=TRUE;
		iStationFunctionNr:=TStation.TControl.iFunctNr;
		TStation.TControl.xAbord:=FALSE;
	END_IF;
	IF TStation.TControl.xStop THEN
		IF NOT(xInitStop) THEN
			xInitStop:=TRUE;
			ptrTFunction^.xStop:=TRUE;
		END_IF;
		IF NOT(ptrTFunction^.xStop) THEN
			xInitStop:=FALSE;
			TStation.TControl.xStop:=FALSE;
			xTmpStopFunction:=TRUE;
		END_IF;
	END_IF;
	IF TStation.TControl.xStart AND xTmpStopFunction AND NOT(ptrTFunction^.xAbord) THEN
		TStation.TControl.xStart:=FALSE;
		xTmpStopFunction:=FALSE;
		ptrTFunction^.xStart:=TRUE;
	END_IF;
	IF TStation.TControl.xAbord AND xTmpStopFunction THEN
		TStation.TControl.xAbord:=FALSE;
		xTmpStopFunction:=FALSE;
		ptrTFunction^.xStart:=FALSE;
		ptrTFunction^.xAbord:=TRUE;
	END_IF;
	IF NOT(ptrTFunction^.xStart) AND ptrTFunction^.xEnd AND NOT(xStationError) THEN
		xTmpStart:=FALSE;
		xInitStart:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				   Check Configuration Station Part                                 *****************************)
(******************************************************************************************************************************************)
IF (xStartFunction OR xChkConfigStation) AND xSetEnableConfig THEN
	IF NOT(xChkConfigStation) THEN
		IF (iEnableConfigMachineType <> iConfigMachineType) OR (iEnableConfigAxisType <> iConfigAxisType) OR (iEnableConfigVisuNavigation <> iConfigVisuNavigation) OR (rEnableConfigMaxToolLength <> rConfigMaxToolLength)  THEN
			xChkConfigStation:=TRUE;
			ptrTFunction^.xStop:=NOT(ptrTFunction^.xEnd);
			IF ptrTFunction^.xEnd THEN
				ptrTFunction^.xStart:=FALSE;
			END_IF;
		END_IF;
	END_IF;
	IF xChkConfigStation THEN
		IF ptrTFunction^.xEnd THEN
			IF (iEnableConfigMachineType <> iConfigMachineType) THEN
				ptrTFunction^.iErrorNr:=7001;	(* Error-->Config Machine Type changed *)
			END_IF;
			IF (iEnableConfigAxisType <> iConfigAxisType) THEN
				ptrTFunction^.iErrorNr:=7002;	(* Error-->Config Axis Type changed *)
			END_IF;
			IF (iEnableConfigVisuNavigation <> iConfigVisuNavigation) THEN
				TStation.TControl.diErrorNr:=7003;	(* Error-->Config Visu Navigation changed *)
			END_IF;
			IF (rEnableConfigMaxToolLength <> rConfigMaxToolLength) THEN
				TStation.TControl.diErrorNr:=7004;	(* Error-->Config Max Tool Length changed *)
			END_IF;
			xStartFunction:=FALSE;
			xChkConfigStation:=FALSE;
			xStationError:=TRUE;
			RETURN;
		END_IF;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				              Funktionen                                                               *****************************)
(******************************************************************************************************************************************)
IF xStartFunction AND NOT(xSetEnd) THEN
	IF (iStationFunctionNr = 1) THEN
		FBFctToolFeedReference(	xMicroRodActive:= xMicroRodActive,
								xBeckhoffDriveActive:= xBeckhoffDriveActive,
								xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
								T_Standard:= T_Standard,
								xStart:= ptrTFunction^.xStart,
								xReset:=ptrTFunction^.xReset,
								xStop:= ptrTFunction^.xStop,
								xQuitErr:= ptrTFunction^.xQuitErr,
								xAbord:= ptrTFunction^.xAbord,
								TAxisToolFeeder:= ptrTAxisToolFeeder^,
								xEnd=>ptrTFunction^.xEnd,
								xError=>ptrTFunction^.xError,
								iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 2) THEN
		FBFctToolRotationTorqueStart(	xMicroRodActive:= xMicroRodActive,
									xBeckhoffDriveActive:= xBeckhoffDriveActive,
									xSafetyCircuitOn:=xSafetyCircuitOn1 AND xSafetyCircuitOn2,
									xStart:= ptrTFunction^.xStart,
									xReset:=ptrTFunction^.xReset,
									xStop:= ptrTFunction^.xStop,
									xQuitErr:= ptrTFunction^.xQuitErr,
									xAbord:= ptrTFunction^.xAbord,
									TAxisToolLeft:= ptrTAxisToolLeft^,
									TAxisToolCenter:= ptrTAxisToolCenter^,
									TAxisToolRight:=ptrTAxisToolRight^,
									TAxisToolFeeder:=ptrTAxisToolFeeder^,
									xEnd=>ptrTFunction^.xEnd,
									xError=>ptrTFunction^.xError,
									iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 3) THEN
		FBFctToolRotationTorqueStop(	xMicroRodActive:= xMicroRodActive,
									xBeckhoffDriveActive:= xBeckhoffDriveActive,
									xSafetyCircuitOn:=xSafetyCircuitOn1 AND xSafetyCircuitOn2,
									xStart:= ptrTFunction^.xStart,
									xReset:=ptrTFunction^.xReset,
									xStop:= ptrTFunction^.xStop,
									xQuitErr:= ptrTFunction^.xQuitErr,
									xAbord:= ptrTFunction^.xAbord,
									TAxisToolLeft:= ptrTAxisToolLeft^,
									TAxisToolCenter:= ptrTAxisToolCenter^,
									TAxisToolRight:=ptrTAxisToolRight^,
									TAxisToolFeeder:=ptrTAxisToolFeeder^,
									xEnd=>ptrTFunction^.xEnd,
									xError=>ptrTFunction^.xError,
									iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 4) OR (iStationFunctionNr = 5) THEN
		FBFctGrindFeedAbsRelPosition(	xMicroRodActive:= xMicroRodActive,
										xBeckhoffDriveActive:= xBeckhoffDriveActive,
										xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
										iFunctionNr:= iStationFunctionNr,
										xStart:= ptrTFunction^.xStart,
										xReset:=ptrTFunction^.xReset,
										xStop:= ptrTFunction^.xStop,
										xQuitErr:= ptrTFunction^.xQuitErr,
										xAbord:= ptrTFunction^.xAbord,
										TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
										xEnd=>ptrTFunction^.xEnd,
										xError=>ptrTFunction^.xError,
										iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr >= 6) AND (iStationFunctionNr <= 10) THEN
		FBFctSetAxisPosition(	xMicroRodActive:= xMicroRodActive,
							xBeckhoffDriveActive:= xBeckhoffDriveActive,
							xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
							iFunctionNr:= iStationFunctionNr,
							xStart:= ptrTFunction^.xStart,
							xReset:=ptrTFunction^.xReset,
							xStop:= ptrTFunction^.xStop,
							xQuitErr:= ptrTFunction^.xQuitErr,
							xAbord:= ptrTFunction^.xAbord,
							TAxisToolLeft:= ptrTAxisToolLeft^,
							TAxisToolCenter:= ptrTAxisToolCenter^,
							TAxisToolRight:=ptrTAxisToolRight^,
							TAxisToolFeeder:=ptrTAxisToolFeeder^,
							TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
							xEnd=>ptrTFunction^.xEnd,
							xError=>ptrTFunction^.xError,
							iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 11) THEN
		(* AutoGeometry *)
		FBFctToolWorkingGeometry(	xMicroRodActive:= xMicroRodActive,
									xBeckhoffDriveActive:= xBeckhoffDriveActive,
									xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
									T_ProcessImageData:= T_ProcessImageData,
									T_Standard:= T_Standard,
									xStart:= ptrTFunction^.xStart,
									xReset:=ptrTFunction^.xReset,
									xStop:= ptrTFunction^.xStop,
									xQuitErr:= ptrTFunction^.xQuitErr,
									xAbord:= ptrTFunction^.xAbord,
									TAxisToolLeft:= ptrTAxisToolLeft^,
									TAxisToolCenter:= ptrTAxisToolCenter^,
									TAxisToolRight:=ptrTAxisToolRight^,
									TAxisToolFeeder:=ptrTAxisToolFeeder^,
									TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
									T_WorkTool:=TStation.T_WorkTool,
									xEnd=>ptrTFunction^.xEnd,
									xError=>ptrTFunction^.xError,
									iErrorNr=>ptrTFunction^.iErrorNr,
									bActivePartNumber=>bActivePartNumber,
									lrProcessToolFeederActualPosition=>lrProcessToolFeederActualPosition,
									lrProcessToolFeederSpeed=>lrProcessToolFeederSpeed,
									iCountDownPlungeCycle=>TStation.TControl.iCountDownPlungeCycle);
	END_IF;
	IF (iStationFunctionNr = 12) THEN
		(* AutoGroove *)
		FBFctToolWorkingGroove(		xMicroRodActive:= xMicroRodActive,
									xBeckhoffDriveActive:= xBeckhoffDriveActive,
									xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
									xDoNotMoveGrindPosition:=T_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder,
									T_ProcessImageData:= T_ProcessImageData,
									T_Standard:= T_Standard,
									xStart:= ptrTFunction^.xStart,
									xReset:=ptrTFunction^.xReset,
									xStop:= ptrTFunction^.xStop,
									xQuitErr:= ptrTFunction^.xQuitErr,
									xAbord:= ptrTFunction^.xAbord,
									TAxisToolLeft:= ptrTAxisToolLeft^,
									TAxisToolCenter:= ptrTAxisToolCenter^,
									TAxisToolRight:=ptrTAxisToolRight^,
									TAxisToolFeeder:=ptrTAxisToolFeeder^,
									TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
									T_WorkTool:=TStation.T_WorkTool,
									rStartPosAutoGrooveToolRotation:=TStation.rStartPosAutoGrooveToolRotation,
									xEnd=>ptrTFunction^.xEnd,
									xError=>ptrTFunction^.xError,
									iErrorNr=>ptrTFunction^.iErrorNr,
									bActivePartNumber=>bActivePartNumber,
									lrProcessToolFeederActualPosition=>lrProcessToolFeederActualPosition,
									lrProcessToolFeederSpeed=>lrProcessToolFeederSpeed);
	END_IF;
	IF (iStationFunctionNr = 13) THEN
		FBFctToolCalibration(			xMicroRodActive:= xMicroRodActive,
									xBeckhoffDriveActive:= xBeckhoffDriveActive,
									xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
									T_ProcessImageData:= T_ProcessImageData,
									T_Standard:= T_Standard,
									xStart:= ptrTFunction^.xStart,
									xReset:=ptrTFunction^.xReset,
									xStop:= ptrTFunction^.xStop,
									xQuitErr:= ptrTFunction^.xQuitErr,
									xAbord:= ptrTFunction^.xAbord,
									TAxisToolLeft:= ptrTAxisToolLeft^,
									TAxisToolCenter:= ptrTAxisToolCenter^,
									TAxisToolRight:=ptrTAxisToolRight^,
									TAxisToolFeeder:=ptrTAxisToolFeeder^,
									TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
									T_WorkTool:=TStation.T_WorkTool,
									xEnd=>ptrTFunction^.xEnd,
									xError=>ptrTFunction^.xError,
									iErrorNr=>ptrTFunction^.iErrorNr,
									lrProcessToolFeederActualPosition=>lrProcessToolFeederActualPosition,
									lrProcessToolFeederSpeed=>lrProcessToolFeederSpeed);
	END_IF;
	IF (iStationFunctionNr = 14) OR (iStationFunctionNr = 15) THEN
		FBFctToolFeedAbsRelPosition(		xMicroRodActive:= xMicroRodActive,
										xBeckhoffDriveActive:= xBeckhoffDriveActive,
										xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
										iFunctionNr:= iStationFunctionNr,
										xStart:= ptrTFunction^.xStart,
										xReset:=ptrTFunction^.xReset,
										xStop:= ptrTFunction^.xStop,
										xQuitErr:= ptrTFunction^.xQuitErr,
										xAbord:= ptrTFunction^.xAbord,
										TAxisToolFeeder:= ptrTAxisToolFeeder^,
										xEnd=>ptrTFunction^.xEnd,
										xError=>ptrTFunction^.xError,
										iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 16) OR (iStationFunctionNr = 17) THEN
		FBFctSwitchOnOffPowerSupply(	xMicroRodActive:= xMicroRodActive,
									xBeckhoffDriveActive:= xBeckhoffDriveActive,
									xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
									iFunctionNr:= iStationFunctionNr,
									xStart:= ptrTFunction^.xStart,
									xReset:=ptrTFunction^.xReset,
									xStop:= ptrTFunction^.xStop,
									xQuitErr:= ptrTFunction^.xQuitErr,
									xAbord:= ptrTFunction^.xAbord,
									TAxisToolLeft:= ptrTAxisToolLeft^,
									TAxisToolCenter:= ptrTAxisToolCenter^,
									TAxisToolRight:=ptrTAxisToolRight^,
									TAxisToolFeeder:=ptrTAxisToolFeeder^,
									TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
									xEnd=>ptrTFunction^.xEnd,
									xError=>ptrTFunction^.xError,
									iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 18) THEN
		FBFctStopAxisMovement(	xMicroRodActive:= xMicroRodActive,
								xBeckhoffDriveActive:= xBeckhoffDriveActive,
								xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
								T_ProcessImageData:= T_ProcessImageData,
								T_Standard:= T_Standard,
								xStart:= ptrTFunction^.xStart,
								xReset:=ptrTFunction^.xReset,
								xStop:= ptrTFunction^.xStop,
								xQuitErr:= ptrTFunction^.xQuitErr,
								xAbord:= ptrTFunction^.xAbord,
								TAxisToolLeft:= ptrTAxisToolLeft^,
								TAxisToolCenter:= ptrTAxisToolCenter^,
								TAxisToolRight:=ptrTAxisToolRight^,
								TAxisToolFeeder:=ptrTAxisToolFeeder^,
								TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
								xEnd=>ptrTFunction^.xEnd,
								xError=>ptrTFunction^.xError,
								iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	IF (iStationFunctionNr = 19) THEN
		(* AutoGeometryMultiCycle*)
		FBFctToolWorkingGeometryMultiCycle(	xMicroRodActive:= xMicroRodActive,
											xBeckhoffDriveActive:= xBeckhoffDriveActive,
											xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
											T_ProcessImageData:= T_ProcessImageData,
											T_Standard:= T_Standard,
											xStart:= ptrTFunction^.xStart,
											xReset:=ptrTFunction^.xReset,
											xStop:= ptrTFunction^.xStop,
											xQuitErr:= ptrTFunction^.xQuitErr,
											xAbord:= ptrTFunction^.xAbord,
											TAxisToolLeft:= ptrTAxisToolLeft^,
											TAxisToolCenter:= ptrTAxisToolCenter^,
											TAxisToolRight:=ptrTAxisToolRight^,
											TAxisToolFeeder:=ptrTAxisToolFeeder^,
											TAxisGrindFeeder:= ptrTAxisGrindFeeder^,
											T_WorkTool:=TStation.T_WorkTool,
											xEnd=>ptrTFunction^.xEnd,
											xError=>ptrTFunction^.xError,
											iErrorNr=>ptrTFunction^.iErrorNr,
											bActivePartNumber=>bActivePartNumber,
											lrProcessToolFeederActualPosition=>lrProcessToolFeederActualPosition,
											lrProcessToolFeederSpeed=>lrProcessToolFeederSpeed,
											iCountDownPlungeCycle=>TStation.TControl.iCountDownPlungeCycle);
	END_IF;
	(* 17.11.2010: KFS 	{	*)
	IF (iStationFunctionNr = 20) THEN
		FBFctToolFeedMaxLenReference(	xMicroRodActive:= xMicroRodActive,
										xBeckhoffDriveActive:= xBeckhoffDriveActive,
										xSafetyCircuitOn:= xSafetyCircuitOn1 AND xSafetyCircuitOn2,
										T_Standard:= T_Standard,
										xStart:= ptrTFunction^.xStart,
										xReset:=ptrTFunction^.xReset,
										xStop:= ptrTFunction^.xStop,
										xQuitErr:= ptrTFunction^.xQuitErr,
										xAbord:= ptrTFunction^.xAbord,
										TAxisToolFeeder:= ptrTAxisToolFeeder^,
										xEnd=>ptrTFunction^.xEnd,
										xError=>ptrTFunction^.xError,
										iErrorNr=>ptrTFunction^.iErrorNr);
	END_IF;
	(* 17.11.2010: KFS 	{	*)
END_IF;
(******************************************************************************************************************************************)
(****************************				         Init / Reset Hardware                                                 *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xStationError:=FALSE;
	xInitError:=FALSE;
	xInitStart:=FALSE;
	xInitStop:=FALSE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xTmpStart:=FALSE;
	TStation.TControl.xEnd:=TRUE;
	TStation.TControl.xStart:=FALSE;
	TStation.TControl.xStop:=FALSE;
	TStation.TControl.xAbord:=FALSE;
	IF NOT(xDontDeleteErrorFlag) THEN
		TStation.TControl.xError:=FALSE;
		TStation.TControl.diErrorNr:=0;
	END_IF;
	xDontDeleteErrorFlag:=FALSE;
	xStartFunction:=FALSE;
	iStepError:=100;
	xStepError:=FALSE;
	xTmpStationError:=FALSE;
	xChkConfigStation:=FALSE;
	diErrorNumber:=0;
	xSetError:=FALSE;
	xReadyToQuitErr:=FALSE;
END_IF;
(*03.03.2017: KFS { *)
IF T_StartUp.T_State.xCompleted THEN
	IF ptrTCylToolLeftActive^.T_CtrleCyl.T_Standard.xActivOn AND ptrTAxisToolLeft^.T_CtrleSingle.xPower
	     AND NOT(ptrTAxisToolLeft^.T_CtrleSingle.xExecute) AND ptrTAxisToolLeft^.T_CtrleSingle.xDone THEN
		ptrTAxisToolLeft^.T_CtrleSingle.iFunction:=4;
		ptrTAxisToolLeft^.T_CtrleSingle.xExecute:=TRUE;
	END_IF;
	IF ptrTCylToolRightActive^.T_CtrleCyl.T_Standard.xActivOn AND ptrTAxisToolRight^.T_CtrleSingle.xPower
	     AND NOT(ptrTAxisToolRight^.T_CtrleSingle.xExecute) AND ptrTAxisToolRight^.T_CtrleSingle.xDone THEN
		ptrTAxisToolRight^.T_CtrleSingle.iFunction:=4;
		ptrTAxisToolRight^.T_CtrleSingle.xExecute:=TRUE;
	END_IF;
END_IF;
(*03.03.2017: KFS } *)
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_STATION_LAYER3' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_STATION
VAR
	FBStation: FB_STATION;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 5
_NETWORK

_COMMENT
'STATION LEVEL-->LAYER 3'
_END_COMMENT
_FUNCTIONBLOCK
FBStation
_BOX_EXPR : 12
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigAxisType
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeOut.QxContactor_K3
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeOut.QxContactor_K4
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_ProcessImageData
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard
_OPERATOR
_BOX_EXPR : 4
_OPERAND
_EXPRESSION
_NEGATIV
T_Process.xEnd
_OPERAND
_EXPRESSION
_NEGATIV
T_Process.xError
_OPERAND
_EXPRESSION
_POSITIV
T_Process.xRdy
_OPERAND
_EXPRESSION
_POSITIV
T_StartUp.T_State.xCompleted
_EXPRESSION
_POSITIV
AND
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_Cylinder.iSelectToolTensionForce
_OPERAND
_EXPRESSION
_POSITIV
T_Station
_OPERAND
_EXPRESSION
_POSITIV
T_StartUp
_EXPRESSION
_POSITIV
FB_STATION
_OUTPUTS : 10
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FBStation.bActivePartNumber
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_ExchgParam.T_InfoValueCommon.bActivePartNumber
_NETWORK

_COMMENT
''
_END_COMMENT
_RET
_EXPRESSION
_POSITIV
_OPERATOR
_BOX_EXPR : 3
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_Station.TControl.iFunctNr
_OPERAND
_EXPRESSION
_POSITIV
11
_EXPRESSION
_POSITIV
GE
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_Station.TControl.iFunctNr
_OPERAND
_EXPRESSION
_POSITIV
13
_EXPRESSION
_POSITIV
LE
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType
_OPERAND
_EXPRESSION
_POSITIV
1
_EXPRESSION
_POSITIV
EQ
_EXPRESSION
_NEGATIV
AND
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FBStation.lrProcessToolFeederActualPosition
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_ExchgParam.T_InfoValueCommon.rActualWireFeedPosition
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 1
_OPERAND
_EXPRESSION
_POSITIV
FBStation.lrProcessToolFeederSpeed
_EXPRESSION
_POSITIV
ABS
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_ExchgParam.T_InfoValueCommon.rActualWireFeedSpeed

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CALC_TORQUE
VAR_INPUT
	xStart:BOOL;				(* start the calculation of the mean value of the torque *)
	uiActualTorque:UINT;		(* actual current value *)
	uiZeroTorque:UINT;		(* set value of the current value for scale the range *)
	iStepCalc:INT;			(* number of mean value *)
END_VAR
VAR_OUTPUT
	uiCalcTorque:UINT;		(* calculated torque value in % of the maximal torque of the motor *)
END_VAR
VAR
	auiSaveTorque: ARRAY [1..200] OF UINT;
	auiTmpSaveTorque: ARRAY [1..200] OF UINT;
	auiDeleteTorque: ARRAY [1..200] OF UINT;
	uiSumTorque: UINT;
	ii: INT;
	xInit: BOOL;
	uiTmpZeroTorque:UINT;
	rMaxMotorCurrent: REAL;
	rMaxMotorTorque: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********             This Functionblock calc the torque of the ToolRotation with set and reset torque function                         ************)
(****************************************************************************************************************************************************)
uiCalcTorque:=0;
IF NOT(xStart) AND xInit THEN
	xInit:=FALSE;
	auiSaveTorque:=auiDeleteTorque;
	auiTmpSaveTorque:=auiDeleteTorque;
	uiTmpZeroTorque:=uiZeroTorque;
END_IF;
IF xStart THEN
	xInit:=TRUE;
	uiSumTorque:=0;
	IF (uiZeroTorque <> uiTmpZeroTorque) THEN
		auiSaveTorque:=auiDeleteTorque;
		auiTmpSaveTorque:=auiDeleteTorque;
		uiTmpZeroTorque:=uiZeroTorque;
	END_IF;
	IF (iStepCalc > 0) AND (iStepCalc <= 200) THEN
		FOR ii:=1 TO (iStepCalc - 1)  DO
			auiTmpSaveTorque[ii+1]:=auiSaveTorque[ii];
			uiSumTorque:=uiSumTorque + auiSaveTorque[ii];
		END_FOR;
		auiSaveTorque:=auiTmpSaveTorque;
		IF (uiTmpZeroTorque <= uiActualTorque) THEN
			auiSaveTorque[1]:=uiActualTorque - uiTmpZeroTorque;
		ELSE
			auiSaveTorque[1]:=0;
		END_IF;
		uiSumTorque:=uiSumTorque + auiSaveTorque[1];
		uiSumTorque:=uiSumTorque/iStepCalc;
		rMaxMotorCurrent:=6.0;	(* EcoStep Motor 23S21  *)
		rMaxMotorTorque:=(rMaxMotorCurrent * 0.16) * 1000.0;	(* 0.16 = 0.16Nm/A -->1000.0= Umwandlung in mNm *)
		uiCalcTorque:=REAL_TO_UINT((UINT_TO_REAL(uiSumTorque) / (REAL_TO_UINT(rMaxMotorTorque) - uiTmpZeroTorque)) * 100.0);	(* Ausgabe in % des Max Stromes *)
		IF (uiCalcTorque >= 100) THEN
			uiCalcTorque:=100;
		END_IF;
	END_IF;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_COMPAREPROFILEPROCESSVALUE
VAR_INPUT
	T_Data_ProcessImageLoadData:ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram parameter structure for the profile value *)
	T_Data_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;		(* Novram parametre structure for the process parameter *)
	xMicroRodActive: BOOL;											(* choice of the machine MicroWire or MicroRod *)
END_VAR
VAR_OUTPUT
	xProcessValueModified:BOOL;										(* TRUE=Profile parameter and process parameter are not the same, FALSE=both are same *)
END_VAR
VAR_IN_OUT
END_VAR
VAR
(* variable *)
	xFirstExecution:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***  This Functionblock check if the parameter of the loaded profile ar the same as the parameter of the process parameter   ***)
(****************************************************************************************************************************************************)
(* First execution *)
	IF NOT xFirstExecution THEN
		xProcessValueModified:=FALSE;
		(* confirm execution *)
		xFirstExecution:=TRUE;
	END_IF

(* compare value *)
	xProcessValueModified:=FALSE;

	(* value *)
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arStartDiameter[1] <> T_Data_ProcessImageData.T_GeometryPara.arStartDiameter[1] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arEndDiameter[1] <> T_Data_ProcessImageData.T_GeometryPara.arEndDiameter[1] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionLength[1] <> T_Data_ProcessImageData.T_GeometryPara.arSectionLength[1] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionPitch[1] <> T_Data_ProcessImageData.T_GeometryPara.arSectionPitch[1] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.axActiveSection[1] <> T_Data_ProcessImageData.T_GeometryPara.axActiveSection[1] THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_GeometryPara.arStartDiameter[2] <> T_Data_ProcessImageData.T_GeometryPara.arStartDiameter[2] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arEndDiameter[2] <> T_Data_ProcessImageData.T_GeometryPara.arEndDiameter[2] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionLength[2] <> T_Data_ProcessImageData.T_GeometryPara.arSectionLength[2] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionPitch[2] <> T_Data_ProcessImageData.T_GeometryPara.arSectionPitch[2] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.axActiveSection[2] <> T_Data_ProcessImageData.T_GeometryPara.axActiveSection[2] THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_GeometryPara.arStartDiameter[3] <> T_Data_ProcessImageData.T_GeometryPara.arStartDiameter[3] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arEndDiameter[3] <> T_Data_ProcessImageData.T_GeometryPara.arEndDiameter[3] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionLength[3] <> T_Data_ProcessImageData.T_GeometryPara.arSectionLength[3] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionPitch[3] <> T_Data_ProcessImageData.T_GeometryPara.arSectionPitch[3] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.axActiveSection[3] <> T_Data_ProcessImageData.T_GeometryPara.axActiveSection[3] THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_GeometryPara.arStartDiameter[4] <> T_Data_ProcessImageData.T_GeometryPara.arStartDiameter[4] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arEndDiameter[4] <> T_Data_ProcessImageData.T_GeometryPara.arEndDiameter[4] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionLength[4] <> T_Data_ProcessImageData.T_GeometryPara.arSectionLength[4] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.arSectionPitch[4] <> T_Data_ProcessImageData.T_GeometryPara.arSectionPitch[4] THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_GeometryPara.axActiveSection[4] <> T_Data_ProcessImageData.T_GeometryPara.axActiveSection[4] THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_PrismPara.rPrismaDistanceD1 <> T_Data_ProcessImageData.T_PrismPara.rPrismaDistanceD1 THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_PrismPara.rPrismaDistanceD2 <> T_Data_ProcessImageData.T_PrismPara.rPrismaDistanceD2 THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_PrismPara.rPrismaAngleA <> T_Data_ProcessImageData.T_PrismPara.rPrismaAngleA THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_PrismPara.bStateInputPrisma <> T_Data_ProcessImageData.T_PrismPara.bStateInputPrisma THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_PrismPara.rToolDiameterMin <> T_Data_ProcessImageData.T_PrismPara.rToolDiameterMin THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_PrismPara.rToolDiameterMax <> T_Data_ProcessImageData.T_PrismPara.rToolDiameterMax THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_PrismPara.rPrismaFactor <> T_Data_ProcessImageData.T_PrismPara.rPrismaFactor THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess <> T_Data_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_ProcessPara.rSecurityPosGrindFeedProcess <> T_Data_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_ProcessPara.rSpeedBackwardGrindFeed <> T_Data_ProcessImageData.T_ProcessPara.rSpeedBackwardGrindFeed THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_ProcessPara.rSpeedForwardFastGrindFeed <> T_Data_ProcessImageData.T_ProcessPara.rSpeedForwardFastGrindFeed THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_ProcessPara.rSpeedForwardSlowGrindFeed <> T_Data_ProcessImageData.T_ProcessPara.rSpeedForwardSlowGrindFeed THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF xMicroRodActive THEN
		IF T_Data_ProcessImageLoadData.T_ProcessPara.rSpeedStartPosToolFeedProcess <> T_Data_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess THEN xProcessValueModified:=TRUE; RETURN; END_IF
		IF T_Data_ProcessImageLoadData.T_ProcessPara.rStartPosToolFeedAuto <> T_Data_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto THEN xProcessValueModified:=TRUE; RETURN; END_IF
	END_IF;
	IF T_Data_ProcessImageLoadData.T_ProcessPara.rToolDiameterProcess <> T_Data_ProcessImageData.T_ProcessPara.rToolDiameterProcess THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_ProcessPara.rToolTensionProcess <> T_Data_ProcessImageData.T_ProcessPara.rToolTensionProcess THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.iCycleGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.iCycleGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF xMicroRodActive THEN
		IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	END_IF;
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.rPlungeLengthToolFeedGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.rPlungeLengthToolFeedGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.rSpeedToolRotationGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.xDisplaceActivationGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.xDisplaceActivationGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGeometryPara.xPlungeActivationGeometry <> T_Data_ProcessImageData.T_AutoGeometryPara.xPlungeActivationGeometry THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.rDisplaceLengthToolFeedGroove <> T_Data_ProcessImageData.T_AutoGroovePara.rDisplaceLengthToolFeedGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove <> T_Data_ProcessImageData.T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.rPitchGroove <> T_Data_ProcessImageData.T_AutoGroovePara.rPitchGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.rPlungeLengthToolFeedGroove <> T_Data_ProcessImageData.T_AutoGroovePara.rPlungeLengthToolFeedGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.rPlungeSpeedGrindFeedGroove <> T_Data_ProcessImageData.T_AutoGroovePara.rPlungeSpeedGrindFeedGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.rSpeedToolRotationGroove <> T_Data_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.xDisplaceActivationGroove <> T_Data_ProcessImageData.T_AutoGroovePara.xDisplaceActivationGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.xPlungeActivationGroove <> T_Data_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.xBlockGrindFeeder <> T_Data_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_AutoGroovePara.iNumberOfGrooves <> T_Data_ProcessImageData.T_AutoGroovePara.iNumberOfGrooves THEN xProcessValueModified:=TRUE; RETURN; END_IF

	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rDisplaceLengthToolFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rDisplaceLengthToolFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rDisplaceSpeedGrindFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rDisplaceSpeedGrindFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF NOT(xMicroRodActive) THEN
		IF T_Data_ProcessImageLoadData.T_CalibrationPara.rMeasureOffsetToolFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rMeasureOffsetToolFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	END_IF;
	IF xMicroRodActive THEN
		IF T_Data_ProcessImageLoadData.T_CalibrationPara.rMeasurePosToolFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rMeasurePosToolFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
		IF T_Data_ProcessImageLoadData.T_CalibrationPara.rStartPosToolFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rStartPosToolFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	END_IF;
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rPitchCalib <> T_Data_ProcessImageData.T_CalibrationPara.rPitchCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rPlungeLengthGrindFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rPlungeLengthGrindFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rPlungeLengthToolFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rPlungeLengthToolFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rPlungeSpeedGrindFeedCalib <> T_Data_ProcessImageData.T_CalibrationPara.rPlungeSpeedGrindFeedCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rSpeedToolRotationCalib <> T_Data_ProcessImageData.T_CalibrationPara.rSpeedToolRotationCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.rToolLengthCylinderPartCalib <> T_Data_ProcessImageData.T_CalibrationPara.rToolLengthCylinderPartCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.xDisplaceActivationCalib <> T_Data_ProcessImageData.T_CalibrationPara.xDisplaceActivationCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
	IF T_Data_ProcessImageLoadData.T_CalibrationPara.xPlungeActivationCalib <> T_Data_ProcessImageData.T_CalibrationPara.xPlungeActivationCalib THEN xProcessValueModified:=TRUE; RETURN; END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CTRLEBUTTON
VAR_INPUT
	xHWStart:BOOL;							(* external start button *)
	xHWStop:BOOL;							(* external stop button *)
	dwActualPage:DWORD;					(* active number page of the visualisation *)
	T_VisuQVis:ST_QVIS;						(* data structure of the visualisation *)
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;	(* data structure of the visualisation *)
	IxSafetyCircuitOn1:BOOL;					(* state of current if it is on or off from the channel 1 *)
	IxSafetyCircuitOn2:BOOL;					(* state of current if it is on or off from the channel 2 *)
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_StartButton: ST_BUTTON;				(* data structure of the control button start *)
	T_StopButton:ST_BUTTON;				(* data structure of the control button stop *)
END_VAR
VAR
(* Init. variable *)
	xFirstExecution:BOOL:=FALSE;
(* Variable *)
	iIndexActivPage:INT;
	dwOldActualPage:DWORD;
(* FB Mask *)
	xMaskPageBtStart:BOOL;
	xMaskPageBtStop:BOOL;
(* Trigger *)
	RisingEdgeSignalStartButton:R_TRIG;
	RisingEdgeStartState:R_TRIG;
	RisingEdgeCfgBtStart:R_TRIG;
	RisingEdgeSignalStopButton:R_TRIG;
	RisingEdgeFlagStopProcess:R_TRIG;
(* Tmp variable *)
	xTmp:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********             This Functionblock manage the external start and stop butto, also for the lamp of this button                  ************)
(****************************************************************************************************************************************************)
(* First execution *)
	IF NOT xFirstExecution THEN
		dwOldActualPage:=16#FFFFFFFF;
		RisingEdgeSignalStartButton(CLK:=FALSE);
		RisingEdgeStartState(CLK:=FALSE);
		RisingEdgeCfgBtStart(CLK:=FALSE);
		RisingEdgeSignalStopButton(CLK:=FALSE);
		RisingEdgeFlagStopProcess(CLK:=FALSE);
		(* Set first execution *)
		xFirstExecution:=TRUE;
	END_IF

(* exit FB if Qvis inactiv *)
	IF NOT(T_VisuQVis.T_CtrleVisu.xQvis) THEN RETURN; END_IF
	IF (dwActualPage < 1) OR (dwActualPage > 999) THEN RETURN; END_IF;

(* Index Activ Page *)
	IF dwActualPage = 0 THEN iIndexActivPage:=1;
	ELSE iIndexActivPage:=T_VisuQVis.T_PageIndex[dwActualPage].iIndexConfigPage; END_IF

(* Start Button *)
	xMaskPageBtStart:=FALSE;
	CASE dwActualPage OF
	(* Auto Geometry page *)
	10:	xTmp:=TRUE;
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR (T_ExchgParam.T_Visu.T_Message.iState = 108) THEN
			xTmp:=FALSE;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Auto Groove page *)
	20:	xTmp:=TRUE;
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR (T_ExchgParam.T_Visu.T_Message.iState = 108) THEN
			xTmp:=FALSE;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Reference page *)
	30:	xTmp:=TRUE;
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_StationCommon.iConfigMachineType = 1) THEN
			xTmp:=FALSE;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Tool Calibration page *)
	110:	xTmp:=TRUE;
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR
		     (T_ExchgParam.T_Visu.T_Message.iState = 108) THEN
			xTmp:=FALSE;
		END_IF;
		IF ((T_ExchgParam.T_Machine.T_Process.wState AND 16#6) = 16#2) THEN
			xTmp:=FALSE;
		END_IF;
		IF T_ExchgParam.T_FunctionCommon.xOpenOverlayMeasureInput OR T_ExchgParam.T_FunctionCommon.xOpenOverlaySetGrindPlunge THEN
			xTmp:=FALSE;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Teach-in Tool Rotation page *)
	210:	xTmp:=	((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#1);
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR
		     (T_ExchgParam.T_Visu.T_Message.iState = 101) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_TeachIn.iSelectAxisToolRotation = 1) AND xTmp THEN
			IF ((T_ExchgParam.T_StationCommon.bStateAxisReelLeft AND 16#2) = 16#2) THEN
				xTmp:=FALSE;
			END_IF;
		END_IF;
		IF (T_ExchgParam.T_TeachIn.iSelectAxisToolRotation = 2) AND xTmp THEN
			IF ((T_ExchgParam.T_StationCommon.bStateAxisReelCenter AND 16#2) = 16#2) THEN
				xTmp:=FALSE;
			END_IF;
		END_IF;
		IF (T_ExchgParam.T_TeachIn.iSelectAxisToolRotation = 3) AND xTmp THEN
			IF ((T_ExchgParam.T_StationCommon.bStateAxisReelRight AND 16#2) = 16#2) THEN
				xTmp:=FALSE;
			END_IF;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Tool Torque page *)
	220:	xTmp:=	((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#1);
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR
		     (T_ExchgParam.T_Visu.T_Message.iState = 101) THEN
			xTmp:=FALSE;
		END_IF;
		IF ((T_ExchgParam.T_StationCommon.bStateAxisReelLeft AND 16#2) = 16#2) THEN
			xTmp:=FALSE;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Teach-in Tool Feeder page *)
	310:	xTmp:=	xTmp:=	((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#1);
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR
		     (T_ExchgParam.T_Visu.T_Message.iState = 101) OR (T_ExchgParam.T_Visu.T_Message.iState = 18) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_TeachIn.iSelectAxisWireFeeder = 1) AND xTmp THEN
			IF ((T_ExchgParam.T_StationCommon.bStateAxisWireFeeder AND 16#2) = 16#2) THEN
				xTmp:=FALSE;
			END_IF;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Teach-in Tool Feeder page *)
	330:	xTmp:=	xTmp:=	((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#1);
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR
		     (T_ExchgParam.T_Visu.T_Message.iState = 101) OR (T_ExchgParam.T_Visu.T_Message.iState = 18) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_TeachIn.iSelectAxisWireFeeder = 1) AND xTmp THEN
			IF ((T_ExchgParam.T_StationCommon.bStateAxisWireFeeder AND 16#2) = 16#2) THEN
				xTmp:=FALSE;
			END_IF;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	(* Teach-in Grind Feeder page *)
	410:	xTmp:=	xTmp:=	((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#1);
		IF xTmp AND (NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2)) THEN
			xTmp:=FALSE;	(* Energieversorgung muss eingeschaltet sein *)
		END_IF;
		IF xTmp AND ((T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0)) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) OR
		     (T_ExchgParam.T_Visu.T_Message.iState = 101) THEN
			xTmp:=FALSE;
		END_IF;
		IF (T_ExchgParam.T_TeachIn.iSelectAxisGrind = 1) AND xTmp THEN
			IF ((T_ExchgParam.T_StationCommon.bStateAxisGrind AND 16#2) = 16#2) THEN
				xTmp:=FALSE;
			END_IF;
		END_IF;
		(* copy state *)
		xMaskPageBtStart:=xTmp;
	END_CASE

	(* Set state button start *)
	RisingEdgeSignalStartButton(CLK:=xHWStart);
	IF RisingEdgeSignalStartButton.Q THEN T_StartButton.xInputState:=TRUE; ELSE T_StartButton.xInputState:=FALSE; END_IF
	T_StartButton.xInputState:=T_StartButton.xInputState AND T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStart;

	(* if page change => init. trigger *)
	IF dwActualPage <> dwOldActualPage THEN
		RisingEdgeStartState(CLK:=FALSE);
		RisingEdgeCfgBtStart(CLK:=FALSE);
		(* save value *)
		dwOldActualPage:=dwActualPage;
	END_IF

	(* Led off if action is starting *)
	RisingEdgeStartState(CLK:=T_StartButton.xInputState);
	IF RisingEdgeStartState.Q THEN T_StartButton.xLedState:=FALSE; END_IF
	RisingEdgeCfgBtStart(CLK:=xMaskPageBtStart);
	IF RisingEdgeCfgBtStart.Q THEN T_StartButton.xLedState:=TRUE; END_IF
	T_StartButton.xLedState:=T_StartButton.xLedState AND T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStart;

	(* set page mask *)
	T_StartButton.xInputState:=T_StartButton.xInputState AND xMaskPageBtStart;
	T_StartButton.xLedState:=T_StartButton.xLedState AND xMaskPageBtStart;

(* Stop Button *)
	xMaskPageBtStop:=FALSE;
	RisingEdgeSignalStopButton(CLK:=xHWStop);
	IF RisingEdgeSignalStopButton.Q THEN T_StopButton.xInputState:=TRUE; ELSE T_StopButton.xInputState:=FALSE; END_IF
	T_StopButton.xInputState:=T_StopButton.xInputState AND T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStop;
	T_StopButton.xLedState:=T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStop;

	(* if machine process inactiv => set mask inactiv *)
	IF dwActualPage > 0 THEN
		IF (T_ExchgParam.T_Machine.T_Process.wState AND 16#14) = 16#0 THEN
		(* process activ and no error *)
			IF (T_ExchgParam.T_Machine.T_Process.wState AND 16#80) = 16#0 THEN xMaskPageBtStop:=TRUE; ELSE xMaskPageBtStop:=FALSE; END_IF
		ELSIF ((dwActualPage = 210) OR (dwActualPage = 310) OR (dwActualPage = 410)) THEN
			(* Achse muss Aktiv sein, Stationsendflag muss gesetzt sein, Prozessendflag muss gesetzt sein *)
			IF ((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#3) AND ((T_ExchgParam.T_Machine.T_Process.wState AND 16#2) = 16#0) THEN
				xMaskPageBtStop:=TRUE;
			END_IF;
			(* Achse darf nicht Aktiv sein, Stationsendflag muss gesetzt sein,  Prozessendflag muss gesetzt sein *)
			IF ((T_ExchgParam.T_StationCommon.bStateMachine AND 16#7) = 16#1) AND ((T_ExchgParam.T_Machine.T_Process.wState AND 16#2) = 16#0) THEN
				xMaskPageBtStop:=FALSE;
				IF (T_ExchgParam.T_TeachIn.iSelectAxisToolRotation = 1) AND (dwActualPage = 210) THEN
					IF ((T_ExchgParam.T_StationCommon.bStateAxisReelLeft AND 16#2) = 16#2) THEN
						xMaskPageBtStop:=TRUE;
					END_IF;
				END_IF;
				IF (T_ExchgParam.T_TeachIn.iSelectAxisToolRotation = 2) AND (dwActualPage = 210) THEN
					IF ((T_ExchgParam.T_StationCommon.bStateAxisReelCenter AND 16#2) = 16#2) THEN
						xMaskPageBtStop:=TRUE;
					END_IF;
				END_IF;
				IF (T_ExchgParam.T_TeachIn.iSelectAxisToolRotation = 3) AND (dwActualPage = 210) THEN
					IF ((T_ExchgParam.T_StationCommon.bStateAxisReelRight AND 16#2) = 16#2) THEN
						xMaskPageBtStop:=TRUE;
					END_IF;
				END_IF;
				IF (T_ExchgParam.T_TeachIn.iSelectAxisWireFeeder = 1) AND (dwActualPage = 310) THEN
					IF ((T_ExchgParam.T_StationCommon.bStateAxisWireFeeder AND 16#2) = 16#2) THEN
						xMaskPageBtStop:=TRUE;
					END_IF;
				END_IF;
				IF (T_ExchgParam.T_TeachIn.iSelectAxisGrind = 1) AND (dwActualPage = 410) THEN
					IF ((T_ExchgParam.T_StationCommon.bStateAxisGrind AND 16#2) = 16#2) THEN
						xMaskPageBtStop:=TRUE;
					END_IF;
				END_IF;
			END_IF;
			IF (T_VisuQVis.T_CtrleAction.iFunction = 301) AND NOT(T_VisuQVis.T_CtrleAction.xDone) THEN
				xMaskPageBtStop:=FALSE;
			END_IF;
		ELSIF (dwActualPage = 220) THEN
			(* Achse muss Aktiv sein, Stationsendflag muss gesetzt sein, Prozessendflag muss gesetzt sein *)
			xMaskPageBtStop:=FALSE;
			IF ((T_ExchgParam.T_StationCommon.bStateAxisReelLeft AND 16#2) = 16#2) THEN
				xMaskPageBtStop:=TRUE;
			END_IF;
			IF (T_VisuQVis.T_CtrleAction.iFunction = 403) AND NOT(T_VisuQVis.T_CtrleAction.xDone) THEN
				xMaskPageBtStop:=FALSE;
			END_IF;
		(* process inactiv *)
		ELSE xMaskPageBtStop:=FALSE; END_IF
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) OR (T_ExchgParam.T_Visu.T_Message.iState = 118) OR (T_ExchgParam.T_Visu.T_Message.iState = 119) THEN
			xMaskPageBtStop:=FALSE;
		END_IF;
		IF NOT(IxSafetyCircuitOn1) OR NOT(IxSafetyCircuitOn2) THEN
			xMaskPageBtStop:=FALSE;
		END_IF;
	END_IF

	(* set page mask *)
	T_StopButton.xInputState:=T_StopButton.xInputState AND xMaskPageBtStop;
	T_StopButton.xLedState:=T_StopButton.xLedState AND xMaskPageBtStop;


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PROFILE_FILE
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Data_ProcessImageLoadData:ST_RETAIN_DATA_PROCESSIMAGE;		(* Novram parameter structure for the profile value *)
	T_Data_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;			(* Novram parametre structure for the process parameter *)
	T_Profile:ST_PROFILE;												(* data structure for the profile mangement *)
	T_HDD:ST_HDD;														(* data structure for the file managment *)
END_VAR
VAR
(* Timer *)
	TimerOut:TON;
(* Trigger *)
	RisingEdgeReset:R_TRIG;
	RisingEdgeExecute:R_TRIG;
(* variable *)
	xConfirmResetFB:BOOL;
	xReadProfile:BOOL;
	xWriteProfile:BOOL;
	xReadProfileListeStation: BOOL;
	iStepFunction:INT;
	xStepFunctionDone:BOOL;
	tTimeOut: TIME;
(* Tmp *)
	xTmp:BOOL;
	sTmp:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                       This Functionblock manage the profile for read and write to a file                                            ************)
(****************************************************************************************************************************************************)
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_Profile.T_Ctrle.xReset);
	IF RisingEdgeReset.Q THEN
	(* init. structure *)
		T_Profile.T_Ctrle.xDone:=FALSE;
		T_Profile.T_Ctrle.xErr:=FALSE;
		T_Profile.T_Ctrle.udiErrorID:=0;
		T_Profile.T_Ctrle.iFunction:=0;
		(* Reset HDD if error activ *)
		IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; END_IF
		(* Init. variable *)
		xReadProfile:=FALSE;
		xWriteProfile:=FALSE;
		xReadProfileListeStation:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=0;
			T_Profile.T_Ctrle.iFunction:=0;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* waiting for execute *)
	RisingEdgeExecute(CLK:=T_Profile.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_Profile.T_Ctrle.iFunction OF
		(* read profile *)
		1:	xReadProfile:=TRUE;
			tTimeOut:=T#5s;
		(* write profile *)
		2:	xWriteProfile:=TRUE;
			tTimeOut:=T#5s;
		(* read profile liste station *)
		3:	xReadProfileListeStation:=TRUE;
			tTimeOut:=T#20s;
		ELSE
		(* function not implemented *)
			 T_Profile.T_Ctrle.xDone:=FALSE;
			 T_Profile.T_Ctrle.xErr:=TRUE;
			 T_Profile.T_Ctrle.udiErrorID:=16#F000;
			 (* exit FB *)
			 RETURN;
		END_CASE
		(* Init. variable *)
		T_Profile.T_Ctrle.xDone:=FALSE;
		T_Profile.T_Ctrle.xErr:=FALSE;
		T_Profile.T_Ctrle.udiErrorID:=16#0;
		(* init. step *)
		iStepFunction:=1;
		xStepFunctionDone:=FALSE;
		RETURN;
	END_IF

(* Monitor time out *)
	xTmp:=	NOT T_Profile.T_Ctrle.xDone
			AND NOT T_Profile.T_Ctrle.xErr;
	TimerOut(IN:=xTmp, PT:=tTimeOut);
	IF TimerOut.Q THEN iStepFunction:=99; END_IF

(* Read profile *)
	IF xReadProfile OR xWriteProfile THEN
		CASE iStepFunction OF
		(* check if HDD state *)
		1:	xTmp:=	T_HDD.T_Ctrle.xDone
					AND NOT T_HDD.T_Ctrle.xExecute
					AND NOT T_HDD.T_Ctrle.xErr
					AND NOT T_HDD.T_Ctrle.xLocked;
			IF xTmp THEN iStepFunction:=10; ELSE iStepFunction:=95; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=99; END_IF
		(* file name and activ read *)
		10:	sTmp:='\Hard Disk\Machine450\Profile\';
			sTmp:=CONCAT(sTmp,T_Profile.T_Id.sName);
			IF xReadProfile THEN
			(* activ read *)
				T_HDD.T_Ctrle.iFunction:=1;
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=20;
				xStepFunctionDone:=FALSE;
			(* activ write *)
			ELSE
				(* copy profile to HDD data structure *)

				IF xFctCopyProfileToDataFile(	ptrData_ProcessImageData:=ADR(T_Data_ProcessImageData),
											ptrDataFile:=ADR(T_HDD.T_Data))	THEN iStepFunction:=50; ELSE iStepFunction:=99; END_IF;
				(* next step *)
				xStepFunctionDone:=FALSE;
			END_IF
		(* waiting flag *)
		20:	IF T_HDD.T_Ctrle.xDone THEN iStepFunction:=30; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=80; END_IF
		(* copy value from HDD to Profile structure *)
		30:	IF xFctCopyDataFileToProfile(	ptrData_ProcessImageLoadData:=ADR(T_Data_ProcessImageLoadData),
										ptrDataFile:=ADR(T_HDD.T_Data))	THEN iStepFunction:=90; ELSE iStepFunction:=99; END_IF;
		(* activ write *)
		50:	sTmp:='\Hard Disk\Machine450\Profile\';
			sTmp:=CONCAT(sTmp,T_Profile.T_Id.sName);
			T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
			T_HDD.T_Ctrle.iFunction:=2;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=60;
			xStepFunctionDone:=FALSE;
		(* waiting flag *)
		60:	IF T_HDD.T_Ctrle.xDone THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=80; END_IF
		(* reset error *)
		80:	T_HDD.T_Ctrle.xReset:=TRUE;
			iStepFunction:=99;
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		(* not ready *)
		95:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		(* error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		END_CASE
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_SETERRORLIST
VAR_INPUT
	TControlStation : ST_CONTROL;					(* Control structur of the data station structure *)
	TProcess : ST_PROCESS;						(* data structure of the processlevel *)
END_VAR
VAR_IN_OUT
	xParameterSaved:BOOL;						(* state, if the changed errorlist was saved *)
	T_ErrorNrList:ST_RETAIN_ERROR_DATA;		(* Daten welche im NOVram abgelegt sind *)
	xSetForceError:BOOL;							(* manual input of an error into the error list *)
	diSetForceErrorNr:DINT;						(* manual input of an error number into the error list *)
END_VAR
VAR_OUTPUT
	xSaveParameter:BOOL;						(* save the maked or updated error list into the Novram *)
END_VAR
VAR
	xTmpStation: BOOL;
	xTmpProcess: BOOL;
	iTmpStationNr:INT;
	xBlockProcessProc: BOOL;
	xBlockStationProc: BOOL;
	adiTmpErrorList: ARRAY [1..20] OF DINT;
	asTmpErrorList: ARRAY [1..20] OF STRING(12);
	ii:INT;
	xDataChanged: BOOL;
	xQuitError: BOOL;
	TimerCheckQuitError:TON;
	FBNT_GetTime:NT_GetTime;
	xUpdateProcTimeStamp:BOOL;
	xInitGetTime: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                       This Functionblock manage the machine error, for make and update the errorlist                             ************)
(****************************************************************************************************************************************************)
xTmpStation:=TControlStation.xError AND TControlStation.xActiveStation;
xTmpProcess:=TProcess.xError AND TProcess.xRdy;

IF NOT(xDataChanged) THEN
	IF NOT(TProcess.xEnd) AND TProcess.xError AND NOT(xBlockProcessProc) AND NOT(xBlockStationProc) AND NOT(xSetForceError) THEN
		xBlockProcessProc:=TRUE;
		iTmpStationNr:=0;
	END_IF;
	IF TProcess.xEnd AND xTmpStation AND NOT(xBlockStationProc) AND NOT(xBlockProcessProc) AND NOT(xSetForceError) THEN
		xBlockStationProc:=TRUE;
		iTmpStationNr:=1;
	END_IF;
	IF xBlockProcessProc AND NOT(xQuitError) THEN
		adiTmpErrorList:=T_ErrorNrList.adiErrorListMachine;
		T_ErrorNrList.adiErrorListMachine[1]:=TProcess.diErrorNr;
		FOR ii:=2 TO 20 DO
			T_ErrorNrList.adiErrorListMachine[ii]:=adiTmpErrorList[ii-1];
		END_FOR;
		xUpdateProcTimeStamp:=TRUE;
	END_IF;
	
	IF xBlockStationProc AND NOT(xQuitError) THEN
		adiTmpErrorList:=T_ErrorNrList.adiErrorListMachine;
		T_ErrorNrList.adiErrorListMachine[1]:=TControlStation.diErrorNr;
		FOR ii:=2 TO 20 DO
			T_ErrorNrList.adiErrorListMachine[ii]:=adiTmpErrorList[ii-1];
		END_FOR;
		xUpdateProcTimeStamp:=TRUE;
	END_IF;
	
	IF xSetForceError AND NOT(xQuitError) AND NOT(xBlockStationProc) AND NOT(xBlockProcessProc) THEN
		adiTmpErrorList:=T_ErrorNrList.adiErrorListMachine;
		T_ErrorNrList.adiErrorListMachine[1]:=diSetForceErrorNr;
		FOR ii:=2 TO 20 DO
			T_ErrorNrList.adiErrorListMachine[ii]:=adiTmpErrorList[ii-1];
		END_FOR;
		xUpdateProcTimeStamp:=TRUE;
		xSetForceError:=FALSE;
	ELSE
		xSetForceError:=FALSE;
	END_IF;

	IF xUpdateProcTimeStamp THEN
		IF NOT(xInitGetTime) THEN
			xInitGetTime:=TRUE;
			FBNT_GetTime(	NETID:= '',
							START:=FALSE );
		END_IF;
		FBNT_GetTime(	NETID:= '',
						START:= TRUE,
						TMOUT:= T#2s);
		IF NOT(FBNT_GetTime.BUSY) OR FBNT_GetTime.ERR THEN
			IF xUpdateProcTimeStamp THEN
				asTmpErrorList:=T_ErrorNrList.asErrorTimeStampMachine;
				IF NOT(FBNT_GetTime.ERR) THEN
					T_ErrorNrList.asErrorTimeStampMachine[1]:=Fct_ConvertDateToString(2,FBNT_GetTime.TIMESTR);
				ELSE
					T_ErrorNrList.asErrorTimeStampMachine[1]:='00.00 00:00';	(* Fehler beim lesen der Systemzeit, daher wird ein default-Wert gesetzt *)
				END_IF;
				FOR ii:=2 TO 20 DO
					T_ErrorNrList.asErrorTimeStampMachine[ii]:=asTmpErrorList[ii-1];
				END_FOR;
			END_IF;
			xInitGetTime:=FALSE;
			xUpdateProcTimeStamp:=FALSE;
			xDataChanged:=TRUE;
		END_IF;
	END_IF;
END_IF;

IF xBlockProcessProc OR xBlockStationProc THEN
	xQuitError:=TRUE;
	IF TControlStation.xQuitError OR TProcess.xQuitError THEN
		xBlockProcessProc:=xBlockStationProc:=xSetForceError:=xQuitError:=FALSE;
	END_IF;
	IF NOT(xTmpStation) AND NOT(xTmpProcess) THEN
		TimerCheckQuitError(IN:=TRUE,PT:=T#1s);
		IF TimerCheckQuitError.Q THEN
			TimerCheckQuitError(IN:=FALSE);
			xBlockProcessProc:=xBlockStationProc:=xSetForceError:=xQuitError:=FALSE;
		END_IF;
	ELSE
		TimerCheckQuitError(IN:=FALSE);
	END_IF;
ELSE
	xQuitError:=FALSE;
END_IF;

IF xDataChanged THEN
	xSaveParameter:=TRUE;
	IF xParameterSaved THEN
		xParameterSaved:=xDataChanged:=xSaveParameter:=FALSE;
	END_IF;
END_IF;


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBPW_SYSTEM
VAR_INPUT
	dwCounter:DWORD;		(* number for generate the key *)
END_VAR
VAR_OUTPUT
	iRandom:INT;				(* generated key number for the password *)
	iPwSystem:INT;			(* level of the password *)
END_VAR
VAR
	i:INT;
	iCounter:INT;
	sTmp:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                           This Functionblock is for the dynamic password, it generate a key number                                     ************)
(****************************************************************************************************************************************************)
(*
	dynamic System password
	ex : Counter=12345 => pw=55
	formul : 1+2+3+4+5 + 40 = 55
*)

(* Init. value *)
	iPwSystem:=0;
(* Convert value *)
	iCounter:=DWORD_TO_INT(dwCounter);
	IF iCounter<0 THEN iCounter:=iCounter*-1; END_IF
(* Set Random value *)
	iRandom:=iCounter;
	sTmp:=INT_TO_STRING(iCounter);
(* Set System pw *)
	FOR i:=0 TO LEN(sTmp)-1 DO
		iPwSystem:=iPwSystem+STRING_TO_INT(MID(sTmp,1,LEN(sTmp)-i));
		IF i=1 THEN iPwSystem:=iPwSystem+STRING_TO_INT(MID(sTmp,1,LEN(sTmp)-i))*10; END_IF
	END_FOR
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBQVIS
VAR_INPUT
	xStartButton:BOOL;					(* external start button *)
	xStopButton:BOOL;					(* external stop button *)
	xSecurityKey:BOOL;					(* state of the keyswitch *)
	wSPSSpecialButton:WORD;			(* input of the special button of the controlpanel *)
	T_TwinSafeOut:ST_TWINSAFE_OUT;	(* Output of the TwinSAFE components *)
	T_TwinSafeIn:ST_TWINSAFE_IN;		(* Input of the TwinSAFE components *)
(*22.12.2009: KFS	{	*)
	xToolLeftButton:BOOL;					(* Signal of the button for closing the ToolLeft-->this is only for the MicroRod *)
	xToolRightButton:BOOL;				(* Signal of the button for closing the ToolRight-->this is only for the MicroRod *)
	xToolCenterButton:BOOL;				(* Signal of the button for closing the ToolCenter-->this is only for the MicroRod *)
	xToolPrismaLeftButton:BOOL;			(* Signal of the button for closing the ToolPrismaLeft-->this is only for the MicroRod *)
	xToolPrismaRightButton:BOOL;			(* Signal of the button for closing the ToolPrismaRight-->this is only for the MicroRod *)
	xToolTensionButton:BOOL;				(* Signal of the button for activate the ToolTension-->this is only for the MicroRod *)
(*22.12.2009: KFS	}	*)
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Visu:ST_QVIS;
	T_CtrleQVis:ST_QVISCTRLE;
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;
	T_StartUp:ST_STARTUP;
END_VAR
VAR
	RisingEdgeActiv:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	RisingEdgeExecuteAction:R_TRIG;
	RisingEdgeBtPanelLeft:R_TRIG;
	FallingEdgeBtPanelLeft:F_TRIG;
	RisingEdgeSpecialLayer:R_TRIG;
	FallingEdgeSpecialLayer:F_TRIG;
	RisingEdgeTouchScreenNavPanel:R_TRIG;
	FallingEdgeTouchScreenNavPanel:F_TRIG;
	RisingEdgeBtPanelRight:R_TRIG;
	FallingEdgeBtPanelRight:F_TRIG;
	RisingEdgeBtFunctionPanel:R_TRIG;
	FallingEdgeBtFunctionPanel:F_TRIG;
	RisingEdgeDynPassword:R_TRIG;
	RisingEdgeGeometryManagement:R_TRIG;
	RisingEdgeToolDiameter:R_TRIG;
	RisingEdgePrisma:R_TRIG;
	xChangePage:BOOL:=FALSE;
	dwInCount_QVisCmd:DWORD:=0;
	xTmp: BOOL;
	wActivBtLeft: WORD;
	wActivBtRight: WORD;
	fbQvisInitPage:FBQVIS_INITPAGE;
	xNavPanelChangePage: BOOL;
	xBtPanelLeftChangePage:BOOL;
	xNextPageVertical:BOOL;
	xSetParameterPage:BOOL;
	xActivationSection1: BOOL;
	xActivationSection2: BOOL;
	xActivationSection3: BOOL;
	xActivationSection4: BOOL;
	xSetPitchEqual: BOOL;
	iStepAction: INT;
	xStepActionDone: BOOL;
	bOldActivSpecialLayer: BYTE;
	wSpecialLayerGeneralActivTask: WORD;
	wSpecialLayerToolRotActivTask: WORD;
	wSpecialLayerWireFeedActivTask: WORD;
	wSpecialLayerGrindAxisActivTask: WORD;
	wSpecialLayerGeneralActivPage: WORD;
	wSpecialLayerToolRotActivPage: WORD;
	wSpecialLayerWireFeedActivPage: WORD;
	wSpecialLayerGrindAxisActivPage: WORD;
	dwSetNewPage: DWORD;
	wNormalLayerActivTask: WORD;
	wNormalLayerActivPage: WORD;
	ii: INT;
	wTmp: WORD;
	awNormalLayerActivPage:ARRAY [1..6] OF WORD;
	awSpecialLayerGeneralActivPage:ARRAY [1..6] OF WORD;
	awSpecialLayerToolRotActivPage:ARRAY [1..6] OF WORD;
	awSpecialLayerWireFeedActivPage:ARRAY [1..6] OF WORD;
	awSpecialLayerGrindAxisActivPage:ARRAY [1..6] OF WORD;
	wTmpNormalLayerActivTask: WORD;
	wTmpSpecialLayerGeneralActivTask: WORD;
	wTmpSpecialLayerToolRotActivTask: WORD;
	wTmpSpecialLayerWireFeedActivTask: WORD;
	wTmpSpecialLayerGrindAxisActivTask: WORD;
	wStandardPageNr: WORD;
	iTmpActivBtLeft: INT;
	(* Random *)
	fbGetCpuAccount:GETCPUCOUNTER;
	fbPwSystem:FBPW_SYSTEM;
(* Pw *)
	iPwSystem:INT;
	iStepCounter: INT;
	arSaveToolGeometry:ST_GEOMETRY;
	rSectionPitch: REAL;
	ptxActiveSection1: POINTER TO BOOL;
	ptxActiveSection2: POINTER TO BOOL;
	ptxActiveSection3: POINTER TO BOOL;
	ptxActiveSection4: POINTER TO BOOL;
	xOverlayMeasureToolDia: BOOL;
	xPlungeActivation: BOOL;
	xDisplaceActivation: BOOL;
	xCorrectionToolDiameterAdd: BOOL;
	xCorrectionToolDiameterAddMore: BOOL;
	xCorrectionToolDiameterSub: BOOL;
	xCorrectionToolDiameterSubMore: BOOL;
	xResetToolDiameterCorrection: BOOL;
	xKeyPadActivation: BOOL;
	xFctCorrectionToolDiameter: BOOL;
	rCorrectionValue: REAL;

(* Key panel button "Esc"/"Enter" *)
	RisingEdgeKeyPanel_Esc:R_TRIG;
	RisingEdgeKeyPanel_Enter:R_TRIG;
(*22.12.2009: KFS	{	 *)
(* External button for the tool-clamping*)
	RisingEdgeBtToolLeft:R_TRIG;
	RisingEdgeBtToolRight:R_TRIG;
	RisingEdgeBtToolCenter:R_TRIG;
	RisingEdgeBtToolPrismaLeft:R_TRIG;
	RisingEdgeBtToolPrismaRight:R_TRIG;
	RisingEdgeBtToolTension:R_TRIG;
(*22.12.2009: KFS	}	 *)
(* variable start action *)
	TimerAction:TON;
	TimerNotReady:TOF;
	tTimeOutAction:TIME;
	xSelectPrisma: BOOL;
	xToolTensForceAdd: BOOL;
	xToolTensForceAddMore: BOOL;
	xToolTensForceSub: BOOL;
	xToolTensForceSubMore: BOOL;
	xResetCalculToolRotTorque: BOOL;
	rCalcTotalToolLength: REAL;
	xTmpSecurityKey: BOOL;
	RisingEdgeTemp:R_TRIG;
	TONWAIT: TON;
	xPart1: BOOL;
	xPart2: BOOL;
	xPart3: BOOL;
	xPart4: BOOL;
	iPartActive: INT;
	xToolRotationMasterSlave: BOOL;
	xSwitchMasterSlave: BOOL;
	xQvisActiv: BOOL;
	TimerQVis: TON;
	RisingEdgeReset:R_TRIG;
	xConfirmResetFB: BOOL;
	xFirstRead: BOOL;
	ptrTeachINAxis:POINTER TO ST_AXIS;
	ptrCylAction:POINTER TO ST_CYLINDER;
	xStopAxis: BOOL;
	xMoveRelPosition: BOOL;
	TParaAxisTeachIN:ST_EXCHG_PARAM_TEACHIN;
	xMoveContinousVel: BOOL;
	xMoveAbsPosition: BOOL;
	bButtonPanelLocked: BYTE;
	xDelayActionBtPanelRight: BOOL;
	TimerPressBtPanelRight: TON;

(* Structure page *)
	T_ConfigPage:ST_CONFIGPAGE;
	wMaskBtPanelLeft: WORD;
	wMaskBtPanelRight: WORD;
	wMaskFunctionPanel: WORD;
	RisingEdgeProcessDone: R_TRIG;
	xStopImmediatly: BOOL;
	RisingEdgeProcessError: R_TRIG;
	RisingEdgeResetProcess: R_TRIG;
	RisingEdgeExecuteProcess: R_TRIG;
	RisingEdgeActionNotReady: R_TRIG;
	FallingEdgeActionNotReady: F_TRIG;
	RisingEdgeActionDone: R_TRIG;
	xBlockConfirmMessage: BOOL;
	RisingEdgeActionError: R_TRIG;
	RisingEdgeResetAction: R_TRIG;
	xSlowFast: BOOL;
	iSelectedAxis: INT;
	xSlowFastJogToolRotation: BOOL;
	xSlowFastJogToolFeeder: BOOL;
	xSlowFastJogGrindFeeder: BOOL;
	xToggleAxisPower: BOOL;
	xResetAxis: BOOL;
	xUpdateProfileList: BOOL;
	jj: INT;
	RisingEdgePtrProfileListUpDown: R_TRIG;
	iPointerListProfile: INT;
	iActualActiveProfile: INT;
	xAction_CopyProfileToProcess: BOOL;
	xProfileFileNotFound: BOOL;
	iToLoadProfileNr: INT;
	sToLoadProfileName: STRING;
	sTmpDynamicText: STRING;
	xAction_LoadProfileToProcessImage: BOOL;
	xAction_SaveNovRAM: BOOL;
	xActionDeleteProfile: BOOL;
	TimerONTmp: TON;
	iStepActionNovRam: INT;
	xAction_SaveProfileToFile: BOOL;
	iTmp: INT;
	sTmp: STRING;
	sTmp_2: STRING;
	RisingEdgeTimeOut: R_TRIG;
	fbCompareProfileProcessValue:FB_COMPAREPROFILEPROCESSVALUE;
	FailingEdgeGeometryManagement: F_TRIG;
	FailingEdgePrisma: F_TRIG;
	rCalcMinMaxToolDia: REAL;
	xResetParaListValue: BOOL;
	xActivateStationFunction: BOOL;
	iTmpStationFunctionNr: INT;
	xFirstReadInit: BOOL;
	xFirstReadReset: BOOL;
	xMicroRodActive: BOOL;
	FBCalcTorqueToolLeft: FB_CALC_TORQUE;
	FBCalcTorqueToolCenter: FB_CALC_TORQUE;
	FBCalcTorqueToolRight: FB_CALC_TORQUE;
	xTmpStopAxis: BOOL;
	RisingEdgeStartButton: R_TRIG;
	dwPageNrProcessStart: DWORD;
	FallingEdgeStartButton: F_TRIG;
	RisingEdgeStopButton: R_TRIG;
	FallingEdgeStopButton: F_TRIG;
	xToggleCylinderState: BOOL;
	dwTmpActualPage: DWORD;
	xUpdateErrorList: BOOL;
	RisingEdgeErrorList: R_TRIG;
	xParameterSavedErrorList: BOOL;
	xDeleteErrorList: BOOL;
	FBQVisErrorList: FBQVIS_ERROR_LIST;
	FBSetErrorList:FB_SETERRORLIST;
	xProcessMachine: BOOL;
	xProcessStation: BOOL;
	iStepProcess: INT;
	xStepProcessDone: BOOL;
	xStopProcess: BOOL;
	xAction_StopCycle: BOOL;
	xWaitStopEnd: BOOL;
	xWaitStopCycleEnd: BOOL;
	iStepWaitStopEnd: INT;
	xActionProcStation: BOOL;
	xActionProcMachine: BOOL;
	RisingEdgeKeySwitch1: R_TRIG;
	FailingEdgeKeySwitch1: F_TRIG;
	TimerDisplayMessage: TON;
	RisingEdgeReleaseWarning: R_TRIG;
	rCalcPrismaFactor: REAL;
	xFirstReadParaList: BOOL;
	iTmpSelectParaList: INT;
	xAction_SaveNovRAMWithoutConfirm: BOOL;
	diErrorNr: DINT;
	FBErrorMessage : FB_ErrorMessage;
	fbQvisClearError:FBQVIS_CLEARERROR;
	xResetError: BOOL;
	TONTimeWaitMsg: TON;
	xCheckQuitError: BOOL;
	bStateMachine: BYTE;
	xSetStateMachine: BOOL;
	iSelectAxisToolRotation: INT;
	rAutoTimeTotal: REAL;
	rToolRotationSpeed: REAL;
	iAutoProcess: INT;
	xBlockGrindFeederActivation: BOOL;
	xToolFeederMoveStartPos: BOOL;
	xToggleAllAxisPower: BOOL;
	FBCalcProcessTime: FB_CALCPROCESSTIME;
	xReferenceAxis: BOOL;
	xTeachPosition: BOOL;
	xCalcAngleRefIndex: BOOL;
	uiToolLeftZeroTorque: UINT;
	uiToolCenterZeroTorque: UINT;
	uiToolRightZeroTorque: UINT;
	xSetCalculToolRotTorque: BOOL;
	rActualToolFeederPosition: REAL;
	xReadActualToolFeedPos: BOOL;
	xReadActualToolFeedPos1: BOOL;
	rActualToolFeederPosition1: REAL;
	rToolTotalLength: REAL;
	xCalcFirstTime: BOOL;
	xFirstReadParaList1: BOOL;
	iTmpSelectParaList1: INT;
	xTmpTeach: BOOL;
	wTmpActivBtRight: WORD;
	xOverlayGrindFeedSetPlung: BOOL;
	xOpenMessageBox: BOOL;
	lrActualGrindFeedPosition: LREAL;
	lrToWriteGrindFeedPosition: LREAL;
	xCalcAgainProcTime: BOOL;
	xToolFeederMoveLoadPos: BOOL;
	xWarmUp:BOOL;
	iSelectedCylinder: INT;
	xWarmUpMessage: BOOL;
	xWarmUpMessageActiv: BOOL;
	xWarmUpMessageDone: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(******    This Functionblock manage the hole visualisation, it is the interface from the QVis and the control application          *******)
(****************************************************************************************************************************************************)
	IF NOT(xFirstRead) THEN
		xFirstRead:=TRUE;
		T_Visu.ptrT_ExchgParam:=ADR(T_ExchgParam);
	END_IF;
	RisingEdgeActiv(CLK:=T_Visu.T_CtrleVisu.xActive);
	IF RisingEdgeActiv.Q THEN
		(* call functionblock init. *)
		fbQvisInitPage(T_Visu:=T_Visu);
		(* Init. variable for visualisation action *)
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		T_Visu.T_CtrleVisu.xDone:=FALSE;
		T_Visu.ptrT_ExchgParam:=ADR(T_ExchgParam);
		wNormalLayerActivTask:=1;
		wSpecialLayerGeneralActivTask:=1;
		wSpecialLayerToolRotActivTask:=1;
		wSpecialLayerWireFeedActivTask:=1;
		wSpecialLayerGrindAxisActivTask:=1;
		wNormalLayerActivPage:=10;
		wSpecialLayerGeneralActivPage:=110;
		wSpecialLayerToolRotActivPage:=210;
		wSpecialLayerWireFeedActivPage:=310;
		wSpecialLayerGrindAxisActivPage:=410;
		T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=1;
		wStandardPageNr:=10;
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
		wTmpNormalLayerActivTask:=1;
		wTmpSpecialLayerGeneralActivTask:=1;
		wTmpSpecialLayerToolRotActivTask:=1;
		wTmpSpecialLayerWireFeedActivTask:=1;
		wTmpSpecialLayerGrindAxisActivTask:=1;
		FOR ii:=1 TO 6 DO
			awNormalLayerActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=110;
		FOR ii:=1 TO 6 DO
			awSpecialLayerGeneralActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=210;
		FOR ii:=1 TO 6 DO
			awSpecialLayerToolRotActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=310;
		FOR ii:=1 TO 6 DO
			awSpecialLayerWireFeedActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=410;
		FOR ii:=1 TO 6 DO
			awSpecialLayerGrindAxisActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		IF NOT(xFirstReadInit) THEN
			xFirstReadInit:=TRUE;
			T_Visu.T_PlcParam.dwSetNewPage:=1001;
		ELSE
			T_Visu.T_PlcParam.dwSetNewPage:=0;
		END_IF;
		T_Visu.T_PlcParam.dwActualPage:=0;
		T_Visu.T_PlcParam.dwPreviousPage:=0;
		iPointerListProfile:=1;
		iActualActiveProfile:=-1;
		TimerAction(IN:=FALSE);
		(* Init FB *)
		fbQvisClearError(	xExecute:=FALSE,
						iError:=0,
						T_Message:=T_ExchgParam.T_Visu.T_Message,
						T_Station:=T_Station,
						T_Process:=T_Process,
						T_NovRAM:=T_NovRAM,
						T_Profile:=T_Profile,
						T_HDD:=T_HDD,
						xDone=>T_Visu.T_CtrleAction.xDone,
						xNotReady=>T_Visu.T_CtrleAction.xNotReady,
						xErr=>T_Visu.T_CtrleAction.xErr,
						udiErrorID=>T_Visu.T_CtrleAction.udiErrorID);
		T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectToolTensionForce:=1;	(* For starting the machine set always the process force for the ToolTension *)
		ptrTeachINAxis:=ADR(T_Station.THardware.TAxisToolLeft);
	END_IF;

	IF NOT(T_Visu.T_CtrleVisu.xActive) THEN
		RETURN;
	END_IF;

(* waiting for reset *)
	RisingEdgeReset(CLK:=T_Visu.T_CtrleVisu.xReset);
	IF RisingEdgeReset.Q THEN
		(* Init. structure *)
		T_Visu.T_CtrleVisu.xDone:=FALSE;
		T_Visu.T_CtrleVisu.iFunction:=0;
		T_Visu.T_CtrleVisu.xErr:=FALSE;
		T_Visu.T_CtrleVisu.udiErrorID:=0;
		IF NOT(xFirstReadReset) THEN
			xFirstReadReset:=TRUE;
			T_Visu.T_PlcParam.dwSetNewPage:=1001;
		ELSE
			T_Visu.T_PlcParam.dwSetNewPage:=0;
		END_IF;
		T_Visu.T_PlcParam.dwActualPage:=0;
		T_Visu.T_PlcParam.dwPreviousPage:=0;
		T_Visu.ptrT_ExchgParam^.T_Visu.iQVisActivNewPage:=0;
		wNormalLayerActivTask:=1;
		wSpecialLayerGeneralActivTask:=1;
		wSpecialLayerToolRotActivTask:=1;
		wSpecialLayerWireFeedActivTask:=1;
		wSpecialLayerGrindAxisActivTask:=1;
		wNormalLayerActivPage:=10;
		wSpecialLayerGeneralActivPage:=110;
		wSpecialLayerToolRotActivPage:=210;
		wSpecialLayerWireFeedActivPage:=310;
		wSpecialLayerGrindAxisActivPage:=410;
		wTmpNormalLayerActivTask:=1;
		wTmpSpecialLayerGeneralActivTask:=1;
		wTmpSpecialLayerToolRotActivTask:=1;
		wTmpSpecialLayerWireFeedActivTask:=1;
		wTmpSpecialLayerGrindAxisActivTask:=1;
		T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=1;
		T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=0;
		T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
		wStandardPageNr:=10;
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
		FOR ii:=1 TO 6 DO
			awNormalLayerActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=110;
		FOR ii:=1 TO 6 DO
			awSpecialLayerGeneralActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=210;
		FOR ii:=1 TO 6 DO
			awSpecialLayerToolRotActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=310;
		FOR ii:=1 TO 6 DO
			awSpecialLayerWireFeedActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		wStandardPageNr:=410;
		FOR ii:=1 TO 6 DO
			awSpecialLayerGrindAxisActivPage[ii]:=wStandardPageNr;
			wStandardPageNr:=wStandardPageNr + 10;
		END_FOR;
		(* Activ reset structure control action *)
		T_Visu.T_CtrleAction.xReset:=TRUE;
		(* Activ reset structure control process *)
		T_Visu.T_CtrleProcess.xReset:=TRUE;
		(* Init. pw value *)
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
		(* Init. Error *)
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:='';
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:='';
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:='';
		T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
		T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1:=1;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.iWireFeederAngleRefIndex:=0;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisGrind:=1;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation:=1;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisWireFeeder:=1;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolRotation:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolFeed:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastGrindFeeder:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce:=T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
		(* active confirmation *)
		xConfirmResetFB:=TRUE;
		(* exit function bloc *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
			(* confirm reset FB *)
			T_Visu.T_CtrleVisu.xDone:=TRUE;
			T_Visu.T_CtrleVisu.xErr:=FALSE;
			T_Visu.T_CtrleVisu.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
			(* activ research if Qvis is activ *)
			xQvisActiv:=TRUE;
			T_Visu.T_CtrleVisu.xQvis:=FALSE;
			dwInCount_QVisCmd:=T_CtrleQVis.dwInCount;
		END_IF
	END_IF

(* determin if qvis activ *)
	IF xQvisActiv THEN
		(* timer time off  *)
		TimerQVis(IN:=TRUE,PT:=T#2s);
		IF dwInCount_QVisCmd = T_CtrleQVis.dwInCount THEN
			(* Init. command *)
			T_CtrleQVis.dwInCommand:=1;
			T_CtrleQVis.dwInQVisCtrlAddress:=ADR(T_CtrleQVis);
			T_CtrleQVis.dwInParameterAddress:=ADR(T_Visu.T_PlcParam.dwSetNewPage);
			(* start command *)
			T_CtrleQVis.dwInCount:=T_CtrleQVis.dwInCount+1;
			(* Activ Timer *)
			TimerQVis(IN:=FALSE);
		ELSE
			IF T_CtrleQVis.dwInCount = T_CtrleQVis.dwOutCount THEN
			(* command done *)
				IF T_CtrleQVis.diOutStatus = 0 THEN
				(* command done without error *)
					xQvisActiv:=FALSE;
					T_Visu.T_CtrleVisu.xQvis:=TRUE;
					T_Visu.T_PlcParam.dwActualPage:=T_Visu.T_PlcParam.dwSetNewPage;
				END_IF
			ELSE
			(* test time off, restart command *)
				IF TimerQVis.Q THEN
					dwInCount_QVisCmd:=T_CtrleQVis.dwInCount;
				END_IF
			END_IF
		END_IF
	END_IF

(* exit FB if Qvis inactiv *)
	IF NOT(T_Visu.T_CtrleVisu.xQvis) THEN RETURN; END_IF

	IF (T_Visu.T_PlcParam.dwActualPage > 0) AND (T_Visu.T_PlcParam.dwActualPage <= 999) THEN
		(* copy config page structure *)
		T_ConfigPage:=T_Visu.T_ConfigPage[T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage].iIndexConfigPage];
		T_Visu.ptrT_ExchgParam^. T_TouchScreenNavPanel.wNotMasktext:=T_ConfigPage.wMaskTouchScreenNavPanel;
		T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt:=16#0;
		T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt:=WORD_TO_INT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt) OR T_ConfigPage.wMaskBtPanelRight);
		T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt:=WORD_TO_INT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt) OR T_ConfigPage.wMaskBtPanelLeft);
		T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt:=WORD_TO_INT(NOT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt)));
	END_IF;

(* monitor page Errorlist for Machine *)
	xTmp:=	(T_Visu.T_PlcParam.dwActualPage = 60) OR
			(T_Visu.T_PlcParam.dwActualPage = 160) OR
			(T_Visu.T_PlcParam.dwActualPage = 260) OR
			(T_Visu.T_PlcParam.dwActualPage = 360) OR
			(T_Visu.T_PlcParam.dwActualPage = 460);
	IF xTmp THEN
		(* Check if Station will be changed without change the Error Page *)
		IF (dwTmpActualPage <> T_Visu.T_PlcParam.dwActualPage) THEN
			xUpdateErrorList:=TRUE;
			dwTmpActualPage:=T_Visu.T_PlcParam.dwActualPage;
		END_IF;
	END_IF;
	IF xTmp OR xUpdateErrorList THEN
		IF NOT(xTmp) AND xUpdateErrorList THEN
			RisingEdgeErrorList(CLK:=xUpdateErrorList);
		ELSE
			RisingEdgeErrorList(CLK:=xTmp AND NOT(xUpdateErrorList));
		END_IF;
		xUpdateErrorList:=FALSE;
		IF RisingEdgeErrorList.Q THEN
			FBQVisErrorList(	T_ErrorList:= T_ErrorList,
							T_ErrorNrList:= T_NovRAM.T_Data.T_ErrorNrList,
							T_MsgErrorEnglish:= T_Visu.ptrT_ExchgParam^.T_Visu.T_MsgErrorEnglish,
							T_MsgErrorDeutsch:= T_Visu.ptrT_ExchgParam^.T_Visu.T_MsgErrorDeutsch,
							T_MsgErrorFrancais:= T_Visu.ptrT_ExchgParam^.T_Visu.T_MsgErrorFrancais);
		END_IF;
	ELSE
		RisingEdgeErrorList(CLK:=FALSE);
	END_IF;

(* Refresh Errorlist for Machine and Station *)
	FBSetErrorList(	TControlStation:= T_Station.TControl,
					TProcess:= T_Process,
					xParameterSaved:= xParameterSavedErrorList,
					T_ErrorNrList:= T_NovRAM.T_Data.T_ErrorNrList,
					xSetForceError:= T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError,
					diSetForceErrorNr:= T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr);
	IF FBSetErrorList.xSaveParameter THEN
		IF T_Visu.T_CtrleAction.xDone AND NOT(T_Visu.T_CtrleAction.xExecute) AND T_NovRAM.T_Ctrle.xDone AND NOT(T_NovRAM.T_Ctrle.xExecute) THEN
			xParameterSavedErrorList:=TRUE;
			xUpdateErrorList:=TRUE;
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			T_NovRAM.T_Data.T_ErrorNrList;
		END_IF;
	END_IF;

(* Monitoring Visu Parameter *)
	T_Visu.ptrT_ExchgParam^.T_StationCommon.rConvertMaxToolLength:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength * 10.0;	(* convert from cm to mm *)
	T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ParamToolTensionSystem.rMaxForceTT:=T_NovRAM.T_Data.T_Standard.T_ToolTensionSystem.rMaxForceTT;
	IF (T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType = 2) THEN
		xMicroRodActive:=TRUE;
	ELSE
		xMicroRodActive:=FALSE;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = 170) AND ((T_Visu.ptrT_ExchgParam^.T_Config.iEditParam >= 120) AND (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam <= 129)) THEN
		IF NOT(xFirstReadParaList) THEN
			iTmpSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList;
		END_IF;
		xFirstReadParaList:=TRUE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi1:=TRUE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockNavParaList:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=iFctGetEditParaList(	dwActualPage:=120,
																	xMicroRodActive:=xMicroRodActive,
																	iSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList,
																	iSelectParaListTeachRot:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot);
		(* 09.12.2010 KFS:	{	*)
		IF (T_ExchgParam.T_Visu.T_Level.iActLevel <>2) THEN
			IF  (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 121) THEN
				 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 126;
			ELSIF ( T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 123) THEN
				 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 127;
			ELSIF ( T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 125) THEN
				 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 128;
			END_IF;
		END_IF;
		(* 09.12.2010 KFS:	}	*)
		IF (iTmpSelectParaList <> T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList) THEN
			iTmpSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList;
			xResetParaListValue:=TRUE;
		END_IF;
	ELSE
		xFirstReadParaList:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockNavParaList:=TRUE;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = 270) AND ((T_Visu.ptrT_ExchgParam^.T_Config.iEditParam >= 210) AND (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam <= 219)) THEN
		IF NOT(xFirstReadParaList1) THEN
			iTmpSelectParaList1:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot;
		END_IF;
		xFirstReadParaList1:=TRUE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockNavParaListTeachRot:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=iFctGetEditParaList(	dwActualPage:=210,
																	xMicroRodActive:=xMicroRodActive,
																	iSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot,
																	iSelectParaListTeachRot:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot);
		IF (iTmpSelectParaList1 <> T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot) THEN
			iTmpSelectParaList1:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot;
			xResetParaListValue:=TRUE;
		END_IF;
	ELSE
		xFirstReadParaList1:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockNavParaListTeachRot:=TRUE;
	END_IF;
	xTmp:=	(T_Visu.T_PlcParam.dwActualPage = 170) OR
			(T_Visu.T_PlcParam.dwActualPage = 270) OR
			(T_Visu.T_PlcParam.dwActualPage = 370) OR
			(T_Visu.T_PlcParam.dwActualPage = 470);
	IF xTmp AND (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 0) THEN
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=TRUE;
		T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi1:=TRUE;
	END_IF;

(* Monitor dynamic mask for button panel left and right and function panel *)
	IF T_Visu.T_CtrleProcess.xDone OR T_Visu.T_CtrleProcess.xErr THEN
	(* Set the standard mask *)
		wMaskBtPanelLeft:=T_ConfigPage.wMaskBtPanelLeft;
		wMaskBtPanelRight:=T_ConfigPage.wMaskBtPanelRight;
		wMaskFunctionPanel:=T_ConfigPage.wMaskFunctionPanel;
	(* Set the dynamic mask *)
	ELSE	wMaskBtPanelLeft:=T_ConfigPage.wMaskBtPanelLeft AND T_ConfigPage.wMaskActiveMachineBtPanelLeft;
			wMaskBtPanelRight:=T_ConfigPage.wMaskActiveMachineBtPanelRight;
			wMaskFunctionPanel:=T_ConfigPage.wMaskActiveMachineFunctionPanel;
	END_IF
	(* Check activ Page *)
	IF (T_Visu.T_PlcParam.dwActualPage = 170) OR (T_Visu.T_PlcParam.dwActualPage = 270) OR (T_Visu.T_PlcParam.dwActualPage = 370) OR (T_Visu.T_PlcParam.dwActualPage = 470) THEN
		IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 0) THEN
			wMaskBtPanelRight:=16#0;
		END_IF;
		IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 130) OR (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 131) THEN
			wMaskBtPanelRight:=16#0;
		END_IF;
	END_IF;
	(* Config. divers mask *)
	T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt
		:=(16#1F XOR wMaskBtPanelLeft) OR (16#3E0 XOR wMaskBtPanelRight);
	(* management Fn button panel availability *)
	T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext:=16#FFF XOR wMaskFunctionPanel;
	(* management navigation panel mask *)
	T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wNotMasktext:=T_ConfigPage.wMaskTouchScreenNavPanel;

(************************************************************************************************************************************************************************)
(********start of the managment of the external start-stop button, special button and function button and task button and external tool buttons********)
(************************************************************************************************************************************************************************)
(* Start button *)
	(* ...manage action button *)
	xTmp:=	NOT(xChangePage)
			AND (T_Visu.T_CtrleAction.xDone)
			AND NOT(T_Visu.T_CtrleAction.xExecute);
	IF xTmp THEN
		(* manage rising edge start button *)
		RisingEdgeStartButton(CLK:=xStartButton AND T_ConfigPage.xMaskBtStart);
		IF RisingEdgeStartButton.Q AND bButtonPanelLocked = 16#0 AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu) THEN
		(* panel locked *)
			bButtonPanelLocked:=16#10;
			(* Start process at the begin *)
			T_Visu.T_CtrleAction.xExecute:=TRUE;
			CASE T_Visu.T_PlcParam.dwActualPage OF
			(* Data machine *)
			10:	T_Visu.T_CtrleAction.iFunction:=710;
			20:	T_Visu.T_CtrleAction.iFunction:=720;
			30:	T_Visu.T_CtrleAction.iFunction:=730;
			110:	T_Visu.T_CtrleAction.iFunction:=640;
			210:	T_Visu.T_CtrleAction.iFunction:=318;
			220:	T_Visu.T_CtrleAction.iFunction:=402;
			310:	T_Visu.T_CtrleAction.iFunction:=305;
			330:	T_Visu.T_CtrleAction.iFunction:=420;
			410:	T_Visu.T_CtrleAction.iFunction:=305;
			ELSE
				T_Visu.T_CtrleAction.xExecute:=FALSE;
			END_CASE
			(* save page number for stop procedure *)
			IF T_Visu.T_CtrleAction.xExecute THEN
				dwPageNrProcessStart:=T_Visu.T_PlcParam.dwActualPage;
				xStopImmediatly:=FALSE;
			END_IF
		END_IF
		(* manage falling edge start button *)
		FallingEdgeStartButton(CLK:=xStartButton AND T_ConfigPage.xMaskBtStart);
		IF FallingEdgeStartButton.Q AND (bButtonPanelLocked AND 16#10) = 16#10 THEN bButtonPanelLocked:=bButtonPanelLocked XOR 16#10; END_IF
	ELSE
		RisingEdgeStartButton(CLK:=FALSE);
		FallingEdgeStartButton(CLK:=TRUE);
	END_IF

(* Stop button *)
	xTmp:=	NOT(T_Visu.T_CtrleAction.xExecute);
	xTmpTeach:=((T_Visu.T_PlcParam.dwActualPage = 310) OR (T_Visu.T_PlcParam.dwActualPage = 410)) AND (bButtonPanelLocked = 16#10);
	IF xTmp THEN
		RisingEdgeStopButton(CLK:=xStopButton);
		IF RisingEdgeStopButton.Q AND ((bButtonPanelLocked = 16#0) OR xTmpTeach) THEN
		(* pane locked *)
			bButtonPanelLocked:=16#20;
			(* activ stop process *)
			T_Visu.T_CtrleAction.xExecute:=TRUE;
			CASE T_Visu.T_PlcParam.dwActualPage OF
			10:	T_Visu.T_CtrleAction.iFunction:=800;
			20:	T_Visu.T_CtrleAction.iFunction:=800;
			30:	T_Visu.T_CtrleAction.iFunction:=800;
			110:	T_Visu.T_CtrleAction.iFunction:=800;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;
			210:	T_Visu.T_CtrleAction.iFunction:=301;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;
			220:	T_Visu.T_CtrleAction.iFunction:=403;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;
			310:	T_Visu.T_CtrleAction.iFunction:=301;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;
			330:	T_Visu.T_CtrleAction.iFunction:=800;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;
			410:	T_Visu.T_CtrleAction.iFunction:=301;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=121;
			ELSE
				T_Visu.T_CtrleAction.xExecute:=FALSE;
			END_CASE
		END_IF
		(* manage falling edge stop button *)
		FallingEdgeStopButton(CLK:=xStopButton AND T_ConfigPage.xMaskBtStop);
		IF FallingEdgeStopButton.Q AND (bButtonPanelLocked AND 16#20) = 16#20 THEN
			bButtonPanelLocked:=bButtonPanelLocked XOR 16#20; END_IF
	ELSE
		RisingEdgeStopButton(CLK:=FALSE);
		FallingEdgeStopButton(CLK:=TRUE);
	END_IF

(* Management Bt Panel left *)
	IF T_Visu.ptrT_ExchgParam^.T_Config.xNoTouchScreenBtPanel THEN
		wActivBtLeft:=wSPSSpecialButton;
	ELSE
		wActivBtLeft:=INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iActivBtLeft);
	END_IF;
	RisingEdgeSpecialLayer(CLK:=xSecurityKey);
	FallingEdgeSpecialLayer(CLK:=xSecurityKey);
	RisingEdgeBtPanelLeft(CLK:=((wActivBtLeft AND wMaskBtPanelLeft) <> 16#0) AND T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer <> 0);
	FallingEdgeBtPanelLeft(CLK:=((wActivBtLeft AND wMaskBtPanelLeft) <> 16#0) AND T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer <> 0);
	xTmp:=	NOT(xChangePage)
			AND (T_Visu.T_CtrleAction.xDone OR ((xOverlayMeasureToolDia OR xOverlayGrindFeedSetPlung OR T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox) AND FallingEdgeSpecialLayer.Q))
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu)
			AND NOT(T_StartUp.T_State.xBlockVisuNavigation)
			AND T_StartUp.T_State.xCompleted;
	IF xTmp THEN
		IF RisingEdgeSpecialLayer.Q THEN
			CASE bOldActivSpecialLayer OF
				1:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=1;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=1;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGeneralActivTask;
					ii:=1;
					wTmp:=wSpecialLayerGeneralActivTask;
					WHILE wTmp <> 16#0 DO
						IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
						wTmp:=ROR(wTmp,1);
						ii:=ii+1;
					END_WHILE
					dwSetNewPage:=awSpecialLayerGeneralActivPage[ii];
				2:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=2;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=2;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerToolRotActivTask;
					ii:=1;
					wTmp:=wSpecialLayerToolRotActivTask;
					WHILE wTmp <> 16#0 DO
						IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
						wTmp:=ROR(wTmp,1);
						ii:=ii+1;
					END_WHILE
					dwSetNewPage:=awSpecialLayerToolRotActivPage[ii];
				3:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=3;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=4;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerWireFeedActivTask;
					ii:=1;
					wTmp:=wSpecialLayerWireFeedActivTask;
					WHILE wTmp <> 16#0 DO
						IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
						wTmp:=ROR(wTmp,1);
						ii:=ii+1;
					END_WHILE
					dwSetNewPage:=awSpecialLayerWireFeedActivPage[ii];
				4:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=4;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=8;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGrindAxisActivTask;
					ii:=1;
					wTmp:=wSpecialLayerGrindAxisActivTask;
					WHILE wTmp <> 16#0 DO
						IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
						wTmp:=ROR(wTmp,1);
						ii:=ii+1;
					END_WHILE
					dwSetNewPage:=awSpecialLayerGrindAxisActivPage[ii];
			ELSE
				T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=1;
				T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=1;
				T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGeneralActivTask;
				dwSetNewPage:=wSpecialLayerGeneralActivPage;
			END_CASE;
			T_Visu.T_CtrleAction.iFunction:=6;
			T_Visu.T_CtrleAction.xExecute:=TRUE;
		END_IF;

		IF FallingEdgeSpecialLayer.Q THEN
			IF xOverlayMeasureToolDia THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
				xOverlayMeasureToolDia:=FALSE;
				T_Visu.T_CtrleAction.xDone:=TRUE;
			END_IF;
			IF xOverlayGrindFeedSetPlung THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
				xOverlayGrindFeedSetPlung:=FALSE;
				T_Visu.T_CtrleAction.xDone:=TRUE;
			END_IF;
			IF T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
				xAction_SaveNovRAM:=FALSE;
				xAction_SaveNovRAMWithoutConfirm:=FALSE;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=0;
			T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
			T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wNormalLayerActivTask;
			ii:=1;
			wTmp:=wNormalLayerActivTask;
			WHILE wTmp <> 16#0 DO
				IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
				wTmp:=ROR(wTmp,1);
				ii:=ii+1;
			END_WHILE
			dwSetNewPage:=awNormalLayerActivPage[ii];
			T_Visu.T_CtrleAction.iFunction:=6;
			T_Visu.T_CtrleAction.xExecute:=TRUE;
		END_IF;
		IF wActivBtLeft = 16#10 THEN
			CASE T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer OF
				1:	iTmpActivBtLeft:=1;
				2:	iTmpActivBtLeft:=2;
				3:	iTmpActivBtLeft:=4;
				4:	iTmpActivBtLeft:=8;
			END_CASE;
		ELSE
			iTmpActivBtLeft:=WORD_TO_INT(wActivBtLeft);
		END_IF;
		IF RisingEdgeBtPanelLeft.Q THEN
			iStepCounter:=iStepCounter + 1;
			CASE iTmpActivBtLeft OF
				16#1:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=1;
						T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGeneralActivTask;
						dwSetNewPage:=wSpecialLayerGeneralActivPage;
				16#2:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=2;
						T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerToolRotActivTask;
						dwSetNewPage:=wSpecialLayerToolRotActivPage;
				16#4:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=3;
						T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerWireFeedActivTask;
						dwSetNewPage:=wSpecialLayerWireFeedActivPage;
				16#8:	T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer:=4;
						T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGrindAxisActivTask;
						dwSetNewPage:=wSpecialLayerGrindAxisActivPage;
			END_CASE;
			bOldActivSpecialLayer:=T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer;
			IF ((wActivBtLeft AND 16#10) <> 16#10) THEN
				IF ((INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft) AND 16#10) = 16#10) THEN
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=WORD_TO_INT(wActivBtLeft OR 16#10);
					T_Visu.T_CtrleAction.iFunction:=3;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
					xResetParaListValue:=TRUE;
				ELSE
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=WORD_TO_INT(wActivBtLeft);
					T_Visu.T_CtrleAction.iFunction:=6;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
			ELSE
				IF ((INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft) AND 16#10) = 16#10) THEN
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft - 16#10;
					T_Visu.T_CtrleAction.iFunction:=6;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
					xResetParaListValue:=TRUE;
				ELSE
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=WORD_TO_INT(wActivBtLeft OR INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft));
					T_Visu.T_CtrleAction.iFunction:=3;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
					xResetParaListValue:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	END_IF;

(* Management Bt Panel Right *)
	IF (T_Visu.T_PlcParam.dwActualPage = 320) THEN
		IF NOT(xMicroRodActive) THEN
		(* For MicroWire no Function for ToolFeeder-->Cancel Function F1, F2, F3 and F4 *)
			wMaskBtPanelRight:=wMaskBtPanelRight AND 16#0;
			T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt:=WORD_TO_INT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt) OR 16#3E0);
		END_IF;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
		IF (T_NovRam.T_Data.T_ProcessImageData.T_AutoGeometryPara.iCycleGeometry <= 1) THEN
			T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt:=WORD_TO_INT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iNotMaskTextBt) OR 16#1E0);
		END_IF;
	END_IF;
	TimerPressBtPanelRight(IN:=TRUE, PT:=T#3600s);
	IF T_Visu.ptrT_ExchgParam^.T_Config.xNoTouchScreenBtPanel THEN
		wActivBtRight:=wSPSSpecialButton;
	ELSE
		wActivBtRight:=INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iActivBtRight);
	END_IF;
	RisingEdgeBtPanelRight(CLK:=(wActivBtRight AND wMaskBtPanelRight) <> 16#0);
	FallingEdgeBtPanelRight(CLK:=(wActivBtRight AND wMaskBtPanelRight) <> 16#0);
	xTmp:=	(NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu)
			(*AND NOT(T_StartUp.T_State.xBlockVisuNavigation)*))
			OR xDelayActionBtPanelRight;
	IF (wActivBtRight = 0) AND NOT(xDelayActionBtPanelRight) THEN
		TimerPressBtPanelRight(IN:=FALSE);
	END_IF;
	IF xTmp THEN
		(* Rising edge action *)
		IF RisingEdgeBtPanelRight.Q AND (bButtonPanelLocked = 16#0) AND (NOT(T_StartUp.T_State.xBlockVisuNavigation) OR ((T_NovRam.T_Data.T_ProcessImageData.T_AutoGeometryPara.iCycleGeometry > 1)) AND (T_Visu.T_PlcParam.dwActualPage = 10)) THEN
		(* init. variable *)
			ii:=1;
			wTmp:=wActivBtRight;
			wTmpActivBtRight:=wActivBtRight;
			wTmp:=ROR(wTmp,5);
			(* only one button is used *)
			WHILE wTmp <> 16#0 DO
				IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
				wTmp:=ROR(wTmp,1);
				ii:=ii+1;
			END_WHILE
			(* set the new action if present *)
			IF T_ConfigPage.aiRTrigActionPanelRight[ii] <> 0 THEN
				T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiRTrigActionPanelRight[ii];
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF
			IF (T_ConfigPage.aiFTrigActionPanelRight[ii] = 301) THEN
				xTmpStopAxis:=TRUE;
			END_IF
			(* init. timer press button *)
			TimerPressBtPanelRight(IN:=FALSE);
			(* Lock button panel *)
			bButtonPanelLocked:=16#2;
			(* init. variable *)
			xDelayActionBtPanelRight:=FALSE;
		END_IF
		(* Falling Edge action activ only if the delay action has been started *)
		IF FallingEdgeBtPanelRight.Q AND ((bButtonPanelLocked AND 16#2) = 16#2) THEN
			ii:=1;
			wTmp:=wTmpActivBtRight;
			wTmp:=ROR(wTmp,5);
			(* only one button is used *)
			WHILE wTmp <> 16#0 DO
				IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
				wTmp:=ROR(wTmp,1);
				ii:=ii+1;
			END_WHILE
			(* set the new action if present *)
			IF T_ConfigPage.aiFTrigActionPanelRight[ii] <> 0 (*AND xDelayActionBtPanelRight*) THEN
				T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiFTrigActionPanelRight[ii];
				T_Visu.T_CtrleAction.xExecute:=TRUE;
				IF (T_Visu.T_CtrleAction.iFunction = 301) THEN
					xTmpStopAxis:=TRUE;
				END_IF;
			END_IF
			(* release lock panel *)
			bButtonPanelLocked:=bButtonPanelLocked XOR 16#2;
			(* init. variable *)
			xDelayActionBtPanelRight:=FALSE;
		END_IF;

		(* monitor delay *)
		xTmp:=	NOT(xDelayActionBtPanelRight)
				AND NOT(FallingEdgeBtPanelRight.Q)
				AND (bButtonPanelLocked AND 16#2) =16#2;
		IF xTmp AND (TimerPressBtPanelRight.ET > T#500ms) THEN
		(* activ delay action *)
			ii:=1;
			wTmp:=wActivBtRight;
			wTmp:=ROR(wTmp,5);
			(* only one button is used *)
			WHILE wTmp <> 16#0 DO
				IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
				wTmp:=ROR(wTmp,1);
				ii:=ii+1;
			END_WHILE
			(* set the new action if present *)
			IF T_ConfigPage.aiDelayActionPanelRight[ii] <> 0 THEN
				T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiDelayActionPanelRight[ii];
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF
			(* confirm execution delay action *)
			xDelayActionBtPanelRight:=TRUE;
		END_IF;
		IF T_Visu.T_CtrleAction.xDone AND (wActivBtRight = 16#0) AND (bButtonPanelLocked = 16#2) THEN
			bButtonPanelLocked:=0;
		END_IF;
	END_IF
	IF xTmpStopAxis THEN
		IF ptrTeachINAxis^.T_CtrleSingle.xErr THEN
			IF (ptrTeachINAxis^.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(ptrTeachINAxis^.T_Config_Gen.iTyp * 1000000) + ptrTeachINAxis^.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			ptrTeachINAxis^.T_CtrleSingle.iFunction:=1;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.xSetSecurityStateON:=TRUE;
		END_IF;
	END_IF;
	IF xTmpStopAxis AND T_Visu.T_CtrleAction.xDone AND (bButtonPanelLocked = 0) AND NOT(T_Visu.T_CtrleAction.xExecute) AND (NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xNotMoving) OR
	    (NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xNotMoving) AND xMicroRodActive) OR NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xNotMoving) OR
	     NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving) OR NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving)) THEN
		T_Visu.T_CtrleAction.iFunction:=301;
		T_Visu.T_CtrleAction.xExecute:=TRUE;
	END_IF;
	IF xTmpStopAxis AND T_Visu.T_CtrleAction.xDone AND NOT(T_Visu.T_CtrleAction.xExecute) AND T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xNotMoving AND
	    ((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xNotMoving AND xMicroRodActive) OR NOT(xMicroRodActive)) AND T_Station.THardware.TAxisToolRight.T_CtrleSingle.xNotMoving AND
	    T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving THEN
		xTmpStopAxis:=FALSE;
	END_IF;

(* Managment Bt Function panel *)
	IF (T_Visu.T_PlcParam.dwActualPage = 10) OR (T_Visu.T_PlcParam.dwActualPage = 110) THEN
		IF NOT(xMicroRodActive) THEN
		(* For MicroWire no Function for move the ToolFeeder to the StartPos-->Cancel Function F5 *)
			wMaskFunctionPanel:=wMaskFunctionPanel AND 16#FFEF;
			T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext:=T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext OR 16#10;
		END_IF;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
		IF NOT(xMicroRodActive) THEN
		(* For MicroWire no Function for move the ToolFeeder to the StartPos-->Cancel Function F5 *)
			wMaskFunctionPanel:=wMaskFunctionPanel AND 16#FFEF;
			T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext:=T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext OR 16#10;
		END_IF;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = 310) THEN
		IF NOT(xMicroRodActive) THEN
		(* For MicroWire no Function for no Position to save for ToolFeeder-->Cancel Function F3 and F6 *)
			wMaskFunctionPanel:=wMaskFunctionPanel AND 16#FFDB;
			T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext:=T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext OR 16#24;
		END_IF;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = 320) THEN
		IF NOT(xMicroRodActive) THEN
		(* For MicroWire no Function for ToolFeeder-->Cancel Function F1, F2, F3 and F4 *)
			wMaskFunctionPanel:=wMaskFunctionPanel AND 16#0;
			T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext:=T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wNotMasktext OR 16#FFFF;
		END_IF;
	END_IF;
	RisingEdgeBtFunctionPanel(CLK:=(T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wActivBt AND wMaskFunctionPanel) <> 16#0);
	FallingEdgeBtFunctionPanel(CLK:=(T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wActivBt AND wMaskFunctionPanel) <> 16#0);
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu);
	IF xTmp THEN
		(* Rising edge action *)
		IF RisingEdgeBtFunctionPanel.Q THEN
		(* Init. variable *)
			ii:=1;
			wTmp:=T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wActivBt;
			WHILE wTmp <> 16#0 DO
				IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
				wTmp:=ROR(wTmp,1);
				ii:=ii+1;
			END_WHILE
			(* set the new action if present *)
			IF  T_ConfigPage.aiRTrigActionFunctionPanel[ii] <> 0 THEN
				T_Visu.T_CtrleAction.iFunction:= T_ConfigPage.aiRTrigActionFunctionPanel[ii];
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF
		END_IF
	END_IF

(* Management Bt navigation panel *)
	RisingEdgeTouchScreenNavPanel(CLK:=	T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt <> 0);
	FallingEdgeTouchScreenNavPanel(CLK:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt <> 0);
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu)
			AND NOT(T_StartUp.T_State.xBlockVisuNavigation)
			AND ((T_Visu.ptrT_ExchgParam^. T_TouchScreenNavPanel.wNotMasktext AND T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt) <> 0);
	IF xTmp THEN
		(* activ action of rising edge *)
		IF RisingEdgeTouchScreenNavPanel.Q THEN
			ii:=1;
			wTmp:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt;
			WHILE wTmp <> 16#0 DO
				IF (wTmp AND 16#1) = 16#1 THEN EXIT; END_IF
				wTmp:=ROR(wTmp,1);
				ii:=ii+1;
			END_WHILE
			T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiFTrigActionTouchScreenNavPanel[ii];
			CASE T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer OF
				0: 	wNormalLayerActivTask:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt;
					wNormalLayerActivPage:=T_Visu.T_CtrleAction.iFunction - 10000;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wNormalLayerActivTask;
					wTmpNormalLayerActivTask:=ii;
				1:	wSpecialLayerGeneralActivTask:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt;
					wSpecialLayerGeneralActivPage:=T_Visu.T_CtrleAction.iFunction - 10000;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGeneralActivTask;
					wTmpSpecialLayerGeneralActivTask:=ii;
				2:	wSpecialLayerToolRotActivTask:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt;
					wSpecialLayerToolRotActivPage:=T_Visu.T_CtrleAction.iFunction - 10000;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerToolRotActivTask;
					wTmpSpecialLayerToolRotActivTask:=ii;
				3:	wSpecialLayerWireFeedActivTask:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt;
					wSpecialLayerWireFeedActivPage:=T_Visu.T_CtrleAction.iFunction - 10000;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerWireFeedActivTask;
					wTmpSpecialLayerWireFeedActivTask:=ii;
				4:	wSpecialLayerGrindAxisActivTask:=T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt;
					wSpecialLayerGrindAxisActivPage:=T_Visu.T_CtrleAction.iFunction - 10000;
					T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wState:=wSpecialLayerGrindAxisActivTask;
					wTmpSpecialLayerGrindAxisActivTask:=ii;
			END_CASE;
			IF ((INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft) AND 16#10) = 16#10) THEN
				T_Visu.T_CtrleAction.iFunction:=3;
				xResetParaListValue:=TRUE;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt:=0;
			T_Visu.T_CtrleAction.xExecute:=TRUE;
		END_IF;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_TouchScreenNavPanel.wActivBt:=0;
	END_IF;
(*22.12.2009: KFS 	{	*)
(* Management BT Tool  (additionel external buttons) only for MicroRod *)
	IF xMicroRodActive THEN
		(* ToolTension button *)
		xTmp:=	NOT(xChangePage) AND T_Visu.T_CtrleAction.xDone AND
				NOT(T_Visu.T_CtrleAction.xExecute) 	AND T_Visu.T_CtrleProcess.xDone AND (bStateMachine <>2);
		IF xTmp THEN
(*03.03.2017: KFS { *)
			RisingEdgeBtToolTension(CLK:=xToolTensionButton);
			IF RisingEdgeBtToolTension.Q THEN
				IF  T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension AND	T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolLeft AND T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolRight	THEN
					T_Visu.T_CtrleAction.iFunction:=510;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
				IF  NOT (T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension) THEN
					T_Visu.T_CtrleAction.iFunction:=510;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
			END_IF;
			RisingEdgeBtToolLeft(CLK:=xToolLeftButton);
			IF RisingEdgeBtToolLeft.Q THEN
				IF NOT T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension  THEN
					T_Visu.T_CtrleAction.iFunction:=511;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
				IF  T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension  AND NOT(T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolLeft) THEN
					T_Visu.T_CtrleAction.iFunction:=511;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
			END_IF;
			RisingEdgeBtToolRight(CLK:=xToolRightButton);
			IF RisingEdgeBtToolRight.Q THEN
				IF NOT T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension  THEN
					T_Visu.T_CtrleAction.iFunction:=512;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
				IF  T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension  AND NOT(T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolRight) THEN
					T_Visu.T_CtrleAction.iFunction:=512;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
			END_IF;
(*03.03.2017: KFS } *)
			RisingEdgeBtToolCenter(CLK:=xToolCenterButton);
			IF RisingEdgeBtToolCenter.Q THEN
				T_Visu.T_CtrleAction.iFunction:=513;
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF;
			RisingEdgeBtToolPrismaLeft(CLK:=xToolPrismaLeftButton);
			IF RisingEdgeBtToolPrismaLeft.Q THEN
				T_Visu.T_CtrleAction.iFunction:=514;
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF;
			RisingEdgeBtToolPrismaRight(CLK:=xToolPrismaRightButton);
			IF RisingEdgeBtToolPrismaRight.Q THEN
				T_Visu.T_CtrleAction.iFunction:=515;
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF;
		ELSE
			IF   NOT(T_Visu.T_CtrleAction.xExecute) AND T_Visu.T_CtrleAction.xDone  THEN
				RisingEdgeBtToolTension(CLK:=FALSE);
				RisingEdgeBtToolLeft(CLK:=FALSE);
				RisingEdgeBtToolRight(CLK:=FALSE);
				RisingEdgeBtToolCenter(CLK:=FALSE);
				RisingEdgeBtToolPrismaLeft(CLK:=FALSE);
				RisingEdgeBtToolPrismaRight(CLK:=FALSE);
			END_IF;
		END_IF;
	END_IF;
(*22.12.2009: KFS 	}	*)
(************************************************************************************************************************************************************************)
(*********end of the managment of the external start-stop button, special button and function button and task button and external tool buttons********)
(************************************************************************************************************************************************************************)

(* set system level *)
	IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem <> 999) AND (T_Visu.T_PlcParam.dwActualPage = 40) THEN
		IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem = iPwSystem THEN
		(* pw correct *)
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iActLevel:=2;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=2;
		(* wrong pw *)
		ELSE 	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=3; END_IF
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;
	END_IF
	IF (T_Visu.T_PlcParam.dwActualPage = 40) THEN
		RisingEdgeDynPassword(CLK:=TRUE);
		IF RisingEdgeDynPassword.Q THEN
			fbGetCpuAccount;
			fbPwSystem(	dwCounter:=fbGetCpuAccount.fbGetCpuCounter.dwCpuCntHi+fbGetCpuAccount.fbGetCpuCounter.dwCpuCntLo,
						iRandom=>T_Visu.ptrT_ExchgParam^.T_Visu.T_Level.iRandom,
						iPwSystem=>iPwSystem);
		END_IF;
	ELSE
		RisingEdgeDynPassword(CLK:=FALSE);
	END_IF;

(************************************************************************************************************************************************************************)
(**********************************						Profile Management Start						****************************************)
(************************************************************************************************************************************************************************)

(* Update profile list *)
	IF xUpdateProfileList THEN
		xTmp:= 	iPointerListProfile > 0
				AND (iPointerListProfile+4) <= csiMaxProfile;
		IF xTmp THEN
			jj:=1;
			FOR ii:=iPointerListProfile TO iPointerListProfile+4 DO
				T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileList[jj].iNumber:=ii;
				T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileList[jj].sName:=T_NovRam.T_Data.T_IDProfileStation[ii].sName;
				jj:=jj+1;
			END_FOR
		END_IF
		(* confirm update *)
		xUpdateProfileList:=FALSE;
	END_IF

(* Compare Profile and Process value *)
	xTmp:=	(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile <> 0);
	IF xTmp THEN
		fbCompareProfileProcessValue(T_Data_ProcessImageLoadData:=T_NovRam.T_Data.T_ProcessImageLoadData,
									T_Data_ProcessImageData:=T_NovRam.T_Data.T_ProcessImageData,
									xMicroRodActive:=xMicroRodActive);
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.xOnlineValueModified:=fbCompareProfileProcessValue.xProcessValueModified;
	END_IF

(* monitor change actual profile common *)
	IF (T_Visu.T_PlcParam.dwActualPage = 130) THEN
		IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber<>iActualActiveProfile THEN
			IF T_Visu.T_CtrleAction.xDone THEN
				(* set value from selected profile *)
				T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName
					:=T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName;
				(* save value from selected profile *)
				iActualActiveProfile:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber;
			END_IF
		END_IF
	END_IF

(* Pointer Profile List Up/Down Slow *)
	RisingEdgePtrProfileListUpDown(CLK:=	T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileUp
										OR T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileDown);
	IF RisingEdgePtrProfileListUpDown.Q THEN
		IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileUp THEN
			iPointerListProfile:=iPointerListProfile-5;
		ELSE iPointerListProfile:=iPointerListProfile+5; END_IF
		(* min/max=1/6 *)
		IF iPointerListProfile>(csiMaxProfile -5) THEN iPointerListProfile:=(csiMaxProfile - 4); END_IF
		IF iPointerListProfile<0 THEN iPointerListProfile:=1; END_IF
		T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileUp:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileDown:=FALSE;
		(* Update display  list *)
		xUpdateProfileList:=TRUE;
	END_IF

(* Pointer Profile List Up/Down Fast *)
	RisingEdgePtrProfileListUpDown(CLK:=	T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileUpFast
										OR T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileDownFast);
	IF RisingEdgePtrProfileListUpDown.Q THEN
		IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileUpFast THEN
			iPointerListProfile:=iPointerListProfile-10;
		ELSE iPointerListProfile:=iPointerListProfile+10; END_IF
		(* min/max=1/6 *)
		IF iPointerListProfile>(csiMaxProfile -5) THEN iPointerListProfile:=(csiMaxProfile - 4); END_IF
		IF iPointerListProfile<0 THEN iPointerListProfile:=1; END_IF
		T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileUpFast:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_ProfileManage.xListProfileDownFast:=FALSE;
		(* Update display  list *)
		xUpdateProfileList:=TRUE;
	END_IF

(************************************************************************************************************************************************************************)
(**********************************						Profile Management End						****************************************)
(************************************************************************************************************************************************************************)

(* Display info or warning message *)
	RisingEdgeKeySwitch1(CLK:=xSecurityKey);
	FailingEdgeKeySwitch1(CLK:=xSecurityKey);
	IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState <> 0 THEN
		(* info message *)
		IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState < 100THEN
		(* activ message during 3s, after that the message will be cleared *)
			TimerDisplayMessage(IN:=TRUE,PT:=T#3s);
			IF TimerDisplayMessage.Q THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
				TimerDisplayMessage(IN:=FALSE);
			END_IF
			IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState = 2) THEN
				IF (TimerDisplayMessage.ET > T#0.5s) THEN
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
					TimerDisplayMessage(IN:=FALSE);
				END_IF;
			END_IF;
		(* disable timer *)
		ELSE TimerDisplayMessage(IN:=FALSE); END_IF

		(* warning message *)
		xTmp:=	(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState > 100 AND T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState <200)
				AND T_Visu.T_CtrleAction.xDone;
		RisingEdgeReleaseWarning(CLK:=wActivBtLeft <> 16#0 OR T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wActivBt <> 16#0);
		(* the warning will be cleared by the operator *)
		IF xTmp AND (RisingEdgeReleaseWarning.Q OR RisingEdgeKeySwitch1.Q OR FailingEdgeKeySwitch1.Q) THEN
			IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState <> 120) THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			END_IF;
		END_IF
	END_IF

(* Monitor dynamic error text *)
	xTmp:=	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish <> ''
			AND T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState <> 401;
	IF xTmp THEN
		bStateMachine:=0;
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=401;
		xSetStateMachine:=TRUE;
		xCheckQuitError:=TRUE;
	END_IF
	IF xCheckQuitError THEN
		IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState <> 401) THEN
			xSetStateMachine:=TRUE;
			xCheckQuitError:=FALSE;
			IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
				bStateMachine:=3;
			ELSE
				bStateMachine:=1;
			END_IF;
		END_IF;
	END_IF;
	IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN
		bStateMachine:=4;
	END_IF;
	IF xSetStateMachine THEN
		xSetStateMachine:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReferenceMaxToolLength:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=bStateMachine;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=BYTE_TO_INT(bStateMachine);
	END_IF;

(* Reset settled value on the parameter list, without saved *)
	IF xResetParaListValue OR T_Visu.T_CtrleAction.xResetParaListValue THEN
		T_Visu.T_CtrleAction.xResetParaListValue:=FALSE;
		xResetParaListValue:=FALSE;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolLeft:=T_NovRAM.T_Data.T_Standard.T_TeachINToolLeft;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolCenter:=T_NovRAM.T_Data.T_Standard.T_TeachINToolCenter;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolRight:=T_NovRAM.T_Data.T_Standard.T_TeachINToolRight;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolFeeder:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_GrindFeeder:=T_NovRAM.T_Data.T_Standard.T_TeachINGrindFeeder;
		T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_AxisPosition:=T_NovRAM.T_Data.T_Standard.T_AxisPosition;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigMachineType:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigMachineType;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigAxisType:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigAxisType;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigVisuNavigation:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ParamToolTensionSystem:=T_NovRAM.T_Data.T_Standard.T_ToolTensionSystem;
		T_Visu.ptrT_ExchgParam^.T_Cylinder.T_ParamToolTension:=T_NovRAM.T_Data.T_Standard.T_Cyl_ToolTension;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara:=T_NovRAM.T_Data.T_ProcessImageData.T_CalibrationPara;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ProcessPara:=T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName:=T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry:=T_NovRAM.T_Data.T_ProcessImageData.T_GeometryPara;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMinToolDiameter:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMaxToolDiameter:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMinToolLength:=0.1;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMaxToolLength:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLengthOriginal:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal;
	END_IF;

(* Monitoring Process value *)
	IF T_Process.xReferenced THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#1;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#FE; END_IF
	IF NOT(T_Process.xEnd) THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#2;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#FD; END_IF
	IF T_Process.xError THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#4;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#FB; END_IF
	IF T_Process.xRdy THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#8;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#F7; END_IF
	IF T_Process.xEnd THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#10;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#EF; END_IF
	IF T_Process.xProcessHold THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#40;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#BF; END_IF
	IF T_Process.xStop THEN T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState OR 16#80;
		ELSE T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState AND 16#7F; END_IF

(* Monitoring Station value *)
	IF T_Station.TControl.xEnd AND T_Station.TControl.xRdy AND T_Station.TControl.xEnable THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine OR 16#1;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine AND 16#FE;
	END_IF;
	IF NOT(T_Station.TControl.xEnd) AND T_Station.TControl.xRdy AND T_Station.TControl.xEnable THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine OR 16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine AND 16#FD;
	END_IF;
	IF T_Station.TControl.xError THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine OR 16#4;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine AND 16#FB;
	END_IF;
	IF T_Station.TControl.xReferenced THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine OR 16#8;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachine AND 16#F7;
	END_IF;

(* Monitoring for the visu of the state of the machine *)
	T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachineLED:=16#0;
	IF T_Station.TControl.xError OR T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr OR (T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
	    T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr OR T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr OR T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr OR
	     (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachineLED:=16#4;
	ELSIF NOT(T_Station.TControl.xEnd) OR NOT(T_Process.xEnd) OR T_Station.TControl.xActiveMovement THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachineLED:=16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachineLED:=16#1;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachineLED <> 16#4) THEN
		IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
			T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateMachineLED:=16#0;
		END_IF;
	END_IF

(* Monitoring Axis value *)
	(* ToolLeft Monitoring *)
	IF T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xPower THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft OR 16#1;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft AND 16#FE;
	END_IF;
	IF NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xNotMoving) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft OR 16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft AND 16#FD;
	END_IF;
	IF T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft OR 16#4;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelLeft AND 16#FB;
	END_IF;
	(* ToolRight Monitoring *)
	IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xPower THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight OR 16#1;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight AND 16#FE;
	END_IF;
	IF NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xNotMoving) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight OR 16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight AND 16#FD;
	END_IF;
	IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight OR 16#4;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight AND 16#FB;
	END_IF;
	IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xSlave THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight OR 16#8;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelRight AND 16#F7;
	END_IF;
	(* ToolCenter Monitoring *)
	IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xPower THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter OR 16#1;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter AND 16#FE;
	END_IF;
	IF NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xNotMoving) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter OR 16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter AND 16#FD;
	END_IF;
	IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter OR 16#4;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter AND 16#FB;
	END_IF;
	IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xSlave THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter OR 16#8;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisReelCenter AND 16#F7;
	END_IF;
	(* ToolFeeder Monitoring *)
	IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder OR 16#1;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder AND 16#FE;
	END_IF;
	IF NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder OR 16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder AND 16#FD;
	END_IF;
	IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder OR 16#4;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder AND 16#FB;
	END_IF;
	IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xSlave THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder OR 16#8;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisWireFeeder AND 16#F7;
	END_IF;
	(* GrindFeeder Monitoring *)
	IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xPower THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind OR 16#1;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind AND 16#FE;
	END_IF;
	IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind OR 16#2;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind AND 16#FD;
	END_IF;
	IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind OR 16#4;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind AND 16#FB;
	END_IF;
	IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xSlave THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind OR 16#8;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind:=T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateAxisGrind AND 16#F7;
	END_IF;
	(* General Actual Axis value *)
	T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualToolRotSpeed:=T_Station.THardware.TAxisToolLeft.T_LiveValue.lrActualVelocity;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation = 1) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rActualToolRotationSpeed:=T_Station.THardware.TAxisToolLeft.T_LiveValue.lrActualVelocity;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation = 2) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rActualToolRotationSpeed:=T_Station.THardware.TAxisToolCenter.T_LiveValue.lrActualVelocity;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation = 3) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rActualToolRotationSpeed:=T_Station.THardware.TAxisToolRight.T_LiveValue.lrActualVelocity;
	END_IF;
	IF xMicroRodActive THEN
		IF (T_Visu.T_PlcParam.dwActualPage = 10) OR (T_Visu.T_PlcParam.dwActualPage = 20) THEN
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedPosition:=	T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition -
																						T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedPosition:=	T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition -
																						T_NovRam.T_Data.T_ProcessImageData.T_CalibrationPara.rStartPosToolFeedCalib;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage = 30) THEN
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedPosition:=	T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage = 330) THEN
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedPosition:=	T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition;
		END_IF;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rActualToolFeederPosition:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedSpeed:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualVelocity;
	ELSE
		(* On the MicroWire set the Position of the ToolFeed every time when the TeachPage will be activate to zero *)
		IF (T_Visu.T_PlcParam.dwActualPage = 310) AND NOT(xReadActualToolFeedPos) THEN
			rActualToolFeederPosition:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition;
			xReadActualToolFeedPos:=TRUE;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage <> 310) THEN
			xReadActualToolFeedPos:=FALSE;
		END_IF;
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rActualToolFeederPosition:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition - rActualToolFeederPosition;
		(* On the MicroWire set the Position of the ToolFeed every time when the Reference Page will be activate to zero *)
		IF (T_Visu.T_PlcParam.dwActualPage = 30) AND NOT(xReadActualToolFeedPos1) THEN
			rActualToolFeederPosition1:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition;
			xReadActualToolFeedPos1:=TRUE;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage <> 30) THEN
			xReadActualToolFeedPos1:=FALSE;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage = 30) THEN
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedPosition:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition - rActualToolFeederPosition1;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualWireFeedSpeed:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualVelocity;
		END_IF;
	END_IF;
	T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualGrindAxisPosition:=T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition;
	T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualGrindAxisSpeed:=T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualVelocity;
	T_Visu.ptrT_ExchgParam^.T_StationCommon.rActualGrindFeederPosition:=T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 0) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldToolFeederPosition:=0.0;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 1) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldToolFeederPosition:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 2) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldToolFeederPosition:=T_NovRam.T_Data.T_ProcessImageData.T_CalibrationPara.rStartPosToolFeedCalib;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 3) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldToolFeederPosition:=T_NovRam.T_Data.T_ProcessImageData.T_CalibrationPara.rMeasurePosToolFeedCalib;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 4) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldToolFeederPosition:=T_NovRam.T_Data.T_Standard.T_AxisPosition.rLoadPosToolFeedAuto;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 0) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldGrindFeederPosition:=0.0;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 1) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldGrindFeederPosition:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 2) THEN
		(* Security Position will be calculateted with the settled Tooldiameter plus the Offset *)
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldGrindFeederPosition:=	T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																		T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 3) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldGrindFeederPosition:=T_NovRam.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 4) THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rOldGrindFeederPosition:=T_NovRam.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax + T_NovRam.T_Data.T_Standard.T_TeachINGrindFeeder.rOffsetSWPosEndSwitch;
	END_IF;

(* Monitoring Cylinder value *)
	(* Cyl ToolTension *)
	T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension:=T_Station.THardware.TCylToolTension.T_CtrleCyl.T_AnalogCylinder.xActiv;
	IF T_Station.THardware.TCylToolTension.T_CtrleCyl.xStatePosOn THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosToolTension:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosToolTension OR 16#1;
		ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosToolTension:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosToolTension AND 16#FE; END_IF
	IF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectToolTensionForce < 2) THEN
		T_Visu.ptrT_ExchgParam^.T_Cylinder.rToSetToolTensionForce:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
	END_IF;
	IF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectToolTensionForce > 1) THEN
		T_Visu.ptrT_ExchgParam^.T_Cylinder.rToSetToolTensionForce:=T_NovRam.T_Data.T_Standard.T_Cyl_ToolTension.rForce;
	END_IF;
	(*22.12.2009: KFS	{	 *)
	IF xMicroRodActive THEN
		(* Cyl ToolLeft *)
		T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolLeft:=T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.T_Standard.xActivOn;
		IF T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xStatePosOn THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft OR 16#1;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft AND 16#FE; END_IF
		IF T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.xStatePosOff THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft OR 16#2;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolLeft AND 16#FD; END_IF
		(* Cyl ToolRight *)
		T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolRight:=T_Station.THardware.TCylToolRightActive.T_CtrleCyl.T_Standard.xActivOn;
		IF T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xStatePosOn THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight OR 16#1;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight AND 16#FE; END_IF
		IF T_Station.THardware.TCylToolRightActive.T_CtrleCyl.xStatePosOff THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight OR 16#2;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolRight AND 16#FD; END_IF
		(* Cyl ToolCenter *)
		T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolCenter:=T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.T_Standard.xActivOn;
		IF T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xStatePosOn THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter OR 16#1;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter AND 16#FE; END_IF
		IF T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.xStatePosOff THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter OR 16#2;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolCenter AND 16#FD; END_IF
		(* Cyl ToolPrismaLeft *)
		T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolPrismaLeft:=T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.T_Standard.xActivOn;
		IF T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xStatePosOn THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft OR 16#1;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft AND 16#FE; END_IF
		IF T_Station.THardware.TCylToolPrismaLeftActive.T_CtrleCyl.xStatePosOff THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft OR 16#2;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismaLeft AND 16#FD; END_IF
		(* Cyl ToolPrismaRight *)
		T_Visu.ptrT_ExchgParam^.T_Cylinder.xCylToolPrismaRight:=T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.T_Standard.xActivOn;
		IF T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xStatePosOn THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight OR 16#1;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight AND 16#FE; END_IF
		IF T_Station.THardware.TCylToolPrismaRightActive.T_CtrleCyl.xStatePosOff THEN T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight OR 16#2;
			ELSE T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight:=T_Visu.ptrT_ExchgParam^.T_Cylinder.bPosCylToolPrismalRight AND 16#FD; END_IF
	END_IF;
	(*22.12.2009: KFS	}	 *)

(* Bt Function panel *)
	(* Fn Bt function panel state *)
	CASE T_Visu.T_PlcParam.dwActualPage OF
	10:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xPlungeActivationGeometry THEN wTmp:=wTmp+16#1; ELSE wTmp:=wTmp AND 16#FE; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xDisplaceActivationGeometry THEN wTmp:=wTmp+16#2; ELSE wTmp:=wTmp AND 16#FD; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#4; ELSE wTmp:=wTmp AND 16#FB; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xWarmUp THEN wTmp:=wTmp+16#20; ELSE wTmp:=wTmp AND 16#DF; END_IF
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xPower AND
						((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xPower AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xPower AND
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower AND
						T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xPower;
				IF xTmp THEN wTmp:=wTmp+16#8; ELSE wTmp:=wTmp AND 16#F7; END_IF
	20:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xPlungeActivationGroove THEN wTmp:=wTmp+16#1; ELSE wTmp:=wTmp AND 16#FE; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xDisplaceActivationGroove THEN wTmp:=wTmp+16#2; ELSE wTmp:=wTmp AND 16#FD; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#4; ELSE wTmp:=wTmp AND 16#FB; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xBlockGrindFeeder THEN wTmp:=wTmp+16#20; ELSE wTmp:=wTmp AND 16#DF; END_IF
	30:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#4; ELSE wTmp:=wTmp AND 16#FB; END_IF
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xPower AND
						((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xPower AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xPower AND
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower AND
						T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xPower;
				IF xTmp THEN wTmp:=wTmp+16#8; ELSE wTmp:=wTmp AND 16#F7; END_IF
	110:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.xPlungeActivationCalib THEN wTmp:=wTmp+16#1; ELSE wTmp:=wTmp AND 16#FE; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.xDisplaceActivationCalib THEN wTmp:=wTmp+16#2; ELSE wTmp:=wTmp AND 16#FD; END_IF
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#4; ELSE wTmp:=wTmp AND 16#FB; END_IF
	220:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#4; ELSE wTmp:=wTmp AND 16#FB; END_IF
	310:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#10; ELSE wTmp:=wTmp AND 16#EF; END_IF
	330:			wTmp:=16#0;
				IF T_Visu.ptrT_ExchgParam^.T_Cylinder.xToolTension THEN wTmp:=wTmp+16#10; ELSE wTmp:=wTmp AND 16#EF; END_IF
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xPower AND
						((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xPower AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xPower AND
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower AND
						T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xPower;
				IF xTmp THEN wTmp:=wTmp+16#1; ELSE wTmp:=wTmp AND 16#FE; END_IF
	ELSE wTmp:=16#0;
	END_CASE
	T_Visu.ptrT_ExchgParam^.T_BtFunctionPanel.wState:=wTmp;

(* Monitoring ToolTorque *)
	IF (T_Visu.T_PlcParam.dwActualPage = 220) THEN
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualToolLeftTorque:=T_Station.THardware.TAxisToolLeft.T_LiveValue.uiActualTorque;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualToolRightTorque:=T_Station.THardware.TAxisToolRight.T_LiveValue.uiActualTorque;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualToolCenterTorque:=T_Station.THardware.TAxisToolCenter.T_LiveValue.uiActualTorque;
		FBCalcTorqueToolLeft(	xStart:=TRUE,
								uiActualTorque:= T_Station.THardware.TAxisToolLeft.T_LiveValue.uiActualTorque,
								uiZeroTorque:=uiToolLeftZeroTorque,
								iStepCalc:= 100);
		FBCalcTorqueToolCenter(	xStart:=TRUE,
								uiActualTorque:= T_Station.THardware.TAxisToolCenter.T_LiveValue.uiActualTorque,
								uiZeroTorque:=uiToolCenterZeroTorque,
								iStepCalc:= 100);
		FBCalcTorqueToolRight(	xStart:=TRUE,
								uiActualTorque:= T_Station.THardware.TAxisToolRight.T_LiveValue.uiActualTorque,
								uiZeroTorque:=uiToolRightZeroTorque,
								iStepCalc:= 100);
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCalculToolLeftTorque:=FBCalcTorqueToolLeft.uiCalcTorque;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCalculToolCenterTorque:=FBCalcTorqueToolCenter.uiCalcTorque;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCalculToolRightTorque:=FBCalcTorqueToolRight.uiCalcTorque;
	ELSE
		FBCalcTorqueToolLeft(	xStart:=FALSE);
		FBCalcTorqueToolCenter(	xStart:=FALSE);
		FBCalcTorqueToolRight(	xStart:=FALSE);
	END_IF;

(* Monitoring Max ToolRotation Speed *)
	IF xMicroRodActive THEN
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rMaxSpeedToolRotation:=1200.0;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_StationCommon.rMaxSpeedToolRotation:=500.0;
	END_IF;

(* Monitoring AutoGeometry or AutoGroove *)
	IF (T_Visu.T_PlcParam.dwActualPage = 10) OR (T_Visu.T_PlcParam.dwActualPage = 20) THEN
		xPart1:=xPart2:=xPart3:=xPart4:=FALSE;
		rToolTotalLength:=0.0;
		IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[1] THEN
			xPart1:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[1];
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[1];
			rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[1];
			IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[2] THEN
				xPart2:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[2];
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[2];
				rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[2];
				IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
					xPart3:=TRUE;
					T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[3]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[3];
					T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[3]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[3];
					rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[3];
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
						xPart4:=TRUE;
						T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[4]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4];
						T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[4]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[4];
						rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[4];
					END_IF;
				END_IF;
			END_IF;
		ELSIF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[2] THEN
			xPart2:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[2];
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[2];
			rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[2];
			IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
				xPart3:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[3];
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[3];
				rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[3];
				IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
					xPart4:=TRUE;
					T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[3]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4];
					T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[3]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[4];
					rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[4];
				END_IF;
			END_IF;
		ELSIF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
			xPart3:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[3];
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[3];
			rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[3];
			IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
				xPart4:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4];
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[4];
				rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[4];
			END_IF;
		ELSIF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
			xPart4:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4];
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[4];
			rToolTotalLength:=rToolTotalLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[4];
		ELSE
			FOR ii:=1 TO 4 DO
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[ii]:=0;
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[ii]:=0;
			END_FOR;
		END_IF;
		iPartActive:=0;
		IF xPart1 THEN iPartActive:=iPartActive + 1; END_IF;
		IF xPart2 THEN iPartActive:=iPartActive + 1; END_IF;
		IF xPart3 THEN iPartActive:=iPartActive + 1; END_IF;
		IF xPart4 THEN iPartActive:=iPartActive + 1; END_IF;
		IF (iPartActive > 0) THEN
			FOR ii:=4 TO (iPartActive + 1) BY -1 DO
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arStartDiameter[ii]:=0;
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.arEndDiameter[ii]:=0;
			END_FOR;
		END_IF;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.iTotalCountDownCycle:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.iCycleGeometry;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.iTotalCountDownPlungeCycle:=T_Station.T_WorkTool.iTotalCountDownPlungeCycle;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.iTotalCountDownGrooveCycle:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.iNumberOfGrooves;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolDiameter:=T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength:=rToolTotalLength * 10.0;	(* umwandeln von cm in mm *)
		IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
			IF T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.xPlungeActivationGeometry THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength + T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.rPlungeLengthToolFeedGeometry;
			END_IF;
			IF T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.xDisplaceActivationGeometry THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength + T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry;
			END_IF;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
			IF T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove AND NOT(T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder) THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength + T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.rPlungeLengthToolFeedGroove;
			END_IF;
			IF T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.xDisplaceActivationGroove THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTotalLength + T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.rDisplaceLengthToolFeedGroove;
			END_IF;
		END_IF;
	ELSE
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.iCountDownCycle:=1;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.iCountDownPlungeCycle:=1;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.iCountDownGrooveCycle:=1;
	END_IF;

(* Tool Geometry Managment *)
	IF (T_Visu.T_PlcParam.dwActualPage = 120) THEN
		FailingEdgeGeometryManagement(CLK:=TRUE);
		RisingEdgeGeometryManagement(CLK:=(T_Visu.T_PlcParam.dwActualPage = 120));
		IF RisingEdgeGeometryManagement.Q THEN
			arSaveToolGeometry:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry;
		END_IF;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMinToolDiameter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.rToolDiameterMin;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMaxToolDiameter:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.rToolDiameterMax;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMinToolLength:=0.1;
		T_Visu.ptrT_ExchgParam^.T_GeometryCommon.rMaxToolLength:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength;
		IF (arSaveToolGeometry.arEndDiameter[1] <> T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[1]) THEN
			arSaveToolGeometry.arEndDiameter[1]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[1];
			arSaveToolGeometry.arStartDiameter[2]:=arSaveToolGeometry.arEndDiameter[1];
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[2]:=arSaveToolGeometry.arStartDiameter[2];
		END_IF;
		IF (arSaveToolGeometry.arStartDiameter[2] <> T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[2]) THEN
			arSaveToolGeometry.arStartDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[2];
			arSaveToolGeometry.arEndDiameter[1]:=arSaveToolGeometry.arStartDiameter[2];
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[1]:=arSaveToolGeometry.arEndDiameter[1];
		END_IF;
		IF (arSaveToolGeometry.arEndDiameter[2] <> T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[2]) THEN
			arSaveToolGeometry.arEndDiameter[2]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[2];
			arSaveToolGeometry.arStartDiameter[3]:=arSaveToolGeometry.arEndDiameter[2];
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[3]:=arSaveToolGeometry.arStartDiameter[3];
		END_IF;
		IF (arSaveToolGeometry.arStartDiameter[3] <> T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[3]) THEN
			arSaveToolGeometry.arStartDiameter[3]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[3];
			arSaveToolGeometry.arEndDiameter[2]:=arSaveToolGeometry.arStartDiameter[3];
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[2]:=arSaveToolGeometry.arEndDiameter[2];
		END_IF;
		IF (arSaveToolGeometry.arEndDiameter[3] <> T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[3]) THEN
			arSaveToolGeometry.arEndDiameter[3]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[3];
			arSaveToolGeometry.arStartDiameter[4]:=arSaveToolGeometry.arEndDiameter[3];
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4]:=arSaveToolGeometry.arStartDiameter[4];
		END_IF;
		IF (arSaveToolGeometry.arStartDiameter[4] <> T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4]) THEN
			arSaveToolGeometry.arStartDiameter[4]:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[4];
			arSaveToolGeometry.arEndDiameter[3]:=arSaveToolGeometry.arStartDiameter[4];
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[3]:=arSaveToolGeometry.arEndDiameter[3];
		END_IF;
		FOR ii:=1 TO 4 DO
			IF NOT(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[ii]) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[ii]:=0;
			END_IF;
		END_FOR;
		FOR ii:=1 TO 4 DO
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[ii] = T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[ii]) THEN
				IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
					T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[ii]:=2;
				END_IF;
			END_IF;
		END_FOR;
		FOR ii:=1 TO 4 DO
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[ii] > T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[ii]) THEN
				IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
					T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[ii]:=3;
				END_IF;
			END_IF;
		END_FOR;
		FOR ii:=1 TO 4 DO
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[ii] < T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[ii]) THEN
				IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
					T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[ii]:=4;
				END_IF;
			END_IF;
		END_FOR;
		rCalcTotalToolLength:=0.0;
		FOR ii:=1 TO 4 DO
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[ii] = 0) OR
			     (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[ii] > T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.rToolDiameterMax) OR
			     (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arStartDiameter[ii] < T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.rToolDiameterMin) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(SETBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii-1)));
			ELSE
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(CLEARBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii-1)));
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[ii] = 0) OR
			     (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[ii] > T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.rToolDiameterMax) OR
			     (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arEndDiameter[ii] < T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.rToolDiameterMin) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(SETBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii+3)));
			ELSE
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(CLEARBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii+3)));
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[ii] = 0) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(SETBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii+7)));
			ELSE
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(CLEARBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii+7)));
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[ii] = 0) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(SETBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii+11)));
			ELSE
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=DWORD_TO_WORD(CLEARBIT32(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput,INT_TO_SINT(ii+11)));
			END_IF;
			IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[ii] THEN
				rCalcTotalToolLength:=rCalcTotalToolLength + T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionLength[ii];
			END_IF;
		END_FOR;
		IF (rCalcTotalToolLength > T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength) AND ((T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput AND 16#F000) = 0) THEN
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput OR 16#F000;
		END_IF;
		IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[1] THEN
			IF ((T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput AND 16#1111) <> 0) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[1]:=5;
			END_IF;
		END_IF;
		IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[2] THEN
			IF ((T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput AND 16#2222) <> 0) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[2]:=5;
			END_IF;
		END_IF;
		IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
			IF ((T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput AND 16#4444) <> 0) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[3]:=5;
			END_IF;
		END_IF;
		IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
			IF ((T_Visu.ptrT_ExchgParam^.T_GeometryCommon.wWrongInput AND 16#8888) <> 0) THEN
				T_Visu.ptrT_ExchgParam^.T_GeometryCommon.abSectionSelectForm[4]:=5;
			END_IF;
		END_IF;
	ELSE
		RisingEdgeGeometryManagement(CLK:=FALSE);
		FailingEdgeGeometryManagement(CLK:=FALSE);
		(*If the page change, then copy again the settled value *)
		IF FailingEdgeGeometryManagement.Q THEN
			T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry:=T_NovRAM.T_Data.T_ProcessImageData.T_GeometryPara;
		END_IF;
	END_IF;

(* Monitoring Tool Geometry and Tool Calibration calculation Parameter *)
	T_Station.T_WorkTool.iBaseGearDivider:=15000;
	T_Station.T_WorkTool.rPrismaFactor:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaFactor;
	T_Station.T_WorkTool.rGrindFeederScaleFactor:=T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrScaleFactor;
	T_Station.T_WorkTool.rToolFeederGearRatio:=T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearRatio;
	T_Station.T_WorkTool.rToolFeederScaleFactor:=T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrScaleFactor;
	T_Station.T_WorkTool.rToolRightGearRatio:=T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio;
	IF (T_Visu.T_PlcParam.dwActualPage = 10) OR (T_Visu.T_PlcParam.dwActualPage = 20) THEN
		IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
			iAutoProcess:=1;
			rToolRotationSpeed:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.rSpeedToolRotationGeometry;
			T_Station.T_WorkTool.rPlungeSpeedGrindFeed:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry;
			T_Station.T_WorkTool.rDisplaceSpeedGrindFeed:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry;
		END_IF;
		IF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
			iAutoProcess:=2;
			rToolRotationSpeed:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.rSpeedToolRotationGroove;
			T_Station.T_WorkTool.rPlungeSpeedGrindFeed:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.rPlungeSpeedGrindFeedGroove;
			T_Station.T_WorkTool.rDisplaceSpeedGrindFeed:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove;
		END_IF;
	ELSE
		iAutoProcess:=0;
	END_IF;
	IF (((T_Visu.T_PlcParam.dwActualPage = 10) OR (T_Visu.T_PlcParam.dwActualPage = 20) OR (T_Visu.T_PlcParam.dwActualPage = 110)) OR xCalcAgainProcTime) AND T_Visu.T_CtrleVisu.xDone THEN
		IF NOT(xCalcFirstTime) OR xCalcAgainProcTime THEN
			xCalcFirstTime:=TRUE;
			FBCalcProcessTime(	T_Geometry:=T_NovRAM.T_Data.T_ProcessImageData.T_GeometryPara,
								T_AutoGeometryPara:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara,
								T_CalibrationPara:=T_NovRAM.T_Data.T_ProcessImageData.T_CalibrationPara,
								T_AutoGroovePara:=T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara,
								T_ProcessPara:=T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara,
								rToolRotationSpeed:=rToolRotationSpeed,
								rToolDiameter:=T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess,
								rToolDiameterWithOffset:=	T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
														T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess,
								iAutoProcess:=iAutoProcess,
								xMicroRodActive:=xMicroRodActive,
								T_WorkTool:=T_Station.T_WorkTool);
		END_IF;
		xCalcAgainProcTime:=FALSE;
		rAutoTimeTotal:=FBCalcProcessTime.rProcessTime;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.tAutoTimeTotal:=REAL_TO_TIME(rAutoTimeTotal * 1000.0);
	ELSE
		xCalcFirstTime:=FALSE;
	END_IF;
	IF T_Process.xEnd OR T_Process.xError THEN
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.tAutoTimeLeft:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.tAutoTimeTotal;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.bProgressbarAutoGeometry:=0;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.bProgressbarAutoGroove:=0;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.bProgressbarToolCalibration:=0;
	END_IF;

(* Monitoring ToolCalibration *)
	IF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolLengthCalibration:=T_NovRAM.T_Data.T_ProcessImageData.T_CalibrationPara.rToolLengthCylinderPartCalib;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolDiameter:=T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rPitchCalibration:=T_NovRAM.T_Data.T_ProcessImageData.T_CalibrationPara.rPitchCalib;
	END_IF;

(* Monitoring Correction Tool Diameter *)
	IF (T_Visu.T_PlcParam.dwActualPage = 420) OR (T_Visu.T_PlcParam.dwActualPage = 11) OR (T_Visu.T_PlcParam.dwActualPage = 21) THEN
		RisingEdgeToolDiameter(CLK:=(T_Visu.T_PlcParam.dwActualPage = 420) OR (T_Visu.T_PlcParam.dwActualPage = 11) OR (T_Visu.T_PlcParam.dwActualPage = 21));
		IF RisingEdgeToolDiameter.Q THEN
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter:=0.0;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.xKeyPadActivation:=FALSE;
		END_IF;
		IF (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter = 0) THEN
			T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateToolDiameter:=1;
		END_IF;
		IF (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter > 0) THEN
			T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateToolDiameter:=3;
		END_IF;
		IF (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter < 0) THEN
			T_Visu.ptrT_ExchgParam^.T_StationCommon.bStateToolDiameter:=2;
		END_IF;
	ELSE
		RisingEdgeToolDiameter(CLK:=FALSE);
	END_IF

(* Monitoring TeachIn Tool Rotation *)
	IF (T_Visu.T_PlcParam.dwActualPage = 210) THEN
		IF xToolRotationMasterSlave THEN
			T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation:=1;	(* Force Selection by choice of MasterSlave to the ToolLeft TouchButton *)
		END_IF;
		IF (T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft = 2) OR (T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter = 2) OR
		     (T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight = 2) THEN
			T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation:=iSelectAxisToolRotation;	(* Force Selection by active movement *)
		END_IF;
		IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation <> iSelectAxisToolRotation) THEN
			iSelectAxisToolRotation:=T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation;
		END_IF;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage <> 210) AND xToolRotationMasterSlave THEN
		xToolRotationMasterSlave:=FALSE;
		IF xMicroRodActive THEN
			IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xSlave AND T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone THEN
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=25;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xSlave AND T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone THEN
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=25;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(xMicroRodActive) THEN
			IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xSlave AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
	END_IF;

(* Monitoring Prisma *)
	IF (T_Visu.T_PlcParam.dwActualPage = 430) THEN
		FailingEdgePrisma(CLK:=TRUE);
		RisingEdgePrisma(CLK:=(T_Visu.T_PlcParam.dwActualPage = 430));
		IF RisingEdgePrisma.Q THEN
		(* 0= 3 value prisma, 1 = 3 value prisma input para, 2 = 2 value prisma, 3 = 2 value prisma input para *)
			IF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 1) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=0;
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 3) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=2;
			END_IF;
		END_IF;
	ELSE
		RisingEdgePrisma(CLK:=FALSE);
		FailingEdgePrisma(CLK:=FALSE);
		(*If the page change, then copy again the settled value *)
		IF FailingEdgePrisma.Q THEN
			T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara;
		END_IF;
	END_IF

(* Tmp timer *)
	TimerONTmp(IN:=TRUE);

(************************************************************************************************************************************************************************)
(***************                                          start of the management for call a function of the visualisation interface                                           ********************)
(************************************************************************************************************************************************************************)
(* waiting for executing action *)
	(* ...monitor Key panel "Enter" *)
	RisingEdgeKeyPanel_Enter(CLK:=T_Visu.ptrT_ExchgParam^.T_Visu.xKey_Enter);
	(* ...monitor Key panel "Esc" *)
	RisingEdgeKeyPanel_Esc(CLK:=T_Visu.ptrT_ExchgParam^.T_Visu.xKey_Escape);
	IF RisingEdgeKeyPanel_Esc.Q THEN tTimeOutAction:=TimerAction.ET; END_IF
	(*... not ready *)
	TimerNotReady(IN:=FALSE, PT:=T#2s);
	T_Visu.T_CtrleAction.xNotReady:=TimerNotReady.Q;

(* ...message *)
	RisingEdgeActionNotReady(CLK:=T_Visu.T_CtrleAction.xNotReady);
	IF RisingEdgeActionNotReady.Q AND T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState < 200 THEN
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=101; END_IF
	(* Release 'Not ready' action control structure *)
	FallingEdgeActionNotReady(CLK:=T_Visu.T_CtrleAction.xNotReady);
	IF FallingEdgeActionNotReady.Q THEN
		IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState =101) THEN
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
		END_IF;
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		(*
		iStepActionRef:=1;
		iStepActionNovRam:=1;
		*)
		xStepActionDone:=FALSE;
		TimerAction(IN:=FALSE);
	END_IF
	(* ...done *)
	RisingEdgeActionDone(CLK:=T_Visu.T_CtrleAction.xDone);
	IF RisingEdgeActionDone.Q THEN
		(* disable mask stop action *)
		(*wStopActionMaskBtPanelRight:=16#0;*)
		(*xWaitingReleaseStopBtPanel:=FALSE;*)
		IF T_Visu.T_CtrleAction.iFunction > 100
		    AND (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState = 0 OR (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState  > 100 AND T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState < 200)) THEN
			IF NOT TimerAction.Q AND NOT FallingEdgeActionNotReady.Q THEN
				IF NOT(xBlockConfirmMessage) THEN
					(* call confirmation message *)
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState
						:=iFctReturnConfMessage(iNumAction:=T_Visu.T_CtrleAction.iFunction);
				ELSE
					xBlockConfirmMessage:=FALSE;
				END_IF;
			(* call cancelled message *)
			ELSE T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=5; END_IF
		END_IF
	END_IF
	(* ...error *)
	RisingEdgeActionError(CLK:=T_Visu.T_CtrleAction.xErr);
	IF RisingEdgeActionError.Q THEN
	(* call function bloc action error *)
		(*fbQvisError(	udiActionError:=T_Visu.T_CtrleAction.udiErrorID,
					T_Message:=T_Visu.ptrT_ExchgParam^.T_Visu.T_Message);*)
		(* Init. variable *)
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		(*
		iStepActionRef:=1;
		iStepActionNovRam:=1;
		*)
		xStepActionDone:=FALSE;
	END_IF
	(* ...reset *)
	RisingEdgeResetAction(CLK:=T_Visu.T_CtrleAction.xReset);
	IF RisingEdgeResetAction.Q THEN
		(* Init. variable *)
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		(*
		iStepActionRef:=1;
		iStepActionNovRam:=1;
		*)
		xStepActionDone:=FALSE;
		TimerAction(IN:=FALSE);
		(* Release reset *)
		T_Visu.T_CtrleAction.xReset:=FALSE;
	END_IF

	(* Execute Function *)
	RisingEdgeExecuteAction(CLK:=T_Visu.T_CtrleAction.xExecute);
	IF RisingEdgeExecuteAction.Q THEN
		(* confirm action execution *)
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		CASE T_Visu.T_CtrleAction.iFunction OF
			(* Set parameter page *)
			3:	xSetParameterPage:=TRUE;
				tTimeOutAction:=T#3s;
			(* Change Page Button Panel Left *)
			6:	xBtPanelLeftChangePage:=TRUE;
				tTimeOutAction:=T#3s;
			(* next page vertical *)
			12:	xNextPageVertical:=TRUE;
				tTimeOutAction:=T#3s;
			(* Delete error List *)
			20:	xDeleteErrorList:=TRUE;
				tTimeOutAction:=T#3s;
			(* Reset error *)
			99:	xResetError:=TRUE;
				tTimeOutAction:=T#3s;
			(* Open Overlay for input measured tool diameter *)
			101:	xOverlayMeasureToolDia:=TRUE;
				tTimeOutAction:=T#9999s;
			(* Plunge On/Off *)
			102:	xPlungeActivation:=TRUE;
				tTimeOutAction:=T#3s;
			(* Displace On/Off *)
			103:	xDisplaceActivation:=TRUE;
				tTimeOutAction:=T#3s;
			(* AutoGroove-->Block GrindFeeder On/Off *)
			104:	xBlockGrindFeederActivation:=TRUE;
				tTimeOutAction:=T#3s;
			(* AutoGroove-->ToolFeeder move to StartPos *)
			105:	xToolFeederMoveStartPos:=TRUE;
				tTimeOutAction:=T#3s;
			(* AutoGeometry and AutoGroove-->Switch On/Off all Axis Power *)
			106:	xToggleAllAxisPower:=TRUE;
				tTimeOutAction:=T#3s;
			(* AutoGeometry and AutoGroove-->ToolFeeder move to LoadPos *)
			107:	xToolFeederMoveLoadPos:=TRUE;
				tTimeOutAction:=T#3s;
(*08.07.2014: KFS	{	*)
			(* AutoGeometry -->WarmUp On/OFF *)
			108:	xWarmUp:=TRUE;
				tTimeOutAction:=T#3s;
(*08.07.2014: KFS	}	*)
			(* Correction Tool Diameter + *)
			110:	xCorrectionToolDiameterAdd:=TRUE;
				tTimeOutAction:=T#3s;
			(* Correction Tool Diameter ++ *)
			111:	xCorrectionToolDiameterAddMore:=TRUE;
				tTimeOutAction:=T#3s;
			(* Correction Tool Diameter - *)
			112:	xCorrectionToolDiameterSub:=TRUE;
				tTimeOutAction:=T#3s;
			(* Correction Tool Diameter -- *)
			113:	xCorrectionToolDiameterSubMore:=TRUE;
				tTimeOutAction:=T#3s;
			(* Reset Tool Diameter Correction *)
			114:	xResetToolDiameterCorrection:=TRUE;
				tTimeOutAction:=T#3s;
			(* Keypad Activation *)
			115: xKeyPadActivation:=TRUE;
				tTimeOutAction:=T#3s;
			(* Function Correction Tool Diameter *)
			116:	xFctCorrectionToolDiameter:=TRUE;
				tTimeOutAction:=T#3s;
			(* Select Prisma 1 or 2 Input *)
			120:	xSelectPrisma:=TRUE;
				tTimeOutAction:=T#3s;
			(* Set calculated ToolRotation Torque *)
			130:	xSetCalculToolRotTorque:=TRUE;
				tTimeOutAction:=T#3s;
			(* Reset calculated ToolRotation Torque *)
			131:	xResetCalculToolRotTorque:=TRUE;
				tTimeOutAction:=T#3s;
			(* Open Overlay for input the correction of the position of the GrindFeeder *)
			132:	xOverlayGrindFeedSetPlung:=TRUE;
				tTimeOutAction:=T#9999s;
			(* Activation Section 1 *)
			201: (* 13.10.2010 KFS 	{ 	*)
				(*	xActivationSection1:=TRUE;
					tTimeOutAction:=T#3s			*)
				;
				(* 13.10.2010 KFS   }	 *)
			(* Activation Section 1 *)
			202:	xActivationSection2:=TRUE;
				tTimeOutAction:=T#3s;
			(* Activation Section 1 *)
			203:	xActivationSection3:=TRUE;
				tTimeOutAction:=T#3s;
			(* Activation Section 1 *)
			204:	xActivationSection4:=TRUE;
				tTimeOutAction:=T#3s;
			(* Set pitch equal *)
			205:	xSetPitchEqual:=TRUE;
				tTimeOutAction:=T#3s;
			(* TeachIN page *)
			301..399:	(* set pointer, default pointer axis slide *)
					ptrTeachINAxis:=ADR(T_Station.THardware.TAxisToolLeft);
					iSelectedAxis:=1;
					IF (T_Visu.T_PlcParam.dwActualPage = 210) THEN
						xSlowFast:=T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolRotation;
						IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation = 1) THEN
							iSelectedAxis:=1;
							TParaAxisTeachIN:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolLeft:=T_NovRam.T_Data.T_Standard.T_TeachINToolLeft;
							ptrTeachINAxis:=ADR(T_Station.THardware.TAxisToolLeft);
						END_IF;
						IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation = 2) THEN
							iSelectedAxis:=2;
							TParaAxisTeachIN:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolCenter:=T_NovRam.T_Data.T_Standard.T_TeachINToolCenter;
							ptrTeachINAxis:=ADR(T_Station.THardware.TAxisToolCenter);
						END_IF;
						IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSelectAxisToolRotation = 3) THEN
							iSelectedAxis:=3;
							TParaAxisTeachIN:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolRight:=T_NovRam.T_Data.T_Standard.T_TeachINToolRight;
							ptrTeachINAxis:=ADR(T_Station.THardware.TAxisToolRight);
						END_IF;
					END_IF;
					IF (T_Visu.T_PlcParam.dwActualPage = 30) OR (T_Visu.T_PlcParam.dwActualPage = 310) OR (T_Visu.T_PlcParam.dwActualPage = 320) OR (T_Visu.T_PlcParam.dwActualPage = 330) THEN
						iSelectedAxis:=4;
						xSlowFast:=T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolFeed;
						TParaAxisTeachIN:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolFeeder:=T_NovRam.T_Data.T_Standard.T_TeachINToolFeeder;
						ptrTeachINAxis:=ADR(T_Station.THardware.TAxisToolFeeder);
					END_IF;
					IF (T_Visu.T_PlcParam.dwActualPage = 410) THEN
						iSelectedAxis:=5;
						xSlowFast:=T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastGrindFeeder;
						TParaAxisTeachIN:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_GrindFeeder:=T_NovRam.T_Data.T_Standard.T_TeachINGrindFeeder;
						ptrTeachINAxis:=ADR(T_Station.THardware.TAxisGrindFeeder);
					END_IF;
					CASE T_Visu.T_CtrleAction.iFunction OF
					(* Stop axis movement *)
					301:	xStopAxis:=TRUE;
						tTimeOutAction:=T#4s;
					(* Move Axis Absolut *)
					305:	IF (iSelectedAxis = 4) THEN
							IF xMicroRodActive THEN
								IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 0) THEN
									ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rNewToolFeederPosition;
								END_IF;
								IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 1) THEN
									ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
								END_IF;
								IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 2) THEN
									ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_ProcessImageData.T_CalibrationPara.rStartPosToolFeedCalib;
								END_IF;
								IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 3) THEN
									ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_ProcessImageData.T_CalibrationPara.rMeasurePosToolFeedCalib;
								END_IF;
								IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 4) THEN
									ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_Standard.T_AxisPosition.rLoadPosToolFeedAuto;
								END_IF;
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rPositionSpeed;
								xMoveAbsPosition:=TRUE;
							END_IF;
							IF NOT(xMicroRodActive) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrDistance:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rNewToolFeederPosition;
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rPositionSpeed;
								xMoveRelPosition:=TRUE;
							END_IF;
						END_IF;
						IF (iSelectedAxis = 5) THEN
							IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 0) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rNewGrindFeederPosition;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 1) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 2) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrPosition:=	T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
																	T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 3) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin;;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 4) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrPosition:=T_NovRam.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax + T_NovRam.T_Data.T_Standard.T_TeachINGrindFeeder.rOffsetSWPosEndSwitch;
							END_IF;
							ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rPositionSpeed;
							xMoveAbsPosition:=TRUE;
						END_IF;
						tTimeOutAction:=T#999s;
					(* Move Inc Slow/Fast Pos *)
					310..311: IF NOT(xSlowFast) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrDistance:=TParaAxisTeachIN.rIncSlow;
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelSlow;
							ELSE
								ptrTeachINAxis^.T_CtrleSingle.lrDistance:=TParaAxisTeachIN.rIncFast;
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelFast;
							END_IF
							xMoveRelPosition:=TRUE;
							tTimeOutAction:=T#200s;
					(* Move Inc Slow/Fast Neg *)
					312..313:	IF NOT(xSlowFast) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrDistance:=TParaAxisTeachIN.rIncSlow * -1.0;
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelSlow;
							ELSE
								ptrTeachINAxis^.T_CtrleSingle.lrDistance:=TParaAxisTeachIN.rIncFast * -1.0;
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelFast;
							END_IF
							xMoveRelPosition:=TRUE;
							tTimeOutAction:=T#200s;
					(* Move Vel Slow/Fast Pos *)
					314..315:	IF NOT(xSlowFast) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelSlow;
							ELSE
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelFast;
							END_IF
							xMoveContinousVel:=TRUE;
							tTimeOutAction:=T#200s;
					(* Move Vel Slow/Fast Neg *)
					316..317:	IF NOT(xSlowFast) THEN
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelSlow * -1.0;
							ELSE
								ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=TParaAxisTeachIN.rVelFast * -1.0;
							END_IF
							xMoveContinousVel:=TRUE;
							tTimeOutAction:=T#200s;
					(* Move Continuos Velocity *)
					318:		ptrTeachINAxis^.T_CtrleSingle.lrVelocity:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rNewToolRotationSpeed;
							xMoveContinousVel:=TRUE;
							tTimeOutAction:=T#200s;
					(* Switch WireFeed Jog Speed Slow/Fast *)
					320:		IF ((iSelectedAxis = 1) OR (iSelectedAxis = 2) OR (iSelectedAxis = 3)) AND (T_Visu.T_PlcParam.dwActualPage <> 30) THEN
								xSlowFastJogToolRotation:=TRUE;
							END_IF;
							IF (iSelectedAxis = 4) OR (T_Visu.T_PlcParam.dwActualPage = 30) THEN
								xSlowFastJogToolFeeder:=TRUE;
							END_IF;
							IF (iSelectedAxis = 5) AND (T_Visu.T_PlcParam.dwActualPage <> 30) THEN
								xSlowFastJogGrindFeeder:=TRUE;
							END_IF;
							tTimeOutAction:=T#3s;
					(* Switch ToolRotation Master Slave *)
					321:		IF xMicroRodActive THEN
								(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
								T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
								T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearFactor:=(	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																								(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																								T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearRatio)) * -1.0;

								(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
								T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
								T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																								(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																								T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio);
							END_IF;
							IF NOT(xMicroRodActive) THEN
								(* ToolRight --> Slave of ToolRight by MicroWire *)
								T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
								T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																							(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearRatio /
																							T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;

								(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
								T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
								T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																								(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																								T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;
							END_IF;
							xSwitchMasterSlave:=TRUE;
							tTimeOutAction:=T#3s;
					(* Power axis *)
					322:		xToggleAxisPower:=TRUE;
							tTimeOutAction:=T#3s;
					(* Reset axis *)
					323:		xResetAxis:=TRUE;
							tTimeOutAction:=T#3s;
					(* Reference axis *)
					324:		xReferenceAxis:=TRUE;
							tTimeOutAction:=T#200s;
					(* Teach axis Position *)
					325:		xTeachPosition:=TRUE;
							tTimeOutAction:=T#6s;
					(* Calculate the position between the RefIndex and the RefSensor *)
					326:		xCalcAngleRefIndex:=TRUE;
							tTimeOutAction:=T#200s;
					END_CASE;
			(* Station Function *)
			401..499:	xActivateStationFunction:=TRUE;
					iTmpStationFunctionNr:=T_Visu.T_CtrleAction.iFunction - 400;	(* Select Function Number 1 - 99 *)
					IF (iTmpStationFunctionNr = 20) THEN tTimeOutAction:=T#200s; ELSE tTimeOutAction:=T#3s;END_IF;
			(* Cylinder Function *)
			501..599:	(* set pointer, default pointer CylToolTension *)
					(* 1=CylToolTension, 2=CylToolLeftActive, 3=CylToolRightActive, 4=CylToolCenter,5=CylToolPrismaLeftActive, 6=CylToolPrismaRightActive *)
					ptrCylAction:=ADR(T_Station.THardware.TCylToolTension);
					iSelectedCylinder:=1;
					IF (T_Visu.T_PlcParam.dwActualPage = 230) THEN
						IF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1 = 1) THEN
							ptrCylAction:=ADR(T_Station.THardware.TCylToolTension);
							iSelectedCylinder:=1;
						ELSIF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1 = 2) THEN
							ptrCylAction:=ADR(T_Station.THardware.TCylToolLeftActive);
							iSelectedCylinder:=2;
						ELSIF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1 = 3) THEN
							ptrCylAction:=ADR(T_Station.THardware.TCylToolRightActive);
							iSelectedCylinder:=3;
						ELSIF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1 = 4) THEN
							ptrCylAction:=ADR(T_Station.THardware.TCylToolCenterActive);
							iSelectedCylinder:=4;
						ELSIF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1 = 5) THEN
							ptrCylAction:=ADR(T_Station.THardware.TCylToolPrismaLeftActive);
							iSelectedCylinder:=5;
						ELSIF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectCylinder_Sonder1 = 6) THEN
							ptrCylAction:=ADR(T_Station.THardware.TCylToolPrismaRightActive);
							iSelectedCylinder:=6;
						ELSE
							ptrCylAction:=ADR(T_Station.THardware.TCylToolTension);
							iSelectedCylinder:=1;
						END_IF;
					END_IF;
					(*Set pointer -->selection by the extern buttons*)
					IF (T_Visu.T_CtrleAction.iFunction = 510) THEN ptrCylAction:=ADR(T_Station.THardware.TCylToolTension);iSelectedCylinder:=1; END_IF;
					IF (T_Visu.T_CtrleAction.iFunction = 511) THEN ptrCylAction:=ADR(T_Station.THardware.TCylToolLeftActive);iSelectedCylinder:=2; END_IF;
					IF (T_Visu.T_CtrleAction.iFunction = 512) THEN ptrCylAction:=ADR(T_Station.THardware.TCylToolRightActive);iSelectedCylinder:=3; END_IF;
					IF (T_Visu.T_CtrleAction.iFunction = 513) THEN ptrCylAction:=ADR(T_Station.THardware.TCylToolCenterActive);iSelectedCylinder:=4; END_IF;
					IF (T_Visu.T_CtrleAction.iFunction = 514) THEN ptrCylAction:=ADR(T_Station.THardware.TCylToolPrismaLeftActive);iSelectedCylinder:=5; END_IF;
					IF (T_Visu.T_CtrleAction.iFunction = 515) THEN ptrCylAction:=ADR(T_Station.THardware.TCylToolPrismaRightActive);iSelectedCylinder:=6; END_IF;
					IF ((T_Visu.T_CtrleAction.iFunction >= 510) AND (T_Visu.T_CtrleAction.iFunction <= 515)) THEN
						T_Visu.T_CtrleAction.iFunction:=501;
					 END_IF;
					CASE T_Visu.T_CtrleAction.iFunction OF
					501:		xToggleCylinderState:=TRUE;
							IF ( iSelectedCylinder = 1) THEN
								IF (T_Visu.T_PlcParam.dwActualPage = 220) THEN
									ptrCylAction^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce;
								ELSE
									IF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectToolTensionForce < 2) THEN
										(* Process work force *)
										ptrCylAction^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolTensionProcess;
									END_IF;
									IF (T_Visu.ptrT_ExchgParam^.T_Cylinder.iSelectToolTensionForce > 1) THEN
										(* Setup (Cylinder Force) Force *)
										ptrCylAction^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_NovRam.T_Data.T_Standard.T_Cyl_ToolTension.rForce;
									END_IF;
								END_IF;
							END_IF;
							tTimeOutAction:=T#2s;
					(* ToolTens force + *)
					502:		xToolTensForceAdd:=TRUE;
							tTimeOutAction:=T#2s;
					(* ToolTens force ++ *)
					503:		xToolTensForceAddMore:=TRUE;
							tTimeOutAction:=T#2s;
					(* ToolTens force - *)
					504:		xToolTensForceSub:=TRUE;
							tTimeOutAction:=T#2s;
					(* ToolTens force -- *)
					505:		xToolTensForceSubMore:=TRUE;
							tTimeOutAction:=T#2s;
					(* DO NOT USE FUNCTION 510,511,512,513,514,515 *)
					END_CASE;
			(* All process station *)
			601..699:	T_Process.iFunctNr:=T_Visu.T_CtrleAction.iFunction - 600;
					xActionProcStation:=TRUE;
					tTimeOutAction:=T#2s;
			(* All process machine *)
			701..799:	T_Process.iFunctNr:=T_Visu.T_CtrleAction.iFunction - 700;
					xActionProcMachine:=TRUE;
					(* Ref timeout 120s *)
					IF T_Visu.T_CtrleAction.iFunction = 710 THEN  tTimeOutAction:=T#120s; ELSE tTimeOutAction:=T#0.5s; END_IF
			(* Stop process *)
			800:		xStopProcess:=TRUE;
					tTimeOutAction:=T#30s;
			(* Stop cycle *)
			801:		xAction_StopCycle:=TRUE;
					tTimeOutAction:=T#30s;
			(* Copy profile to process value *)
			1001:	xAction_CopyProfileToProcess:=TRUE;
					tTimeOutAction:=T#10s;
			(* Load profile to process image *)
			1002:	xAction_LoadProfileToProcessImage:=TRUE;
					tTimeOutAction:=T#5s;
			(* Save profile to File *)
			1003:	xAction_SaveProfileToFile:=TRUE;
					tTimeOutAction:=T#5s;
			(* Delete Profile *)
			1004:	xActionDeleteProfile:=TRUE;
					tTimeOutAction:=T#5s;
			(* Save NovRAM with confirmation *)
			1005:	xAction_SaveNovRAM:=TRUE;
					tTimeOutAction:=T#6s;
			(* Save NovRAM without confirmation *)
			1006:	xAction_SaveNovRAMWithoutConfirm:=TRUE;
					tTimeOutAction:=T#10s;
			(* change page *)
			10001..10999:	xNavPanelChangePage:=TRUE;
						tTimeOutAction:=T#3s;
		END_CASE;
		(* Init. variable *)
		T_Visu.T_CtrleAction.xDone:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		iStepActionNovRam:=1;
		xStepActionDone:=FALSE;
		IF tTimeOutAction <> T#0s THEN TimerAction(IN:=FALSE); END_IF
		(* exit FB *)
		RETURN;
	END_IF;

(* Timer action *)
	IF tTimeOutAction <> T#0s THEN TimerAction(IN:=TRUE,PT:=tTimeOutAction); END_IF
	RisingEdgeTimeOut(CLK:=TimerAction.Q);
	IF RisingEdgeTimeOut.Q AND NOT(T_Visu.T_CtrleAction.xDone) AND NOT(T_Visu.T_CtrleAction.xErr) THEN
	(* Timeout action activ *)
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=16#0;
		(* call confirmation message *)
		T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=102;
(*			:=iFctReturnConfMessage(iNumAction:=-1);*)
		(* exit FB, do not continue the execution of action! *)
		RETURN;
	END_IF
(************************************************************************************************************************************************************************)
(***************                                          end  of the management for call a function of the visualisation interface                                           ********************)
(************************************************************************************************************************************************************************)

(************************************************************************************************************************************************************************)
(***************                                                   start of the checking of the activation of an visualisation action                                                   ********************)
(************************************************************************************************************************************************************************)
(* check if Action is Acitve and if the power supply is on, otherwise block the action *)
	xTmp:=	xStopAxis OR xMoveRelPosition OR xMoveAbsPosition OR xMoveContinousVel OR xSwitchMasterSlave OR xToggleAxisPower OR xResetAxis OR xReferenceAxis OR xTeachPosition;
	xTmp:=	xTmp OR xToggleCylinderState OR xToolTensForceAdd OR xToolTensForceAddMore OR xToolTensForceSub OR xToolTensForceSubMore;
	xTmp:=	xTmp OR xToolFeederMoveStartPos OR xToggleAllAxisPower OR xCalcAngleRefIndex OR xToolFeederMoveLoadPos;
	xTmp:=	xTmp OR xActivateStationFunction OR xActionProcStation OR xActionProcMachine OR xStopProcess;
	xTmp:=	xTmp OR xOverlayGrindFeedSetPlung OR xOverlayMeasureToolDia OR xFctCorrectionToolDiameter OR xAction_LoadProfileToProcessImage;
	xTmp:=	xTmp OR ((T_Visu.T_PlcParam.dwActualPage = 430) AND xAction_SaveNovRAM);
	IF xTmp THEN
		IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
			xStopAxis:=xMoveRelPosition:=xMoveAbsPosition:=xMoveContinousVel:=xSwitchMasterSlave:=xToggleAxisPower:=xResetAxis:=xReferenceAxis:=xTeachPosition:=FALSE;
			xToggleCylinderState:=xToolTensForceAdd:=xToolTensForceAddMore:=xToolTensForceSub:=xToolTensForceSubMore:=FALSE;
			xToolFeederMoveStartPos:=xToggleAllAxisPower:=xCalcAngleRefIndex:=xToolFeederMoveLoadPos:= FALSE;
			xActivateStationFunction:=xActionProcStation:=xActionProcMachine:=xStopProcess:=FALSE;
			xOverlayGrindFeedSetPlung:=xOverlayMeasureToolDia:=xFctCorrectionToolDiameter:=xAction_LoadProfileToProcessImage:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
			xAction_SaveNovRAM:=FALSE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			tTimeOutAction:=T#0s;
			TimerAction(IN:=FALSE);
			(* Display Message --> Switch first the energy supply ON *)
			T_ExchgParam.T_Visu.T_Message.iState:=120;
			xBlockConfirmMessage:=TRUE;
			TONTimeWaitMsg(IN:=FALSE);
		END_IF;
	END_IF;
	IF (T_ExchgParam.T_Visu.T_Message.iState = 120) THEN
		TONTimeWaitMsg(IN:=TRUE,PT:=T#3s);
		IF TONTimeWaitMsg.Q THEN
			T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Deactivate again the message *)
		END_IF;
	ELSE
		TONTimeWaitMsg(IN:=FALSE);
	END_IF;

(* check if an error is active, otherwise block the action *)
	IF (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
		xTmp:=	xStopAxis OR xMoveRelPosition OR xMoveAbsPosition OR xMoveContinousVel OR xSwitchMasterSlave OR xToggleAxisPower OR xResetAxis OR xReferenceAxis OR xTeachPosition;
		xTmp:=	xTmp OR xToggleCylinderState OR xToolTensForceAdd OR xToolTensForceAddMore OR xToolTensForceSub OR xToolTensForceSubMore;
		xTmp:=	xTmp OR xToolFeederMoveStartPos OR xToggleAllAxisPower OR xCalcAngleRefIndex OR xToolFeederMoveLoadPos;
		xTmp:=	xTmp OR xActivateStationFunction OR xActionProcStation OR xActionProcMachine OR xStopProcess;
		xTmp:=	xTmp OR xOverlayGrindFeedSetPlung OR xOverlayMeasureToolDia OR xFctCorrectionToolDiameter OR xAction_LoadProfileToProcessImage;
		xTmp:=	xTmp OR ((T_Visu.T_PlcParam.dwActualPage = 430) AND xAction_SaveNovRAM);
		IF xTmp THEN
			xStopAxis:=xMoveRelPosition:=xMoveAbsPosition:=xMoveContinousVel:=xSwitchMasterSlave:=xToggleAxisPower:=xResetAxis:=xReferenceAxis:=xTeachPosition:=FALSE;
			xToggleCylinderState:=xToolTensForceAdd:=xToolTensForceAddMore:=xToolTensForceSub:=xToolTensForceSubMore:=FALSE;
			xToolFeederMoveStartPos:=xToggleAllAxisPower:=xCalcAngleRefIndex:=xToolFeederMoveLoadPos:=FALSE;
			xActivateStationFunction:=xActionProcStation:=xActionProcMachine:=xStopProcess:=FALSE;
			xOverlayGrindFeedSetPlung:=xOverlayMeasureToolDia:=xFctCorrectionToolDiameter:=xAction_LoadProfileToProcessImage:=FALSE;
			xAction_SaveNovRAM:=FALSE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			tTimeOutAction:=T#0s;
			TimerAction(IN:=FALSE);
		END_IF;
	END_IF;
(************************************************************************************************************************************************************************)
(***************                                                   end of the checking of the activation of an visualisation action                                                   ********************)
(************************************************************************************************************************************************************************)

(************************************************************************************************************************************************************************)
(***************                                             start for the section for defined function of the visualisation interface                                               ********************)
(************************************************************************************************************************************************************************)
(* Action set parameter page *)
	IF xSetParameterPage THEN
		(* set parameter page *)
		CASE iStepAction OF
		(* check visu *)
		1:	IF (T_Visu.T_PlcParam.dwActualPage = 140) OR (T_Visu.T_PlcParam.dwActualPage = 150) THEN
				(* For this page. for select the parameter list, it need the system level *)
				IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=36;	(* Display Message --> This parameter can be change only with system level *)
						T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=WORD_TO_INT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft) AND 16#FFEF);
				END_IF;
			END_IF;
			IF (T_ExchgParam.T_Visu.T_Message.iState <> 36) THEN
				xTmp:=	T_Visu.T_CtrleVisu.xDone
						AND NOT(T_Visu.T_CtrleVisu.xExecute)
						AND NOT(T_Visu.T_CtrleVisu.xErr);
				IF xTmp THEN
					(* next Step *)
					iStepAction :=10;
					xStepActionDone:=FALSE;
				(* activ error *)
				ELSE iStepAction:=95; END_IF
			ELSE
				iStepAction:=90;
			END_IF;
		(* Set parameter page *)
		10:	T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi1:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=TRUE;
			CASE T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer OF
				1:	T_Visu.T_PlcParam.dwSetNewPage:=170;
					T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=iFctGetEditParaList(	dwActualPage:=wSpecialLayerGeneralActivPage,
																				xMicroRodActive:=xMicroRodActive,
																				iSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList,
																				iSelectParaListTeachRot:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot);
					IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 140) OR (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 150) THEN
						(* For this page. for select the parameter list, it need the system level *)
						IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
							T_ExchgParam.T_Visu.T_Message.iState:=36;	(* Display Message --> This parameter can be change only with system level *)
								T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=WORD_TO_INT(INT_TO_WORD(T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft) AND 16#FFEF);
								T_Visu.T_PlcParam.dwSetNewPage:=wSpecialLayerGeneralActivPage;
						END_IF;
					END_IF;
					IF (T_ExchgParam.T_Visu.T_Message.iState <> 36) THEN
						(* 09.12.2010 KFS:	{	*)
						IF (T_ExchgParam.T_Visu.T_Level.iActLevel =2) THEN
						(* 09.12.2010 KFS:	}	*)
							IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 110) OR (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 111) THEN
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
							END_IF;
							IF ((T_Visu.ptrT_ExchgParam^.T_Config.iEditParam >= 120) AND (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam <= 129)) THEN
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 130) OR (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 131) THEN
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi1:=FALSE;
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=TRUE;
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
								(*  Set Loaded Profil Data from the read file*)
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_AutoGeometryPara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_AutoGroovePara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_CalibrationPara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ProcessPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_ProcessPara;
								T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_GeometryPara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_PrismPara;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 150) THEN
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=TRUE;
							END_IF;
						(* 09.12.2010 KFS:	{	*)
						ELSE
							IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 110) OR (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 111) THEN
								IF  (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 111) THEN
									 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 112;
								END_IF;
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
							END_IF;
							IF ((T_Visu.ptrT_ExchgParam^.T_Config.iEditParam >= 120) AND (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam <= 129)) THEN
								IF  (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 121) THEN
									 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 126;
								ELSIF ( T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 123) THEN
									 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 127;
								ELSIF ( T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 125) THEN
									 T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:= 128;
								END_IF;
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 130) OR (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 131) THEN
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi1:=FALSE;
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=TRUE;
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=FALSE;
								(*  Set Loaded Profil Data from the read file*)
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_AutoGeometryPara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_AutoGroovePara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_CalibrationPara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ProcessPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_ProcessPara;
								T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_GeometryPara;
								T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara:=T_NovRAM.T_Data.T_ProcessImageLoadData.T_PrismPara;
							END_IF;
							IF (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 150) THEN
								T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=TRUE;
							END_IF;
						END_IF;
						(* 09.12.2010 KFS:	}	*)
					END_IF;
				2:	T_Visu.T_PlcParam.dwSetNewPage:=270;
					T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=iFctGetEditParaList(	dwActualPage:=wSpecialLayerToolRotActivPage,
																				xMicroRodActive:=xMicroRodActive,
																				iSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList,
																				iSelectParaListTeachRot:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot);
				3:	T_Visu.T_PlcParam.dwSetNewPage:=370;
					T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=iFctGetEditParaList(	dwActualPage:=wSpecialLayerWireFeedActivPage,
																				xMicroRodActive:=xMicroRodActive,
																				iSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList,
																				iSelectParaListTeachRot:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot);
				4:	T_Visu.T_PlcParam.dwSetNewPage:=470;
					T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=iFctGetEditParaList(	dwActualPage:=wSpecialLayerGrindAxisActivPage,
																				xMicroRodActive:=xMicroRodActive,
																				iSelectParaList:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaList,
																				iSelectParaListTeachRot:=T_Visu.ptrT_ExchgParam^.T_Config.iSelectParaListTeachRot);
			END_CASE;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			(* activ step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait for changing page *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				(* confirm step done *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Visu.T_CtrleVisu.xDone THEN
				(* activ next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
				IF T_Visu.T_CtrleVisu.xErr THEN
				(* activ next error *)
					iStepAction:=99;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetParameterPage:=FALSE;
		(* override done *)
		91:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetParameterPage:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetParameterPage:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xSetParameterPage:=FALSE;
		END_CASE
	END_IF

(* Action change page from navigation panel *)
	IF xNavPanelChangePage OR xBtPanelLeftChangePage OR xNextPageVertical THEN
		(* Step change page from navigation panel *)
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	T_Visu.T_CtrleVisu.xDone
					AND NOT(T_Visu.T_CtrleVisu.xExecute)
					AND NOT(T_Visu.T_CtrleVisu.xErr);
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
				xStepActionDone:=FALSE;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		(* activ change page *)
		10:	T_Visu.T_CtrleVisu.xExecute:=TRUE;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.ptrT_ExchgParam^.T_Config.iEditParam:=0;
			IF xNavPanelChangePage THEN
				T_Visu.T_PlcParam.dwSetNewPage:=INT_TO_DWORD(T_Visu.T_CtrleAction.iFunction - 10000);
				CASE T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer OF
					0:	IF awNormalLayerActivPage[wTmpNormalLayerActivTask] <> 0 AND awNormalLayerActivPage[wTmpNormalLayerActivTask] <> T_Visu.T_PlcParam.dwSetNewPage THEN
							T_Visu.T_PlcParam.dwSetNewPage:=awNormalLayerActivPage[wTmpNormalLayerActivTask];
						END_IF;
					1:	IF awSpecialLayerGeneralActivPage[wTmpSpecialLayerGeneralActivTask] <> 0 AND awSpecialLayerGeneralActivPage[wTmpSpecialLayerGeneralActivTask] <> T_Visu.T_PlcParam.dwSetNewPage THEN
							T_Visu.T_PlcParam.dwSetNewPage:=awSpecialLayerGeneralActivPage[wTmpSpecialLayerGeneralActivTask];
						END_IF;
					2:	IF awSpecialLayerToolRotActivPage[wTmpSpecialLayerToolRotActivTask] <> 0 AND awSpecialLayerToolRotActivPage[wTmpSpecialLayerToolRotActivTask] <> T_Visu.T_PlcParam.dwSetNewPage THEN
							T_Visu.T_PlcParam.dwSetNewPage:=awSpecialLayerToolRotActivPage[wTmpSpecialLayerToolRotActivTask];
						END_IF;
					3:	IF awSpecialLayerWireFeedActivPage[wTmpSpecialLayerWireFeedActivTask] <> 0 AND awSpecialLayerWireFeedActivPage[wTmpSpecialLayerWireFeedActivTask] <> T_Visu.T_PlcParam.dwSetNewPage THEN
							T_Visu.T_PlcParam.dwSetNewPage:=awSpecialLayerWireFeedActivPage[wTmpSpecialLayerWireFeedActivTask];
						END_IF;
					4:	IF awSpecialLayerGrindAxisActivPage[wTmpSpecialLayerGrindAxisActivTask] <> 0 AND awSpecialLayerGrindAxisActivPage[wTmpSpecialLayerGrindAxisActivTask] <> T_Visu.T_PlcParam.dwSetNewPage THEN
							T_Visu.T_PlcParam.dwSetNewPage:=awSpecialLayerGrindAxisActivPage[wTmpSpecialLayerGrindAxisActivTask];
						END_IF;
				END_CASE;
			END_IF;
			IF xBtPanelLeftChangePage THEN
				T_Visu.T_PlcParam.dwSetNewPage:=dwSetNewPage;
				T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_Config.xBlockParaListNavi1:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_Config.xBlockProfilList:=TRUE;
			END_IF;
			IF xNextPageVertical THEN
				IF (T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage + 1].iIndexConfigPage <> 0) THEN
					T_Visu.T_PlcParam.dwSetNewPage:=T_Visu.T_PlcParam.dwActualPage + 1;
				ELSE
					FOR ii:=1 TO 9 DO
						IF (T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage - 1].iIndexConfigPage <> 0) THEN
							T_Visu.T_PlcParam.dwActualPage:=T_Visu.T_PlcParam.dwActualPage - 1;
						ELSE
							T_Visu.T_PlcParam.dwSetNewPage:=T_Visu.T_PlcParam.dwActualPage;
							EXIT;
						END_IF;
					END_FOR;
				END_IF;
				CASE T_Visu.ptrT_ExchgParam^.T_Visu.bActivSpecialLayer OF
					0:	awNormalLayerActivPage[wTmpNormalLayerActivTask]:=DWORD_TO_WORD(T_Visu.T_PlcParam.dwSetNewPage);
					1:	awSpecialLayerGeneralActivPage[wTmpSpecialLayerGeneralActivTask]:=DWORD_TO_WORD(T_Visu.T_PlcParam.dwSetNewPage);
					2:	awSpecialLayerToolRotActivPage[wTmpSpecialLayerToolRotActivTask]:=DWORD_TO_WORD(T_Visu.T_PlcParam.dwSetNewPage);
					3:	awSpecialLayerWireFeedActivPage[wTmpSpecialLayerWireFeedActivTask]:=DWORD_TO_WORD(T_Visu.T_PlcParam.dwSetNewPage);
					4:	awSpecialLayerGrindAxisActivPage[wTmpSpecialLayerGrindAxisActivTask]:=DWORD_TO_WORD(T_Visu.T_PlcParam.dwSetNewPage);
				END_CASE;
			END_IF;
			(* next Step *)
			iStepAction :=20;
			xStepActionDone:=FALSE;
		(* wait  confirmation *)
		20:	IF NOT(xStepActionDone) THEN
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Visu.T_CtrleVisu.xDone THEN
				(* next Step *)
					iStepAction :=90;
					xStepActionDone:=FALSE;
				ELSE	IF T_Visu.T_CtrleVisu.xErr THEN
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xNavPanelChangePage:=FALSE;
			xBtPanelLeftChangePage:=FALSE;
			xNextPageVertical:=FALSE;
		(* visu not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xNavPanelChangePage:=FALSE;
			xBtPanelLeftChangePage:=FALSE;
			xNextPageVertical:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xNavPanelChangePage:=FALSE;
			xBtPanelLeftChangePage:=FALSE;
			xNextPageVertical:=FALSE;
		END_CASE
	END_IF

(* Action reset error station *)
	IF xResetError THEN
		(* FB clear error station *)
		fbQvisClearError(	xExecute:=xResetError,
						iError:=T_Visu.T_CtrleAction.iFunction,
						T_Message:=T_ExchgParam.T_Visu.T_Message,
						T_Station:=T_Station,
						T_Process:=T_Process,
						T_NovRAM:=T_NovRAM,
						T_Profile:=T_Profile,
						T_HDD:=T_HDD,
						xDone=>T_Visu.T_CtrleAction.xDone,
						xNotReady=>T_Visu.T_CtrleAction.xNotReady,
						xErr=>T_Visu.T_CtrleAction.xErr,
						udiErrorID=>T_Visu.T_CtrleAction.udiErrorID);
		IF T_Visu.T_CtrleAction.xDone OR T_Visu.T_CtrleAction.xNotReady OR T_Visu.T_CtrleAction.xErr THEN
			xResetError:=FALSE;
			fbQvisClearError(	xExecute:=xResetError,
							iError:=T_Visu.T_CtrleAction.iFunction,
							T_Message:=T_ExchgParam.T_Visu.T_Message,
							T_Station:=T_Station,
							T_Process:=T_Process,
							T_NovRAM:=T_NovRAM,
							T_Profile:=T_Profile,
							T_HDD:=T_HDD);
		END_IF
	END_IF

(* Action Delete Errorlist for Machine and Station *)
	IF xDeleteErrorList THEN
		(* Step saving NovRAM *)
		CASE iStepAction OF
		(* check NovRAM *)
		1:	xTmp:=	T_NovRAM.T_Ctrle.xDone
					AND NOT(T_NovRAM.T_Ctrle.xExecute)
					AND NOT(T_NovRAM.T_Ctrle.xErr);
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	(* For delete the error, it need the system level *)
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=42;	(* Display Message --> The error list may delete only in system level ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=108;	(* Confirm saving action <Enter>, or escape <Esc> ? *)
			(* next Step *)
			iStepAction :=20;
		(* waiting for saving confirmation key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
			(* Display message *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=13;	(* Start saving *)
				(* next step *)
				iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF
				(* An other message has been displayed, stop saving action *)
				IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>108 THEN iStepAction:=90; END_IF
			END_IF
		30:	FOR ii:=1 TO 20 DO
				T_NovRAM.T_Data.T_ErrorNrList.adiErrorListMachine[ii]:=0;
				T_NovRAM.T_Data.T_ErrorNrList.asErrorTimeStampMachine[ii]:='';
			END_FOR;
			(* activ save *)
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			(* next Step *)
			iStepAction :=40;
			xStepActionDone:=FALSE;
		(* wait save confirmation *)
		40:	IF NOT(xStepActionDone) THEN
				T_NovRAM.T_Ctrle.xExecute:=FALSE;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_NovRAM.T_Ctrle.xDone THEN
				(* next Step *)
					iStepAction :=90;
					xStepActionDone:=FALSE;
					xUpdateErrorList:=TRUE;
				ELSE	IF T_NovRAM.T_Ctrle.xErr THEN
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* no code, waiting timeout *)
		89:	IF TimerAction.Q THEN iStepAction:=90; END_IF
		(* save done *)
		90:	IF (T_ExchgParam.T_Visu.T_Message.iState <> 42) THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			END_IF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xDeleteErrorList:=FALSE;
		(* NovRAM not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xDeleteErrorList:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xDeleteErrorList:=FALSE;
		END_CASE;
	END_IF;

(* Open Overlay for input measured tool diameter *)
	IF xOverlayMeasureToolDia THEN
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xReady
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		10:	(* Open Overlay *)
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.rInputMeasToolDiameter:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolDiameter;
			(* next Step *)
			iStepAction :=20;
		20:	IF T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				(* next Step *)
				iStepAction :=30;
			END_IF;
			IF T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				(* next Step *)
				iStepAction :=90;
			END_IF;
			IF T_Visu.T_CtrleAction.xDone THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
				xOverlayMeasureToolDia:=FALSE;
			END_IF;
		(* activ function axis *)
		30:	T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=	T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition +
																		(T_Visu.ptrT_ExchgParam^.T_FunctionCommon.rInputMeasToolDiameter -
																		T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolDiameter);
			IF (T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition < T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin) OR
			     (T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition > (T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax + T_NovRAM.T_Data.T_Standard.T_TeachINGrindFeeder.rOffsetSWPosEndSwitch)) THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=123;	(* Out of Range, GrindFeeder position not settled! *)
				iStepAction:=50;
			ELSE
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=11;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				(* next step *)
				iStepAction:=50;
			END_IF;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		50:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOverlayMeasureToolDia:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xOverlayMeasureToolDia:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			xOverlayMeasureToolDia:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMeasureInput:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
		END_CASE
	END_IF;

(* Open Overlay for input the correction of the position of the GrindFeeder *)
	IF xOverlayGrindFeedSetPlung THEN
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xReady
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		10:	(* Open Overlay *)
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.rInputGrindPlunge:=T_NovRAM.T_Data.T_ProcessImageData.T_CalibrationPara.rPlungeLengthGrindFeedCalib;
			(* next Step *)
			iStepAction :=20;
		20:	IF T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				(* next Step *)
				iStepAction :=30;
			END_IF;
			IF T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				(* next Step *)
				iStepAction :=90;
			END_IF;
			IF T_Visu.T_CtrleAction.xDone THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xSaveButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xExitButton:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
				xOverlayGrindFeedSetPlung:=FALSE;
			END_IF;
		(* activ function axis *)
		30:	T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=	T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition +
																		T_Visu.ptrT_ExchgParam^.T_FunctionCommon.rInputGrindPlunge;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=11;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=50;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		50:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOverlayGrindFeedSetPlung:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xOverlayGrindFeedSetPlung:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			xOverlayGrindFeedSetPlung:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlaySetGrindPlunge:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xHideProgressbar:=FALSE;
		END_CASE
	END_IF;

(* Plunge On/Off or Displace On/Off *)
	IF xPlungeActivation OR xDisplaceActivation THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	(* Open Overlay *)
			IF xPlungeActivation THEN
				IF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.xPlungeActivationCalib:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.xPlungeActivationCalib);
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xPlungeActivationGeometry:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xPlungeActivationGeometry);
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xPlungeActivationGroove:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xPlungeActivationGroove);
				END_IF;
			END_IF;
			IF xDisplaceActivation THEN
				IF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.xDisplaceActivationCalib:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.xDisplaceActivationCalib);
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xDisplaceActivationGeometry:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xDisplaceActivationGeometry);
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xDisplaceActivationGroove:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xDisplaceActivationGroove);
				END_IF;
			END_IF;
			(* next Step *)
			iStepAction :=30;
		(* active saving data NovRAM *)
		30:	xAction_SaveNovRAM:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=40;
		(* waiting confirm saving NovRAM action *)
		40:	IF NOT xAction_SaveNovRAM THEN
				xCalcAgainProcTime:=TRUE;
				iStepAction:=90;
			END_IF;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xPlungeActivation:=FALSE;
			xDisplaceActivation:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xPlungeActivation:=FALSE;
			xDisplaceActivation:=FALSE;
		END_CASE
	END_IF;

(* AutoGroove-->Block GrindFeeder On/Off *)
	IF xBlockGrindFeederActivation THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	(* Open Overlay *)
			T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xBlockGrindFeeder:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara.xBlockGrindFeeder);
			(* next Step *)
			iStepAction :=30;
		(* active saving data NovRAM *)
		30:	xAction_SaveNovRAM:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=40;
		(* waiting confirm saving NovRAM action *)
		40:	IF NOT xAction_SaveNovRAM THEN
				iStepAction:=90;
			END_IF;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xBlockGrindFeederActivation:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xBlockGrindFeederActivation:=FALSE;
		END_CASE
	END_IF;

(* AutoGroove-->ToolFeeder move to StartPos *)
	IF xToolFeederMoveStartPos OR xToolFeederMoveLoadPos THEN
		(* Step move abs position *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xReady
						AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving
						AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower
						AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute)
						AND ((T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xRef AND xMicroRodActive) OR NOT(xMicroRodActive));
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				ELSE
					IF NOT T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xRef THEN
					(* Display message, axis not referenced *)
						tTimeOutAction:=TimerAction.ET+T#2s;
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=18;
						(* Action has been cancelled *)
						iStepAction:=89;
					END_IF
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	tTimeOutAction:=T#999s;
			bStateMachine:=2;
			xSetStateMachine:=TRUE;
			IF xMicroRodActive THEN
				iStepAction:=20;		(* Move Absolut *)
			END_IF;
			IF NOT(xMicroRodActive) THEN
				iStepAction:=35;		(* Move Relativ *)
			END_IF;
			(* init. acc/dec/jerk *)
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRam.T_Data.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRam.T_Data.T_Standard.T_TeachINToolFeeder.rDeceleration;
			(*
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_Station.THardware.TAxisToolFeeder.T_Config_ObjFileValue.lrAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_Station.THardware.TAxisToolFeeder.T_Config_ObjFileValue.lrDecceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrJerk:=T_Station.THardware.TAxisToolFeeder.T_Config_ObjFileValue.lrJerk;
			*)
		(* activ function axis move absolut *)
		20:	IF xToolFeederMoveStartPos THEN
				IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=	T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
				END_IF;
				IF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
					IF T_NovRam.T_Data.T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove AND T_NovRam.T_Data.T_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder THEN
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=	T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto +
																				T_NovRam.T_Data.T_ProcessImageData.T_AutoGroovePara.rPlungeLengthToolFeedGroove;
					ELSE
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=	T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rStartPosToolFeedAuto;
					END_IF;
				END_IF;
				IF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=	T_NovRam.T_Data.T_ProcessImageData.T_CalibrationPara.rStartPosToolFeedCalib;
				END_IF;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			END_IF;
			IF xToolFeederMoveLoadPos THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=	T_NovRam.T_Data.T_Standard.T_AxisPosition.rLoadPosToolFeedAuto;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRam.T_Data.T_Standard.T_TeachINToolFeeder.rPositionSpeed;
			END_IF;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=7;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=40;
			xStepActionDone:=FALSE;
		(* activ function axis move relativ *)
		35:	IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDistance:=0;
			END_IF;
			IF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
				IF T_NovRam.T_Data.T_ProcessImageData.T_AutoGroovePara.xPlungeActivationGroove (*AND T_NovRam.T_Data.T_ProcessImageData.T_AutoGroovePara.xBlockGrindFeeder*) THEN
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDistance:=T_NovRam.T_Data.T_ProcessImageData.T_AutoGroovePara.rPlungeLengthToolFeedGroove;
				ELSE
					(*T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDistance:=0;*)
					iStepAction:=95;
					RETURN;
				END_IF;
			END_IF;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rSpeedStartPosToolFeedProcess;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=8;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=40;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		40:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
				(* Display message, 'Start moving' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=26;
			ELSE
				IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					bStateMachine:=1;
					xSetStateMachine:=TRUE;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* waiting timeout *)
		89: IF TimerAction.Q THEN iStepAction:=90; END_IF
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xToolFeederMoveStartPos:=xToolFeederMoveLoadPos:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xToolFeederMoveStartPos:=xToolFeederMoveLoadPos:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			xToolFeederMoveStartPos:=xToolFeederMoveLoadPos:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		END_CASE
	END_IF
(*08.07.2014: KFS	{	*)
(* WarmUp On/Off*)
	IF xWarmUp THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	(* Open Overlay *)
			IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xWarmUp:=NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xWarmUp);
			END_IF;
			(* next Step *)
			iStepAction :=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xWarmUp:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xWarmUp:=FALSE;
		END_CASE
	END_IF;
(*08.07.2014: KFS	}	*)

(* AutoGeometry and AutoGroove-->Switch On/Off all Axis Power *)
	IF xToggleAllAxisPower THEN
		(* Step toggle Axis power *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute);
				xTmp:=	xTmp AND ((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute) AND xMicroRodActive) OR NOT(xMicroRodActive)) ;
				xTmp:=	xTmp AND T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisToolRight.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute);
				xTmp:=	xTmp AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute);
				xTmp:=	xTmp AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	bStateMachine:=2;
			xSetStateMachine:=TRUE;
			xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xPower AND
					((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xPower AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.xPower AND
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower AND
					T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xPower;
			IF xTmp THEN
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.iFunction:=4;
				IF xMicroRodActive THEN
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=4;
				END_IF;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=4;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=4;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=4;
			ELSE
				IF NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xPower) THEN
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.iFunction:=3;
				END_IF;
				IF xMicroRodActive THEN
					IF NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xPower) THEN
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=3;
					END_IF;
				END_IF;
				IF NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xPower) THEN
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=3;
				END_IF;
				IF NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower) THEN
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=3;
				END_IF;
				IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xPower) THEN
					T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=3;
				END_IF;
			END_IF;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=xMicroRodActive;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute:=FALSE;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=FALSE;
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=FALSE;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=FALSE;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone AND
						((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone;
				IF xTmp THEN
				(* confirm action next step *)
					bStateMachine:=1;
					xSetStateMachine:=TRUE;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr OR
							(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
							T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr OR
							T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr OR
							T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr;
					IF xTmp THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xToggleAllAxisPower:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xToggleAllAxisPower:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			diErrorNr:=0;
			IF T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr THEN
				diErrorNr:=1000000 + T_Station.THardware.TAxisToolLeft.T_CtrleSingle.udiErrorID;
			END_IF;
			IF xMicroRodActive THEN
				IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr THEN
					diErrorNr:=2000000 + T_Station.THardware.TAxisToolCenter.T_CtrleSingle.udiErrorID;
				END_IF;
			END_IF;
			IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr THEN
				diErrorNr:=3000000 + T_Station.THardware.TAxisToolRight.T_CtrleSingle.udiErrorID;
			END_IF;
			IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
				diErrorNr:=4000000 + T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.udiErrorID;
			END_IF;
			IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
				diErrorNr:=5000000 + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr;
			IF xMicroRodActive THEN
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=1;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr;
			END_IF;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr;
			xToggleAllAxisPower:=FALSE;
		END_CASE
	END_IF

(* Correction Tool Diameter +,++,-,-- *)
	IF xCorrectionToolDiameterAdd OR xCorrectionToolDiameterAddMore OR 	xCorrectionToolDiameterSub OR xCorrectionToolDiameterSubMore OR xResetToolDiameterCorrection OR xKeyPadActivation THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
				IF xResetToolDiameterCorrection THEN
					(* next Step *)
					iStepAction :=20;
				END_IF;
				IF xKeyPadActivation THEN
					IF (T_Visu.T_PlcParam.dwActualPage = 420) OR (T_Visu.T_PlcParam.dwActualPage = 11) OR (T_Visu.T_PlcParam.dwActualPage = 21) THEN
						(* next Step *)
						iStepAction :=30;
					END_IF;
					IF (T_Visu.T_PlcParam.dwActualPage = 430) THEN
						(* next Step *)
						iStepAction :=40;
					END_IF;
				END_IF;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	IF xCorrectionToolDiameterAdd THEN
				rCorrectionValue:=0.1;
			END_IF;
			IF xCorrectionToolDiameterAddMore THEN
				rCorrectionValue:=1.0;
			END_IF;
			IF xCorrectionToolDiameterSub THEN
				rCorrectionValue:=-0.1;
			END_IF;
			IF xCorrectionToolDiameterSubMore THEN
				rCorrectionValue:=-1.0;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter + rCorrectionValue;
			IF (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter < 0.1) AND
			    (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter > -0.1) THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter:=0.0;
			END_IF;
			(* next Step *)
			iStepAction :=90;
		20:	T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter:=0.0;
			(* next Step *)
			iStepAction :=90;
		30:	T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.xKeyPadActivation:=NOT(T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.xKeyPadActivation);
			(* next Step *)
			iStepAction :=90;
		40:	(* 0= 3 value prisma, 1 = 3 value prisma input para, 2 = 2 value prisma, 3 = 2 value prisma input para *)
			IF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 0) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=1;
			ELSIF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 1) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=0;
			ELSIF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 2) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=3;
			ELSIF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 3) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=2;
			END_IF;
			(* next Step *)
			iStepAction:=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCorrectionToolDiameterAdd:=xCorrectionToolDiameterAddMore:=xCorrectionToolDiameterSub:=xCorrectionToolDiameterSubMore:=xResetToolDiameterCorrection:=xKeyPadActivation:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCorrectionToolDiameterAdd:=xCorrectionToolDiameterAddMore:=xCorrectionToolDiameterSub:=xCorrectionToolDiameterSubMore:=xResetToolDiameterCorrection:=xKeyPadActivation:=FALSE;
		END_CASE
	END_IF;

(* Function Correction Tool Diameter *)
	IF xFctCorrectionToolDiameter THEN
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xReady
						AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* Display message to ask for confirmation *)
		10:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=108;
			iStepAction:=20;
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN iStepAction:=30;
			ELSE IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF END_IF
			(* An other message has been displayed, stop teach action *)
			IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>108 THEN iStepAction:=90; END_IF
		(* activ function axis *)
		30:	(*T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualGrindAxisPosition:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rActualGrindAxisPosition - T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter;*)
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition - T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rCorrectionToolDiameter:=0.0;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=11;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=50;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		50:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xFctCorrectionToolDiameter:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xFctCorrectionToolDiameter:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			xFctCorrectionToolDiameter:=FALSE;
		END_CASE
	END_IF;

(* Select Prisma 1 or 2 Input *)
	IF xSelectPrisma THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	(* 0= 3 value prisma, 1 = 3 value prisma input para, 2 = 2 value prisma, 3 = 2 value prisma input para *)
			IF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 0) OR (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 1) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=2;
			ELSIF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 2) OR (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma = 3) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara.bStateInputPrisma:=0;
			END_IF;
			(* next Step *)
			iStepAction:=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSelectPrisma:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSelectPrisma:=FALSE;
		END_CASE
	END_IF;

(* Set calculated ToolRotation Torque *)
	IF xSetCalculToolRotTorque THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	uiToolLeftZeroTorque:=T_Station.THardware.TAxisToolLeft.T_LiveValue.uiActualTorque;
			FBCalcTorqueToolLeft(	xStart:=TRUE,
									uiActualTorque:= T_Station.THardware.TAxisToolLeft.T_LiveValue.uiActualTorque,
									uiZeroTorque:=uiToolLeftZeroTorque,
									iStepCalc:= 100);
			uiToolCenterZeroTorque:=T_Station.THardware.TAxisToolCenter.T_LiveValue.uiActualTorque;
			FBCalcTorqueToolCenter(	xStart:=TRUE,
									uiActualTorque:= T_Station.THardware.TAxisToolCenter.T_LiveValue.uiActualTorque,
									uiZeroTorque:=uiToolCenterZeroTorque,
									iStepCalc:= 100);
			uiToolRightZeroTorque:=T_Station.THardware.TAxisToolRight.T_LiveValue.uiActualTorque;
			FBCalcTorqueToolRight(	xStart:=TRUE,
									uiActualTorque:= T_Station.THardware.TAxisToolRight.T_LiveValue.uiActualTorque,
									uiZeroTorque:=uiToolRightZeroTorque,
									iStepCalc:= 100);
			(* next Step *)
			iStepAction:=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetCalculToolRotTorque:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetCalculToolRotTorque:=FALSE;
		END_CASE
	END_IF;

(* Reset calculated ToolRotation Torque *)
	IF xResetCalculToolRotTorque THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	uiToolLeftZeroTorque:=0;
			FBCalcTorqueToolLeft(	xStart:=TRUE,
									uiActualTorque:= T_Station.THardware.TAxisToolLeft.T_LiveValue.uiActualTorque,
									uiZeroTorque:=uiToolLeftZeroTorque,
									iStepCalc:= 100);
			uiToolCenterZeroTorque:=0;
			FBCalcTorqueToolCenter(	xStart:=TRUE,
									uiActualTorque:= T_Station.THardware.TAxisToolCenter.T_LiveValue.uiActualTorque,
									uiZeroTorque:=uiToolCenterZeroTorque,
									iStepCalc:= 100);
			uiToolRightZeroTorque:=0;
			FBCalcTorqueToolRight(	xStart:=TRUE,
									uiActualTorque:= T_Station.THardware.TAxisToolRight.T_LiveValue.uiActualTorque,
									uiZeroTorque:=uiToolRightZeroTorque,
									iStepCalc:= 100);
			(* next Step *)
			iStepAction:=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xResetCalculToolRotTorque:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xResetCalculToolRotTorque:=FALSE;
		END_CASE
	END_IF;

(* Switch WireFeed Jog Speed Slow/Fast *)
	IF xSlowFastJogToolRotation OR xSlowFastJogToolFeeder OR xSlowFastJogGrindFeeder THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	IF xSlowFastJogToolRotation THEN
				T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolRotation:=NOT(T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolRotation);
			END_IF;
			IF xSlowFastJogToolFeeder THEN
				T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolFeed:=NOT(T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastToolFeed);
			END_IF;
			IF xSlowFastJogGrindFeeder THEN
				T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastGrindFeeder:=NOT(T_Visu.ptrT_ExchgParam^.T_TeachIn.xSlowFastGrindFeeder);
			END_IF;
			(* next Step *)
			iStepAction:=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSlowFastJogToolRotation:=xSlowFastJogToolFeeder:=xSlowFastJogGrindFeeder:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSlowFastJogToolRotation:=xSlowFastJogToolFeeder:=xSlowFastJogGrindFeeder:=FALSE;
		END_CASE
	END_IF;

(* Action stop axis *)
	IF xStopAxis THEN
		(* Step stop axis *)
		CASE iStepAction OF
		(* check axis *)
		1:	xMoveAbsPosition:=xMoveRelPosition:=xMoveContinousVel:=FALSE;
			IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				IF ptrTeachINAxis^.T_CtrleSingle.xErr THEN
					iStepAction:=99;
					RETURN;
				END_IF;
				iStepAction:=95;
				xTmp:=	ptrTeachINAxis^.T_CtrleSingle.xReady (*AND
						NOT(ptrTeachINAxis^.T_CtrleSingle.xErr)*);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				ELSE
					iStepAction:=95;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	ptrTeachINAxis^.T_CtrleSingle.iFunction:=5;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* init. acc/dec/jerk *)
			ptrTeachINAxis^.T_CtrleSingle.lrAcceleration:=TParaAxisTeachIN.rAcceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrDecceleration:=TParaAxisTeachIN.rDeceleration;
			(*
			ptrTeachINAxis^.T_CtrleSingle.lrAcceleration:=ptrTeachINAxis^.T_Config_ObjFileValue.lrAcceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrDecceleration:=ptrTeachINAxis^.T_Config_ObjFileValue.lrDecceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrJerk:=ptrTeachINAxis^.T_Config_ObjFileValue.lrJerk;
			*)
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* waiting stop confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTeachINAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTeachINAxis^.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF ptrTeachINAxis^.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* waiting time out *)
		89:	IF TimerAction.Q THEN iStepAction:=90; END_IF
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* action done *)
		90:	bStateMachine:=1;
			xSetStateMachine:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStopAxis:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xStopAxis:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (ptrTeachINAxis^.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(ptrTeachINAxis^.T_Config_Gen.iTyp * 1000000) + ptrTeachINAxis^.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			ptrTeachINAxis^.T_CtrleSingle.iFunction:=1;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			xStopAxis:=FALSE;
			T_StartUp.T_Ctrle.xSetSecurityStateON:=TRUE;
		END_CASE
	END_IF

(* Action move abs position *)
	IF xMoveAbsPosition OR xMoveRelPosition THEN
		(* Step move abs position *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	ptrTeachINAxis^.T_CtrleSingle.xDone
						AND ptrTeachINAxis^.T_CtrleSingle.xReady
						AND ptrTeachINAxis^.T_CtrleSingle.xNotMoving
						AND ptrTeachINAxis^.T_CtrleSingle.xPower
						AND NOT(ptrTeachINAxis^.T_CtrleSingle.xErr)
						AND NOT(ptrTeachINAxis^.T_CtrleSingle.xExecute)
(*24.09.2010: KFS	{	 *)
						AND( (  T_Visu.T_PlcParam.dwActualPage = 210
							   AND NOT(T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.T_Standard.xActivOn)
							   AND NOT(T_Station.THardware.TCylToolRightActive.T_CtrleCyl.T_Standard.xActivOn)
					     		   AND NOT(T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.T_Standard.xActivOn) )  OR ( T_Visu.T_PlcParam.dwActualPage <> 210))
(*24.09.2010: KFS	}	 *)
						AND ((ptrTeachINAxis^.T_CtrleSingle.xRef AND xMoveAbsPosition AND xMicroRodActive) OR NOT(xMicroRodActive)OR xMoveRelPosition);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				ELSE
					IF NOT ptrTeachINAxis^.T_CtrleSingle.xRef AND xMoveAbsPosition THEN
					(* Display message, axis not referenced *)
						tTimeOutAction:=TimerAction.ET+T#2s;
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=18;
						(* Action has been cancelled *)
						iStepAction:=89;
					END_IF
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	tTimeOutAction:=T#999s;
			bStateMachine:=2;
			xSetStateMachine:=TRUE;
			IF xMoveAbsPosition THEN iStepAction:=20; END_IF
			IF xMoveRelPosition THEN iStepAction:=35; END_IF
			(* init. acc/dec/jerk *)
			ptrTeachINAxis^.T_CtrleSingle.lrAcceleration:=TParaAxisTeachIN.rAcceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrDecceleration:=TParaAxisTeachIN.rDeceleration;
			(*
			ptrTeachINAxis^.T_CtrleSingle.lrAcceleration:=ptrTeachINAxis^.T_Config_ObjFileValue.lrAcceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrDecceleration:=ptrTeachINAxis^.T_Config_ObjFileValue.lrDecceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrJerk:=ptrTeachINAxis^.T_Config_ObjFileValue.lrJerk;
			*)
		(* activ function axis move absolut *)
		20:	ptrTeachINAxis^.T_CtrleSingle.iFunction:=7;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=40;
			xStepActionDone:=FALSE;
		(* activ function axis move relativ *)
		35:	ptrTeachINAxis^.T_CtrleSingle.iFunction:=8;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=40;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		40:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTeachINAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
				(* Display message, 'Start moving' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=26;
			ELSE
				IF ptrTeachINAxis^.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					bStateMachine:=1;
					xSetStateMachine:=TRUE;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF ptrTeachINAxis^.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* waiting timeout *)
		89: IF TimerAction.Q THEN iStepAction:=90; END_IF
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xMoveAbsPosition:=FALSE;
			xMoveRelPosition:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xMoveAbsPosition:=FALSE;
			xMoveRelPosition:=FALSE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (ptrTeachINAxis^.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(ptrTeachINAxis^.T_Config_Gen.iTyp * 1000000) + ptrTeachINAxis^.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			ptrTeachINAxis^.T_CtrleSingle.iFunction:=1;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			xMoveAbsPosition:=FALSE;
			xMoveRelPosition:=FALSE;
			T_StartUp.T_Ctrle.xSetSecurityStateON:=TRUE;
			(*T_Visu.ptrT_ExchgParam^.T_TeachIn.iStateAxisMovement:=1;*)
		END_CASE
	END_IF

(* Action move velocity *)
	IF xMoveContinousVel THEN
		(* Step move continuous velocity *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	ptrTeachINAxis^.T_CtrleSingle.xDone
						AND ptrTeachINAxis^.T_CtrleSingle.xReady
						AND ptrTeachINAxis^.T_CtrleSingle.xNotMoving
						AND ptrTeachINAxis^.T_CtrleSingle.xPower
						AND NOT(ptrTeachINAxis^.T_CtrleSingle.xErr)
						AND NOT(ptrTeachINAxis^.T_CtrleSingle.xExecute)
(*24.09.2010: KFS	{	 *)
						AND( (  T_Visu.T_PlcParam.dwActualPage = 210
							   AND NOT(T_Station.THardware.TCylToolLeftActive.T_CtrleCyl.T_Standard.xActivOn)
							   AND NOT(T_Station.THardware.TCylToolRightActive.T_CtrleCyl.T_Standard.xActivOn)
					     		   AND NOT(T_Station.THardware.TCylToolCenterActive.T_CtrleCyl.T_Standard.xActivOn) )  OR ( T_Visu.T_PlcParam.dwActualPage <> 210))
(*24.09.2010: KFS	}	 *)
						AND (ptrTeachINAxis^.T_CtrleSingle.lrVelocity <> 0);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	bStateMachine:=2;
			xSetStateMachine:=TRUE;
			ptrTeachINAxis^.T_CtrleSingle.iFunction:=6;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* init. acc/dec/jerk *)
			ptrTeachINAxis^.T_CtrleSingle.lrAcceleration:=TParaAxisTeachIN.rAcceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrDecceleration:=TParaAxisTeachIN.rDeceleration;
			(*
			ptrTeachINAxis^.T_CtrleSingle.lrAcceleration:=ptrTeachINAxis^.T_Config_ObjFileValue.lrAcceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrDecceleration:=ptrTeachINAxis^.T_Config_ObjFileValue.lrDecceleration;
			ptrTeachINAxis^.T_CtrleSingle.lrJerk:=ptrTeachINAxis^.T_Config_ObjFileValue.lrJerk;
			*)
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTeachINAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTeachINAxis^.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF ptrTeachINAxis^.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xMoveContinousVel:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xMoveContinousVel:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (ptrTeachINAxis^.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(ptrTeachINAxis^.T_Config_Gen.iTyp * 1000000) + ptrTeachINAxis^.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			ptrTeachINAxis^.T_CtrleSingle.iFunction:=1;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			xMoveContinousVel:=FALSE;
		END_CASE
	END_IF

(* Action Toggle Axis Power *)
	IF xToggleAxisPower OR xResetAxis THEN
		(* Step toggle Axis power *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				IF xToggleAxisPower THEN
					xTmp:=	ptrTeachINAxis^.T_CtrleSingle.xDone
							AND ptrTeachINAxis^.T_CtrleSingle.xNotMoving
							AND NOT(ptrTeachINAxis^.T_CtrleSingle.xErr)
							AND NOT(ptrTeachINAxis^.T_CtrleSingle.xExecute);
				END_IF;
				IF xResetAxis THEN
					xTmp:=	(ptrTeachINAxis^.T_CtrleSingle.xDone OR ptrTeachINAxis^.T_CtrleSingle.xErr)
							AND ptrTeachINAxis^.T_CtrleSingle.xNotMoving
							AND NOT(ptrTeachINAxis^.T_CtrleSingle.xExecute);
				END_IF;
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	bStateMachine:=2;
			xSetStateMachine:=TRUE;
			IF xToggleAxisPower THEN
				IF ptrTeachINAxis^.T_CtrleSingle.xPower THEN
					ptrTeachINAxis^.T_CtrleSingle.iFunction:=4;
				END_IF;
				IF NOT(ptrTeachINAxis^.T_CtrleSingle.xPower) THEN
					ptrTeachINAxis^.T_CtrleSingle.iFunction:=3;
				END_IF;
			END_IF;
			IF xResetAxis THEN
				ptrTeachINAxis^.T_CtrleSingle.iFunction:=1;
			END_IF;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTeachINAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTeachINAxis^.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					bStateMachine:=1;
					xSetStateMachine:=TRUE;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF ptrTeachINAxis^.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xToggleAxisPower:=xResetAxis:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xToggleAxisPower:=xResetAxis:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (ptrTeachINAxis^.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(ptrTeachINAxis^.T_Config_Gen.iTyp * 1000000) + ptrTeachINAxis^.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			ptrTeachINAxis^.T_CtrleSingle.iFunction:=1;
			ptrTeachINAxis^.T_CtrleSingle.xExecute:=TRUE;
			xToggleAxisPower:=xResetAxis:=FALSE;
		END_CASE
	END_IF

(* Reference axis *)
	IF xReferenceAxis THEN
		(* Step reference Axis *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone
						AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xPower
						AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving
						AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr)
						AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	bStateMachine:=2;
			xSetStateMachine:=TRUE;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomingMethode:=5;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeOffset:=0.0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedSwitch:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rRefSpeed;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedZero:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rRefSpeed / 10.0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=9;	(* Reference Axis *)
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					bStateMachine:=1;
					xSetStateMachine:=TRUE;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xReferenceAxis:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xReferenceAxis:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			xReferenceAxis:=FALSE;
		END_CASE
	END_IF

(* Teach axis Position *)
	IF xTeachPosition THEN
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=10;
			ELSE
				iStepAction:=95;
			END_IF;
		(* Check teachin position *)
		10:	IF (iSelectedAxis = 4) THEN
				IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 0) THEN
				(* Display message 'Move position can not be teached' *)
					tTimeOutAction:=TimerAction.ET+T#2s;
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=31;
					(* Action has been cancelled *)
					iStepAction:=89;
				ELSE
					iStepAction:=20;
				END_IF
			END_IF;
			IF (iSelectedAxis = 5) THEN
				IF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 0) THEN
				(* Display message 'Move position can not be teached' *)
					tTimeOutAction:=TimerAction.ET+T#2s;
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=31;
					(* Action has been cancelled *)
					iStepAction:=89;
				(* Software limit switch pos and neg not possible that we can teach this position *)
				ELSIF (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 3) OR (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 4) THEN
				(* Display message 'Selected position can not be teached' *)
					tTimeOutAction:=TimerAction.ET+T#2s;
					T_ExchgParam.T_Visu.T_Message.iState:=30;
					(* Action has been cancelled *)
					iStepAction:=89;
				ELSE
					iStepAction:=20;
				END_IF
			END_IF;
		(* Check if the Axis is referenced *)
		20:	IF (iSelectedAxis = 4) THEN
				xTmp:=	T_Station.TControl.xReferenced;
				IF NOT(xTmp) THEN
					(* Display message 'Axis not referenced' *)
					tTimeOutAction:=TimerAction.ET+T#2s;
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=18;
					(* Action has been cancelled *)
					iStepAction:=89;
				ELSE
					iStepAction:=30;
				END_IF;
			ELSE
				iStepAction:=30;
			END_IF;
		(* Display message to ask for confirmation *)
		30:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=108;
			iStepAction:=40;
		(* waiting for key <Enter> or <Esc> *)
		40:	IF RisingEdgeKeyPanel_Enter.Q THEN iStepAction:=50;
			ELSE IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF END_IF
			(* An other message has been displayed, stop teach action *)
			IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>108 THEN iStepAction:=90; END_IF
		50:	IF (iSelectedAxis = 4) AND (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 1) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ProcessPara.rStartPosToolFeedAuto:=
					LREAL_TO_REAL(ptrTeachINAxis^.T_LiveValue.lrActualPosition);
			ELSIF (iSelectedAxis = 4) AND (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 2) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.rStartPosToolFeedCalib:=
					LREAL_TO_REAL(ptrTeachINAxis^.T_LiveValue.lrActualPosition);
			ELSIF (iSelectedAxis = 4) AND (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 3) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara.rMeasurePosToolFeedCalib:=
					LREAL_TO_REAL(ptrTeachINAxis^.T_LiveValue.lrActualPosition);
			ELSIF (iSelectedAxis = 4) AND (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveToolFeederPos = 4) THEN
				T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_AxisPosition.rLoadPosToolFeedAuto:=
					LREAL_TO_REAL(ptrTeachINAxis^.T_LiveValue.lrActualPosition);
			END_IF;
			iStepAction:=60;
			IF (iSelectedAxis = 5) AND (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 1) THEN
				(* The StartPosition will be set as absolut position for the GrindFeeder Axis *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=
					T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess;
				iStepAction:=80;
			END_IF;
			IF (iSelectedAxis = 5) AND (T_Visu.ptrT_ExchgParam^.T_TeachIn.iSaveGrindFeederPos = 2) THEN
				(* The Security Position will be set as absolut position for the GrindFeeder Axis *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=
										T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rToolDiameterProcess +
										T_NovRam.T_Data.T_ProcessImageData.T_ProcessPara.rSecurityPosGrindFeedProcess;
				iStepAction:=80;
			END_IF;
		60:	xAction_SaveNovRAMWithoutConfirm:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=70;
		70:	IF NOT(xAction_SaveNovRAMWithoutConfirm) THEN
				iStepAction:=90;
			END_IF;
		(* activ function axis *)
		80:	T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=11;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=81;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		81:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=98;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* waiting timeout *)
		89: IF TimerAction.Q THEN iStepAction:=90; END_IF
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xTeachPosition:=FALSE;
		(* slow/fast configuration done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xTeachPosition:=FALSE;
		(* axis error *)
		98:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			xTeachPosition:=FALSE;
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xTeachPosition:=FALSE;
		END_CASE
	END_IF

(* Calculate the position between the RefIndex and the RefSensor *)
	IF xCalcAngleRefIndex THEN
		(* Step calc the position between the RefIndex and the RefSensor *)
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=10;
			ELSE
				iStepAction:=95;
			END_IF;
		(* check axis state *)
		10:	xStepActionDone:=FALSE;
			xTmp:=	T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone
					AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xReady
					AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving
					AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr)
					AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute);
			IF xTmp THEN
				iStepAction:=20;
			ELSE
				iStepAction:=95;
			END_IF
		(* activ function axis *)
		20:	bStateMachine:=2;
			xSetStateMachine:=TRUE;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomingMethode:=5;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeOffset:=0.0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedSwitch:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rRefSpeed;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedZero:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rRefSpeed / 10.0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rDeceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrVelocity:=0.1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrPosition:=0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDistance:=-2;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=19;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=30;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		30:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone THEN
					T_Visu.ptrT_ExchgParam^.T_StationCommon.iWireFeederAngleRefIndex:=T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iStrokeAngleRefIndex;
					xStepActionDone:=FALSE;
					iStepAction:=40;
				ELSE
					IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF;
		(* Reference axis *)
		40:	T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomingMethode:=5;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeOffset:=0.0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedSwitch:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rRefSpeed;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeSpeedZero:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rRefSpeed / 10.0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrHomeAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rAcceleration;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=9;	(* Reference Axis *)
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=50;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		50:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone THEN
				(* confirm action next step *)
					bStateMachine:=1;
					xSetStateMachine:=TRUE;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* waiting time out *)
		89:	IF TimerAction.Q THEN iStepAction:=90; END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCalcAngleRefIndex:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xCalcAngleRefIndex:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			xCalcAngleRefIndex:=FALSE;
		END_CASE
	END_IF;

(* Switch ToolRotation Master Slave *)
	IF xSwitchMasterSlave THEN
		CASE iStepAction OF
		(* check axis *)
		1:	IF NOT T_Station.TControl.xHardwareConfigError THEN
				xStepActionDone:=FALSE;
				iStepAction:=95;
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xNotMoving AND
						NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr) AND
						NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute);
				xTmp:=	xTmp AND
						((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xNotMoving AND
						NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr) AND
						NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute) AND
						xMicroRodActive) OR
						NOT(xMicroRodActive));
				xTmp:=	xTmp AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xNotMoving AND
						NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr) AND
						NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute);
				xTmp:=	xTmp AND
						((T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xNotMoving AND
						NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr) AND
						NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute) AND
						NOT(xMicroRodActive)) OR
						xMicroRodActive);
				(* Start/Stop position or speed of teachin page has to be confirmed *)
				IF xTmp THEN
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* activ function axis *)
		10:	bStateMachine:=2;
			xSetStateMachine:=TRUE;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=25;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
			IF xMicroRodActive THEN
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=25;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(xMicroRodActive) THEN
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=25;
				T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=FALSE;
				IF xMicroRodActive THEN
					T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=FALSE;
				END_IF;
				IF NOT(xMicroRodActive) THEN
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=FALSE;
				END_IF;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone AND ((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
				     ((T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone AND NOT(xMicroRodActive)) OR xMicroRodActive) THEN
				(* confirm action next step *)
					IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xSlave AND T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xSlave AND xMicroRodActive THEN
						xToolRotationMasterSlave:=TRUE;
					END_IF;
					IF NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xSlave) AND NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xSlave) AND xMicroRodActive THEN
						xToolRotationMasterSlave:=FALSE;
					END_IF;
					IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xSlave AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xSlave AND NOT(xMicroRodActive) THEN
						xToolRotationMasterSlave:=TRUE;
					END_IF;
					IF NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xSlave) AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xSlave) AND NOT(xMicroRodActive) THEN
						xToolRotationMasterSlave:=FALSE;
					END_IF;
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr OR (T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive) OR
					     (T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr AND NOT(xMicroRodActive)) THEN
					(* activ action not ready or error *)
						iStepAction:=99;
						xStepActionDone:=FALSE;
					END_IF
				END_IF
			END_IF
		(* action done *)
		90:	bStateMachine:=1;
			xSetStateMachine:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSwitchMasterSlave:=FALSE;
		(* axis not ready *)
		95:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			TimerNotReady(IN:=TRUE);
			xSwitchMasterSlave:=FALSE;
		(* error *)
		99:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr THEN
				IF (T_Station.THardware.TAxisToolRight.T_Config_Gen.iTyp <> 0) THEN
					diErrorNr:=(T_Station.THardware.TAxisToolRight.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolRight.T_CtrleSingle.udiErrorID;
				ELSE
					diErrorNr:=0;
				END_IF;
			END_IF;
			IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive THEN
				IF (T_Station.THardware.TAxisToolCenter.T_Config_Gen.iTyp <> 0) THEN
					diErrorNr:=(T_Station.THardware.TAxisToolCenter.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolCenter.T_CtrleSingle.udiErrorID;
				ELSE
					diErrorNr:=0;
				END_IF;
			END_IF;
			IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr AND NOT(xMicroRodActive) THEN
				IF (T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp <> 0) THEN
					diErrorNr:=(T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.udiErrorID;
				ELSE
					diErrorNr:=0;
				END_IF;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr;
			T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr AND NOT(xMicroRodActive);
			xSwitchMasterSlave:=FALSE;
		END_CASE
	END_IF;

(* Action cylinder toggle state *)
	IF xToggleCylinderState THEN
		(* Step toggle state *)
		CASE iStepAction OF
		(* check cylinder state *)
		1:	xTmp:=	ptrCylAction^.T_CtrleCyl.xDone
					AND NOT(ptrCylAction^.T_CtrleCyl.xExecute)
					AND NOT(ptrCylAction^.T_CtrleCyl.xErr);
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
			IF xTmp AND T_Station.TControl.xHardwareConfigError THEN iStepAction:=95; END_IF;
		(* toggle cylinder state *)
		10:	ptrCylAction^.T_CtrleCyl.iFunction:=51;
			ptrCylAction^.T_CtrleCyl.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrCylAction^.T_CtrleCyl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrCylAction^.T_CtrleCyl.xDone THEN
				(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE 	IF ptrCylAction^.T_CtrleCyl.xErr THEN
						(* action error *)
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* waiting time out *)
		89:	IF TimerAction.Q THEN iStepAction:=90; END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xToggleCylinderState:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xToggleCylinderState:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			(*diErrorNr:=6000000 * ptrCylAction^.T_CtrleCyl.udiErrorID;*)
			diErrorNr:=9000000+ (1000000 * iSelectedCylinder) + ptrCylAction^.T_CtrleCyl.udiErrorID;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			ptrCylAction^.T_CtrleCyl.xReset:=TRUE;
			xToggleCylinderState:=FALSE;
		END_CASE
	END_IF

(* ToolTens force +,++,-,-- *)
	IF xToolTensForceAdd OR xToolTensForceAddMore OR xToolTensForceSub OR xToolTensForceSubMore THEN
		CASE iStepAction OF
		(* check cylinder state *)
		1:	xTmp:=	ptrCylAction^.T_CtrleCyl.xDone
					AND NOT(ptrCylAction^.T_CtrleCyl.xExecute)
					AND NOT(ptrCylAction^.T_CtrleCyl.xErr)
					AND ptrCylAction^.T_CtrleCyl.T_AnalogCylinder.xActiv;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
			IF xTmp AND T_Station.TControl.xHardwareConfigError THEN iStepAction:=95; END_IF;
		10:	IF xToolTensForceAdd THEN
				rCorrectionValue:=0.1;
			END_IF;
			IF xToolTensForceAddMore THEN
				rCorrectionValue:=1.0;
			END_IF;
			IF xToolTensForceSub THEN
				rCorrectionValue:=-0.1;
			END_IF;
			IF xToolTensForceSubMore THEN
				rCorrectionValue:=-1.0;
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce + rCorrectionValue;
			IF (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce < 0.1) THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce:=0.0;
			END_IF;
			IF (T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce > T_NovRAM.T_Data.T_Standard.T_ToolTensionSystem.rMaxForceTT) THEN
				T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce:=T_NovRAM.T_Data.T_Standard.T_ToolTensionSystem.rMaxForceTT;
			END_IF;
			(* next step *)
			iStepAction:=20;
		(* activ function set analog value *)
		20:	ptrCylAction^.T_CtrleCyl.T_AnalogCylinder.rForceIn:=T_Visu.ptrT_ExchgParam^.T_InfoValueCommon.rToolTensionForce;
			ptrCylAction^.T_CtrleCyl.iFunction:=4;
			ptrCylAction^.T_CtrleCyl.xExecute:=TRUE;
			(* next step *)
			iStepAction:=30;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		30:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrCylAction^.T_CtrleCyl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrCylAction^.T_CtrleCyl.xDone THEN
				(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE 	IF ptrCylAction^.T_CtrleCyl.xErr THEN
						(* action error *)
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* waiting time out *)
		89:	IF TimerAction.Q THEN iStepAction:=90; END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xToolTensForceAdd:=xToolTensForceAddMore:=xToolTensForceSub:=xToolTensForceSubMore:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xToolTensForceAdd:=xToolTensForceAddMore:=xToolTensForceSub:=xToolTensForceSubMore:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			(*diErrorNr:=6000000 * ptrCylAction^.T_CtrleCyl.udiErrorID;*)
			diErrorNr:=9000000+ (1000000 * iSelectedCylinder) + ptrCylAction^.T_CtrleCyl.udiErrorID;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			ptrCylAction^.T_CtrleCyl.xReset:=TRUE;
			xToolTensForceAdd:=xToolTensForceAddMore:=xToolTensForceSub:=xToolTensForceSubMore:=FALSE;
		END_CASE
	END_IF;

(* Action Station Function *)
	IF xActivateStationFunction THEN;
		(* Step  function station  *)
		CASE iStepAction OF
		(* check station state *)
		1:	xTmp:=	T_Station.TControl.xEnd AND
					T_Station.TControl.xRdy AND
					NOT(T_Station.TControl.xStart) AND
					NOT(T_Station.TControl.xError) AND
					NOT(T_Station.TControl.xStop) AND
					( (T_Visu.ptrT_ExchgParam^.T_StationCommon.rNewToolRotationSpeed <> 0) OR (iTmpStationFunctionNr = 20)) ;
			(* next step *)
			IF xTmp THEN iStepAction:=20; ELSE iStepAction:=95; END_IF
			IF xTmp AND T_Station.TControl.xHardwareConfigError THEN iStepAction:=95; END_IF;
		(* determin function number *)
		20:	IF (iTmpStationFunctionNr = 2) THEN
				bStateMachine:=2;
				xSetStateMachine:=TRUE;
			END_IF;
			T_Station.TControl.iFunctNr:=iTmpStationFunctionNr;
			CASE T_Station.TControl.iFunctNr OF
			(* available function, activ function *)
			2,3:	CASE T_Station.TControl.iFunctNr OF
				2:	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrVelocity:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rNewToolRotationSpeed;
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolLeft.rAcceleration;
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrDecceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolLeft.rDeceleration;
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearDivider:=10000;
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearFactor:=10000;

					IF xMicroRodActive THEN
						(* ToolCenter --> Slave of ToolLeft only by MicroRod *)
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolCenter.rAcceleration;
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrDecceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolCenter.rDeceleration;
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearFactor:=(	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																						(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.lrGearRatio)) * -1.0;
						(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolRight.rAcceleration;
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolRight.rDeceleration;
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																						(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio);
					END_IF;
					IF NOT(xMicroRodActive) THEN
						(* ToolRight --> Slave of ToolRight by MicroWire *)
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rAcceleration;
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrDecceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder.rDeceleration;
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																						(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.lrGearRatio /
																						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;

						(* ToolRight --> Slave of ToolLeft by MicroWire or Slave of ToolRight by MicroRod *)
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrAcceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolRight.rAcceleration;
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrDecceleration:=T_NovRAM.T_Data.T_Standard.T_TeachINToolRight.rDeceleration;
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearDivider:=INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider);
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearFactor:=	(INT_TO_LREAL(T_Station.T_WorkTool.iBaseGearDivider) /
																						(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.lrGearRatio /
																						T_Station.THardware.TAxisToolRight.T_CtrleSingle.lrGearRatio)) * -1.0;
					END_IF;
				END_CASE;
				T_Station.TControl.xStart:=TRUE;
				IF (T_Station.TControl.iFunctNr = 2) THEN
					(* Display message *)
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=25;
				END_IF;
				(* next step *)
				iStepAction:=30;
			(* not available function *)
			20:	T_Station.TControl.xStart:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=2;
(*				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReferenceMaxToolLength:=2;*)
				bStateMachine:=2;
				xSetStateMachine:=TRUE;
			    	iStepAction:=30;
			1,4..19,21..99:		iStepAction:=95;
			END_CASE
			(* next step *)
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		30:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				T_Station.TControl.xStart:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF T_Station.TControl.xEnd THEN
				(* action done *)
					IF(iTmpStationFunctionNr = 20) THEN
						iStepAction:=50;
					ELSE
						iStepAction:=90;
					END_IF;
					xStepActionDone:=FALSE;
				ELSE 	IF T_Station.TControl.xError THEN
						(* action error *)
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* Save NovRam *)
		50:	T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition *0.1;
			T_NovRam.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal:=T_Station.THardware.TAxisToolFeeder.T_LiveValue.lrActualPosition *0.1;
			T_Station.xOverwriteMaxToolLength:=TRUE;
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			iStepAction:=60;
		60:	IF NOT(xStepActionDone) THEN
				xStepActionDone:=TRUE;
				T_NovRAM.T_Ctrle.xExecute:=FALSE;
			END_IF;
			IF T_NovRAM.T_Ctrle.xDone THEN
				T_Station.T_MachineConfig.rConfigMaxToolLength:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
				T_Station.xOverwriteMaxToolLength:=FALSE;
				xStepActionDone:=FALSE;
				iStepAction:=90;
			END_IF;
		(* action done *)
		90:	IF (iTmpStationFunctionNr = 3) THEN
				bStateMachine:=1;
				xSetStateMachine:=TRUE;
			END_IF;
			IF (iTmpStationFunctionNr = 20) THEN
				T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLengthOriginal:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=1;
(*				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReferenceMaxToolLength:=1;*)
				bStateMachine:=1;
				xSetStateMachine:=TRUE;
			END_IF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActivateStationFunction:=FALSE;
		(* Configuration Error *)
		91:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActivateStationFunction:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xActivateStationFunction:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			FBErrorMessage(	diErrorNr:=T_Station.TControl.diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActivateStationFunction:=FALSE;
		END_CASE
	END_IF;

(* Activation of the Section for the ToolGeometry *)
	IF xActivationSection1 OR xActivationSection2 OR xActivationSection3 OR xActivationSection4 OR xSetPitchEqual THEN
		CASE iStepAction OF
		(* check visu *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		(* Set parameter page *)
		10:	ptxActiveSection1:=ADR(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[1]);
			ptxActiveSection2:=ADR(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[2]);
			ptxActiveSection3:=ADR(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3]);
			ptxActiveSection4:=ADR(T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4]);
			IF xActivationSection1 THEN
				IF (ptxActiveSection1^ AND NOT(ptxActiveSection2^)) OR
				    (NOT(ptxActiveSection1^) AND NOT(ptxActiveSection2^) AND (ptxActiveSection3^ OR ptxActiveSection4^)) THEN
					;
				ELSE
					ptxActiveSection1^:=NOT(ptxActiveSection1^);
				END_IF;
			END_IF;
			IF xActivationSection2 THEN
				IF (ptxActiveSection2^ AND ptxActiveSection1^ AND ptxActiveSection3^) OR
				    (ptxActiveSection2^ AND NOT(ptxActiveSection1^) AND NOT(ptxActiveSection3^)) OR
				    (NOT(ptxActiveSection2^) AND NOT(ptxActiveSection1^) AND NOT(ptxActiveSection3^) AND ptxActiveSection4^)THEN
					;
				ELSE
					ptxActiveSection2^:=NOT(ptxActiveSection2^);
				END_IF;
			END_IF;
			IF xActivationSection3 THEN
				IF (ptxActiveSection3^ AND ptxActiveSection2^ AND ptxActiveSection4^) OR
				    (ptxActiveSection3^ AND NOT(ptxActiveSection2^) AND NOT(ptxActiveSection4^)) OR
				    (NOT(ptxActiveSection3^) AND NOT(ptxActiveSection2^) AND NOT(ptxActiveSection4^) AND ptxActiveSection1^)THEN
					;
				ELSE
					ptxActiveSection3^:=NOT(ptxActiveSection3^);
				END_IF;
			END_IF;
			IF xActivationSection4 THEN
				IF (ptxActiveSection4^ AND NOT(ptxActiveSection3^)) OR
				    (NOT(ptxActiveSection4^) AND NOT(ptxActiveSection3^) AND (ptxActiveSection1^ OR ptxActiveSection2^)) THEN
					;
				ELSE
					ptxActiveSection4^:=NOT(ptxActiveSection4^);
				END_IF;
			END_IF;
			IF xSetPitchEqual THEN
				IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[1] THEN
					rSectionPitch:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[1];
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[2] THEN
						T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[2]:=rSectionPitch;
					END_IF;
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
						T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[3]:=rSectionPitch;
					END_IF;
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
						T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[4]:=rSectionPitch;
					END_IF;
				ELSIF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[2] THEN
					rSectionPitch:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[2];
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
						T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[3]:=rSectionPitch;
					END_IF;
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
						T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[4]:=rSectionPitch;
					END_IF;
				ELSIF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[3] THEN
					rSectionPitch:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[3];
					IF T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.axActiveSection[4] THEN
						T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry.arSectionPitch[4]:=rSectionPitch;
					END_IF;
				END_IF;
			END_IF;
			iStepAction :=90;
		(* change page done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActivationSection1:=xActivationSection2:=xActivationSection3:=xActivationSection4:=xSetPitchEqual:=FALSE;
		(* not ready *)
		95:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActivationSection1:=xActivationSection2:=xActivationSection3:=xActivationSection4:=xSetPitchEqual:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xActivationSection1:=xActivationSection2:=xActivationSection3:=xActivationSection4:=xSetPitchEqual:=FALSE;
		END_CASE
	END_IF;

(* Copy profile value to process *)
	IF xAction_CopyProfileToProcess THEN
		(* Set copy action *)
		CASE iStepAction OF
		(* Set default value *)
		1:	(*IF xFctSetDefaultValueProfileOnlineChange(ptrNovRAM:=ADR(T_WorkingData),
												   ptrDefaultProfilStandProcPara:=ADR(T_DefaultProfilStandProcPara),
												   bActiveStation:=0) THEN iStepAction:=5; END_IF*)
			iStepAction:=10;
			(* Init. display value *)
			xProfileFileNotFound:=FALSE;
		(* activ reading profile file *)
		10:	IF (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile > 0) AND (T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile <= csiMaxProfile) THEN
				T_Profile.T_Id.iNumber:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile;
				T_Profile.T_Id.sName:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName;
				T_Profile.T_Ctrle.iFunction:=1;
				T_Profile.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepAction:=20;
			ELSE iStepAction:=25; END_IF
		20:	IF NOT T_Profile.T_Ctrle.xExecute AND T_Profile.T_Ctrle.xDone THEN
				(* next step *)
				iStepAction:=90;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN
				xProfileFileNotFound:=TRUE;
				iToLoadProfileNr:=T_Profile.T_Id.iNumber;
				sToLoadProfileName:=T_Profile.T_Id.sName;
				(* activ reset *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				(* next step *)
				iStepAction:=25;
			END_IF
		(* waiting flag *)
		25:	IF NOT T_Profile.T_Ctrle.xReset AND T_Profile.T_Ctrle.xDone THEN
				IF (T_Profile.T_Id.iNumber = 1) THEN
					(*T_ActualProfilStandProcPara[1]:=T_DefaultProfilStandProcPara[1];*)
					iStepAction:=90;
				ELSE
					iStepAction:=26;
				END_IF;
				(* erase name *)
				T_NovRam.T_Data.T_IDProfileStation[1].sName:='Default';
				T_NovRam.T_Data.T_IDProfileStation[1].iNumber:=1;
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName:='Default';
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile:=1;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN iStepAction:=99; END_IF
		(* activ reading profile file *)
		26:	T_Profile.T_Id.iNumber:=1;
			T_Profile.T_Id.sName:='Default';
			T_Profile.T_Ctrle.iFunction:=1;
			T_Profile.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
		(* End function *)
		90:	IF xProfileFileNotFound THEN
				xProfileFileNotFound:=FALSE;
				sTmpDynamicText:=INT_TO_STRING(iToLoadProfileNr);
				sTmpDynamicText:=CONCAT(sTmpDynamicText,' ');
				(* For English Language *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=CONCAT(T_ErrorList.asErrorListEnglish.T_LanguagList[50],sTmpDynamicText);	(* 'Profile file not found: ' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=CONCAT(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish,sToLoadProfileName);
				(* For German Language *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=CONCAT(T_ErrorList.asErrorListDeutsch.T_LanguagList[50],sTmpDynamicText);	(* 'Profile file not found: ' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=CONCAT(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch,sToLoadProfileName);
				(* For French Language *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=CONCAT(T_ErrorList.asErrorListFrancais.T_LanguagList[50],sTmpDynamicText);	(* 'Profile file not found: ' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=CONCAT(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais,sToLoadProfileName);
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=1;	(* Datei für Profile nicht gefunden *)
			END_IF;
			xUpdateProfileList:=TRUE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=16#0;
			xAction_CopyProfileToProcess:=FALSE;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAction_CopyProfileToProcess:=FALSE;
		(* Error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			xAction_CopyProfileToProcess:=FALSE;
		END_CASE
	END_IF

(* Load profile to process image *)
	IF xAction_LoadProfileToProcessImage THEN
		(* Step import/export profile value *)
		CASE iStepAction OF
		(* Display message to ask for confirmation *)
		1:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=111;
			(* next step *)
			iStepAction:=10;
		(* waiting for key <Enter> or <Esc> *)
		10:	IF RisingEdgeKeyPanel_Enter.Q THEN
				xProfileFileNotFound:=FALSE;
				(* Display message transfering *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=15;
				(* next step *)
				iStepAction:=20;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF
				(* An other message has been displayed, stop import/export action *)
				IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>105 AND  T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>111THEN iStepAction:=90; END_IF
			END_IF
		(* Init. reading profile file *)
		20:	IF T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName <> '' THEN
			(* Profile name exists *)
				T_Profile.T_Id.iNumber:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber;
				T_Profile.T_Id.sName:=T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName;
				T_Profile.T_Ctrle.iFunction:=1;
				T_Profile.T_Ctrle.xExecute:=TRUE;
				(* Display info message *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=15;
				(* next step *)
				iStepAction:=30;
			(* Display info message 'file does not exists *)
			ELSE
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=11;
				(* next step *)
				iStepAction:=50;
				xStepActionDone:=FALSE;
				tTimeOutAction:=TimerAction.ET+T#2s;
			END_IF
		(* waiting confirmation signal *)
		30:	IF NOT T_Profile.T_Ctrle.xExecute AND T_Profile.T_Ctrle.xDone THEN
			(* Copy profile to online value *)
				T_NovRam.T_Data.T_ProcessImageData:=T_NovRam.T_Data.T_ProcessImageLoadData;
				xResetParaListValue:=TRUE;
				(* next step *)
				iStepAction:=60;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN
				IF T_Profile.T_Id.iNumber > 1 THEN
				(* Reset profile value, display message and reset profile error *)
					(*xFctResetProfileValue(ptrProfileData:=ADR(T_Profile.T_DataOnline));*)
					T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName:='';
					(* Profile will be erased from the profile list *)
					T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName:='';
					xUpdateProfileList:=TRUE;
					(* Display info message 'file does not exists *)
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=11;
					(* Reset control profile *)
					T_Profile.T_Ctrle.xReset:=TRUE;
					(* next step *)
					iStepAction:=40;
					xStepActionDone:=FALSE;
					(* use tmp timer to diplay message *)
					TimerONTmp(IN:=FALSE);
					TimerONTmp.PT:=T#1s;
				ELSE
					xProfileFileNotFound:=TRUE;
					iToLoadProfileNr:=1;
					sToLoadProfileName:='Default';
					(* Set Static Default Parameter *)
(*
					IF xFctSetDefaultValueProfileOnlineChange(ptrNovRAM:=ADR(T_WorkingData),
									ptrDefaultProfilStandProcPara:=ADR(T_DefaultProfilStandProcPara),
									bActiveStation:=T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation) THEN
						T_WorkingData.T_Station[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation].T_StProcess:=T_DefaultProfilStandProcPara[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation];
						T_ActualProfilStandProcPara[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation]:=T_DefaultProfilStandProcPara[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation];
						T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ParamStProcess:=T_DefaultProfilStandProcPara[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation];
						T_WorkingData.T_Station[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation].T_InfoProcess.iProfile:=1;
						T_WorkingData.T_Station[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation].T_Config.iProfile:=1;
						T_WorkingData.T_Station[T_Visu.ptrT_ExchgParam^.T_Visu.bActivStation].T_InfoProcess.sProfileName:='Default';
						T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile:=1;
						T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName:='Default';
						(* Reset control profile *)
						T_Profile.T_Ctrle.xReset:=TRUE;
						(* next step *)
						iStepAction:=60;
					END_IF;
*)
				END_IF;
			END_IF
		(* Wait delay timer *)
		40:	IF TimerONTmp.Q THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
				(* next step *)
				iStepAction:=60;
			END_IF
		(* delay time out *)
		50:	IF TimerAction.Q THEN xAction_LoadProfileToProcessImage:=FALSE; END_IF
		(* active saving data NovRAM *)
		60:	IF NOT(xResetParaListValue) THEN
				xAction_SaveNovRAMWithoutConfirm:=TRUE;
				iStepActionNovRam:=1;
				(* next step *)
				iStepAction:=80;
			END_IF;
		(* waiting confirm saving NovRAM action *)
		80:	IF NOT xAction_SaveNovRAMWithoutConfirm THEN
				iStepAction:=90;
			END_IF;
		(* save done *)
		90:	IF xProfileFileNotFound THEN
				xProfileFileNotFound:=FALSE;
				sTmpDynamicText:=INT_TO_STRING(iToLoadProfileNr);
				sTmpDynamicText:=CONCAT(sTmpDynamicText,' ');
				sTmpDynamicText:=CONCAT(sTmpDynamicText,sToLoadProfileName);
				(* For English Language *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=CONCAT(T_ErrorList.asErrorListEnglish.T_LanguagList[50],sTmpDynamicText);	(* 'Profile file not found: ' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=CONCAT(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish,T_ErrorList.asErrorListEnglish.T_LanguagList[51]);	(* ' -->Load static default parameter' *)
				(* For German Language *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=CONCAT(T_ErrorList.asErrorListDeutsch.T_LanguagList[50],sTmpDynamicText);	(* 'Profile file not found: ' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=CONCAT(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch,T_ErrorList.asErrorListDeutsch.T_LanguagList[51]);	(* ' -->Load static default parameter' *)
				(* For French Language *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=CONCAT(T_ErrorList.asErrorListFrancais.T_LanguagList[50],sTmpDynamicText);	(* 'Profile file not found: ' *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=CONCAT(T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais,T_ErrorList.asErrorListFrancais.T_LanguagList[51]);	(* ' -->Load static default parameter' *)
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=1;	(* Datei für Profile nicht gefunden *)
			END_IF;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_LoadProfileToProcessImage:=FALSE;
		(* Action not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAction_LoadProfileToProcessImage:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			xAction_LoadProfileToProcessImage:=FALSE;
		END_CASE
	END_IF

(* Save profile to File *)
	IF xAction_SaveProfileToFile THEN
				(* Step import/export profile value *)
		CASE iStepAction OF
		(* Display message to ask for confirmation *)
		1:	IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber > 1 THEN
				IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName <> '' THEN
					IF NOT xFctCtrleProfileName(	sNewProfileName:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName,
												ptrProfileList:=ADR(T_NovRam.T_Data.T_IDProfileStation)) THEN
						(* Display message 'ask for rewriting' *)
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=112;
						(* next step *)
						iStepAction:=10;
					ELSE
						(* Display message 'confirm saving' *)
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=108;
						(* next step *)
						iStepAction:=20;
					END_IF
				(* Display message, 'Profile name not correct' *)
				ELSE	tTimeOutAction:=TimerAction.ET+T#2s;
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=16;
						iStepAction:=89;
				END_IF
			ELSE
				 tTimeOutAction:=TimerAction.ET+T#2s;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=6;
				iStepAction:=89;
			END_IF
		(* waiting for rewriting confirmation key <Enter> or <Esc> *)
		10:	IF RisingEdgeKeyPanel_Enter.Q THEN
			(* Display message *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=13;
				(* next step *)
				iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF
				(* An other message has been displayed, stop saving action *)
				IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>112 THEN iStepAction:=90; END_IF
			END_IF
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
			(* Display message *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=13;
				(* next step *)
				iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF
				(* An other message has been displayed, stop saving action *)
				IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>108 THEN iStepAction:=90; END_IF
			END_IF
		30:	(* page profile *)
			iTmp:=0;
			iTmp:=  iFctExistProfileName(	sProfileName:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName,
										ptrProfileList:=ADR(T_NovRam.T_Data.T_IDProfileStation));
			IF iTmp = T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber OR iTmp = 0 THEN
				IF NOT xFctCtrleProfileName(	sNewProfileName:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName,
											ptrProfileList:=ADR(T_NovRam.T_Data.T_IDProfileStation)) THEN
					(* Rename profile datei *)
					sTmp:='\Hard Disk\Machine450\Profile\';
					sTmp_2:=sTmp;
					(* old name *)
					sTmp:=CONCAT(sTmp,T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName);
					T_HDD.T_File.sOldPathAndFileName:=CONCAT(sTmp,'.txt');
					(* new name *)
					sTmp_2:=CONCAT(sTmp_2,T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName);
					T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp_2,'.txt');
					IF T_HDD.T_File.sPathAndFileName<>T_HDD.T_File.sOldPathAndFileName THEN
					(* activ rename file *)
						T_HDD.T_Ctrle.xExecute:=TRUE;
						T_HDD.T_Ctrle.iFunction:=6;
					END_IF
				END_IF
				(* Disable Import prozess data state *)
				T_Visu.ptrT_ExchgParam^.T_ProfileCommon.xImportProzessData:=FALSE;
				(* next step *)
				iStepAction:=40;
			ELSE
				 tTimeOutAction:=TimerAction.ET+T#2s;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=24;
				iStepAction:=89;
			END_IF
		(* activ saving profile file *)
		40:	IF NOT T_HDD.T_Ctrle.xExecute AND T_HDD.T_Ctrle.xDone THEN
			(* activ saving profile file *)
				T_Profile.T_Id:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id;
				T_Profile.T_Ctrle.xExecute:=TRUE;
				T_Profile.T_Ctrle.iFunction:=2;
				(* next step *)
				iStepAction:=50;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepAction:=99; END_IF
		(* waiting signal and start saving data in NovRAM *)
		50:	IF NOT T_Profile.T_Ctrle.xExecute AND T_Profile.T_Ctrle.xDone THEN
				T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber]:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id;
(*
				T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName
					:=T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName;
*)
				(* Process profile value = file profile value *)
				IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber = T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile THEN
					T_NovRam.T_Data.T_ProcessImageLoadData:=T_NovRam.T_Data.T_ProcessImageData;
				END_IF
				(* page profile, update profile list *)
				xUpdateProfileList:=TRUE;
				(* next step *)
				iStepAction:=60;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN iStepAction:=99; END_IF
		(* active saving data NovRAM *)
		60:	xAction_SaveNovRAMWithoutConfirm:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=70;
		(* waiting confirm saving NovRAM action *)
		70:	IF NOT xAction_SaveNovRAMWithoutConfirm THEN
				iStepAction:=90;
			END_IF;
		(* no code, waiting timeout *)
		89:	IF TimerAction.Q THEN iStepAction:=90; END_IF
		(* save done *)
		90:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_SaveProfileToFile:=FALSE;
		(* NovRAM not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAction_SaveProfileToFile:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			IF T_HDD.T_Ctrle.xErr THEN T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_HDD.T_Ctrle.iFunction; T_HDD.T_Ctrle.xReset:=TRUE; END_IF
			IF T_Profile.T_Ctrle.xErr THEN T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_Visu.T_CtrleAction.iFunction; T_Profile.T_Ctrle.xReset:=TRUE; END_IF
			xAction_SaveProfileToFile:=FALSE;
		END_CASE
	END_IF;

(* Action Save NovRAM *)
	IF xAction_SaveNovRAM OR xAction_SaveNovRAMWithoutConfirm THEN
		(* Step saving NovRAM *)
		CASE iStepActionNovRam OF
		(* check NovRAM *)
		1:	xTmp:=	T_NovRAM.T_Ctrle.xDone
					AND NOT(T_NovRAM.T_Ctrle.xExecute)
					AND NOT(T_NovRAM.T_Ctrle.xErr);
			IF xTmp THEN
				(* next Step *)
				iStepActionNovRam :=10;
				xStepActionDone:=FALSE;
			(* activ error *)
			ELSE iStepActionNovRam:=95; END_IF
		(* copy value *)
		10:	IF  xAction_SaveNovRAM THEN
				(* saving with confirmation *)
				TimerAction(IN:=FALSE);
				tTimeOutAction:=T#6s;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=108;	(* Confirm saving action <Enter>, or escape <Esc> ? *)
				(* next Step *)
				iStepActionNovRam :=20;
			ELSE
				(* next Step *)
				IF xAction_LoadProfileToProcessImage OR xAction_SaveProfileToFile OR xActionDeleteProfile  THEN
					IF xAction_LoadProfileToProcessImage THEN
						T_NovRam.T_Data.T_Standard.T_InfoProcess.iProfile:=T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile;
						T_NovRam.T_Data.T_Standard.T_InfoProcess.sProfileName:=T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName;
					END_IF;
					iStepActionNovRam :=40;
				ELSE
					iStepActionNovRam :=30;
				END_IF;
				(* Display message *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=13;	(* Start saving *)
			END_IF;
		(* waiting for saving confirmation key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
			(* Display message *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=13;	(* Start saving *)
				(* next step *)
				iStepActionNovRam:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN iStepActionNovRam:=60; END_IF
				(* An other message has been displayed, stop saving action *)
				IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>108 THEN iStepActionNovRam:=60; END_IF
			END_IF
		30:	T_NovRAM.T_Data.T_ProcessImageData.T_GeometryPara:=T_Visu.ptrT_ExchgParam^.T_GeometryCommon.T_Geometry;
			T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara;
			IF (T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.bStateInputPrisma = 1) THEN
				T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.bStateInputPrisma:=0;
			END_IF;
			IF (T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.bStateInputPrisma = 3) THEN
				T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.bStateInputPrisma:=2;
			END_IF;
			rCalcMinMaxToolDia:=	rFctCalcMaxToolDiameter(	rDistanceD1:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaDistanceD1,
														rDistanceD2:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaDistanceD2,
														rAnglePrism:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaAngleA);
			T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax:=rCalcMinMaxToolDia;
			rCalcMinMaxToolDia:=	rFctCalcMinToolDiameter(	rDistanceD1:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaDistanceD1,
														rDistanceD2:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaDistanceD2,
														rAnglePrism:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaAngleA,
														bStateInputPrisma:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.bStateInputPrisma);
			T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin:=rCalcMinMaxToolDia;
			rCalcPrismaFactor:=	rFctCalcPrismaFactor(	rAnglePrism:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaAngleA);
			T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rPrismaFactor:=rCalcPrismaFactor;
			T_Visu.ptrT_ExchgParam^.T_StationCommon.T_PrismPara:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara;
			T_NovRAM.T_Data.T_Standard.T_TeachINToolLeft:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolLeft;
			T_NovRAM.T_Data.T_Standard.T_TeachINToolCenter:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolCenter;
			T_NovRAM.T_Data.T_Standard.T_TeachINToolRight:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolRight;
			T_NovRAM.T_Data.T_Standard.T_TeachINToolFeeder:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_ToolFeeder;
			T_NovRAM.T_Data.T_Standard.T_TeachINGrindFeeder:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_GrindFeeder;
			T_NovRAM.T_Data.T_Standard.T_AxisPosition:=T_Visu.ptrT_ExchgParam^.T_TeachIn.TParam_AxisPosition;
			T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigMachineType:=T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigMachineType;
			T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigAxisType:=T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigAxisType;
			T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation:=T_Visu.ptrT_ExchgParam^.T_StationCommon.iConfigVisuNavigation;
			T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength:=T_Visu.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength;
			T_NovRAM.T_Data.T_Standard.T_ToolTensionSystem:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ParamToolTensionSystem;
			T_NovRAM.T_Data.T_Standard.T_Cyl_ToolTension:=T_Visu.ptrT_ExchgParam^.T_Cylinder.T_ParamToolTension;
			T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara;
			T_NovRAM.T_Data.T_ProcessImageData.T_AutoGroovePara:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGroovePara;
			T_NovRAM.T_Data.T_ProcessImageData.T_CalibrationPara:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_CalibrationPara;
			T_NovRAM.T_Data.T_ProcessImageData.T_ProcessPara:=T_Visu.ptrT_ExchgParam^.T_StationCommon.T_ProcessPara;
			(* next Step *)
			iStepActionNovRam :=40;
		(* activ save *)
		40:	T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			(* next Step *)
			iStepActionNovRam :=50;
			xStepActionDone:=FALSE;
		(* wait save confirmation *)
		50:	IF NOT(xStepActionDone) THEN
				T_NovRAM.T_Ctrle.xExecute:=FALSE;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_NovRAM.T_Ctrle.xDone THEN
				(* next Step *)
					IF (T_Visu.T_PlcParam.dwActualPage = 430) OR ((T_Visu.T_PlcParam.dwActualPage = 130) AND (T_Visu.T_CtrleAction.iFunction = 1002)) OR
					     ((T_Visu.T_PlcParam.dwActualPage = 470) AND (T_Visu.ptrT_ExchgParam^.T_Config.iEditParam = 410)) THEN
						iStepActionNovRam :=51;
						xOpenMessageBox:=FALSE;
					ELSE
						iStepActionNovRam :=90;
					END_IF;
					xStepActionDone:=FALSE;
				ELSE	IF T_NovRAM.T_Ctrle.xErr THEN
							iStepActionNovRam:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* check first if the Actual position is between the pos and neg SW limit switch *)
		51:	IF (T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition >= T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin) AND
			     (T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition <= (T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax + T_NovRAM.T_Data.T_Standard.T_TeachINGrindFeeder.rOffsetSWPosEndSwitch)) THEN
				(* Actual Position is not over the SW limit switches *)
				iStepActionNovRam :=53;
			ELSE
				(* Actual Position is over the SW limit switches *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=29;		(* Switch off the SW limit switches, in this case the GrindFeeder will not move automatically *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				iStepActionNovRam :=52;
				xOpenMessageBox:=TRUE;
				tTimeOutAction:=tTimeOutAction + T#9999s;
			END_IF;
		(* Wait end of resettet SW end switch for the GrindFeeder Axis *)
		52:	IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				(* set the new position of the GrindFeeder Axis *)
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.rSetPosition:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=11;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				lrActualGrindFeedPosition:=DINT_TO_LREAL(LREAL_TO_DINT(T_Station.THardware.TAxisGrindFeeder.T_LiveValue.lrActualPosition * 100.0)) / 100.0;
				lrToWriteGrindFeedPosition:=DINT_TO_LREAL(LREAL_TO_DINT(T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin * 100.0)) / 100.0;
				iStepActionNovRam :=53;
			END_IF;
			IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
				iStepActionNovRam :=98;
			END_IF;
		(* Set SW end switch for the GrindFeeder Axis *)
		53:	IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=28;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrSWNegLimitSwitch:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMin;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.lrSWPosLimitSwitch:=T_NovRAM.T_Data.T_ProcessImageData.T_PrismPara.rToolDiameterMax + T_NovRAM.T_Data.T_Standard.T_TeachINGrindFeeder.rOffsetSWPosEndSwitch;
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				iStepActionNovRam :=54;
			END_IF;
			IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
				iStepActionNovRam :=98;
			END_IF;
		(* Wait end of settled SW end switch for the GrindFeeder Axis *)
		54:	IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone THEN
				IF xOpenMessageBox THEN
					xOpenMessageBox:=FALSE;
					iStepActionNovRam :=55;
				ELSE
					iStepActionNovRam :=90;
				END_IF;
			END_IF;
			IF NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
				iStepActionNovRam :=98;
			END_IF;
		(* Open MessageBox *)
		55:	T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine1:='The prisma value are changed and the actual ';
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine2:='GrindFeeder position is now over the';
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine3:='Software limit switches. The actual absolut';
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine4:='GrindFeeder position: ';
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine4:=CONCAT(T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine4,
																				LREAL_TO_STRING(lrActualGrindFeedPosition));
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine4:=CONCAT(T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine4,'um');
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine5:='is overwritten with the minimum ';
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine6:='ToolDiameter: ';
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine6:=CONCAT(T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine6,
																				LREAL_TO_STRING(lrToWriteGrindFeedPosition));
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine6:=CONCAT(T_Visu.ptrT_ExchgParam^.T_FunctionCommon.sMessageBoxLine6,'um');
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=TRUE;
			iStepActionNovRam :=56;
		(* Wait cofirming of the messagebox *)
		56:	IF NOT(T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox) THEN
				iStepActionNovRam :=90;
			END_IF;
			IF T_Visu.T_CtrleAction.xDone THEN
				T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
				xAction_SaveNovRAM:=FALSE;
				xAction_SaveNovRAMWithoutConfirm:=FALSE;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			END_IF;
		(* Reset settled value *)
		60:	xResetParaListValue:=TRUE;
			iStepActionNovRam:=70;
		70:	IF NOT(xResetParaListValue) THEN
				iStepActionNovRam:=90;
			END_IF;
		(* no code, waiting timeout *)
		89:	IF TimerAction.Q THEN iStepActionNovRam:=90; END_IF
		(* save done *)
		90:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_SaveNovRAM:=FALSE;
			xAction_SaveNovRAMWithoutConfirm:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
		(* NovRAM not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAction_SaveNovRAM:=FALSE;
			xAction_SaveNovRAMWithoutConfirm:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
		(* error *)
		98:	T_Visu.ptrT_ExchgParam^.T_StationCommon.wState:=T_Visu.ptrT_ExchgParam^.T_StationCommon.wState AND 16#BF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			IF (T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp <> 0) THEN
				diErrorNr:=(T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			ELSE
				diErrorNr:=0;
			END_IF;
			FBErrorMessage(	diErrorNr:=diErrorNr,
							T_ErrorList:=T_ErrorList);
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diErrorNr;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
			xAction_SaveNovRAM:=FALSE;
			xAction_SaveNovRAMWithoutConfirm:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xAction_SaveNovRAM:=FALSE;
			xAction_SaveNovRAMWithoutConfirm:=FALSE;
			T_Visu.ptrT_ExchgParam^.T_FunctionCommon.xOpenOverlayMessageBox:=FALSE;
		END_CASE
	END_IF;

(* Delete Profile *)
	IF xActionDeleteProfile THEN
		(* Step delete profile *)
		CASE iStepAction OF
		(* Profile number could not be 1 *)
		1:	IF T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber < 2 THEN
				 tTimeOutAction:=TimerAction.ET+T#2s;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=27;	(* Default profile can't be deleted *)
				iStepAction:=10;
			ELSIF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile = T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber THEN
				tTimeOutAction:=TimerAction.ET+T#2s;
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=28;	(* Load profile can't be deleted *)
				iStepAction:=10;
			ELSE iStepAction:=20; END_IF
		(* no code, waiting timeout *)
		10:	IF TimerAction.Q THEN xActionDeleteProfile:=FALSE; END_IF;
		(* Display message to ask for confirmation *)
		20:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=117;	(* Confirm delete profile <Enter>, or escape <Esc> ? *)
			(* next step *)
			iStepAction:=30;
		(* waiting for key <Enter> or <Esc> *)
		30:	IF RisingEdgeKeyPanel_Enter.Q THEN
				(* Display message deleting *)
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=29;	(* Start deleting *)
				(* next step *)
				iStepAction:=40;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN iStepAction:=90; END_IF
				(* An other message has been displayed, stop import/export action *)
				IF T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState<>117 THEN iStepAction:=90; END_IF
			END_IF;
		(* Init. deleting profile file *)
		40:	IF T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName <> '' THEN
				sTmp:='\Hard Disk\Machine450\Profile\';
				sTmp:=CONCAT(sTmp,T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName);
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				(* activ delete file *)
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_HDD.T_Ctrle.iFunction:=5;
				iStepAction:=50;
			(* Display info message 'file does not exists *)
			ELSE
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=11;
				(* next step *)
				iStepAction:=55;
				xStepActionDone:=FALSE;
				tTimeOutAction:=TimerAction.ET+T#2s;
			END_IF
		50:	IF NOT T_HDD.T_Ctrle.xExecute AND (T_HDD.T_Ctrle.xDone OR T_HDD.T_Ctrle.xErr) THEN
				T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
				(* Profile will be erased from the profile list *)
				T_NovRam.T_Data.T_IDProfileStation[T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber].sName:='';
				xUpdateProfileList:=TRUE;
				IF T_HDD.T_Ctrle.xErr THEN
					(* Display info message 'file does not exists *)
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=11;
					(* next step *)
					iStepAction:=52;
					xStepActionDone:=FALSE;
					(* use tmp timer to diplay message *)
					TimerONTmp(IN:=FALSE);
					TimerONTmp.PT:=T#2s;
				ELSE
					(* next step *)
					iStepAction:=70;
					xStepActionDone:=FALSE;
				END_IF;
			END_IF
		(* Wait delay timer *)
		52:	IF TimerONTmp.Q THEN
				T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
				(* next step *)
				iStepAction:=70;
			END_IF
		(* delay time out *)
		55:	IF TimerAction.Q THEN xActionDeleteProfile:=FALSE; END_IF
		(* active saving data NovRAM *)
		70:	T_Visu.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName:='';
			xAction_SaveNovRAMWithoutConfirm:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=80;
		(* waiting confirm saving NovRAM action *)
		80:	IF NOT xAction_SaveNovRAMWithoutConfirm THEN iStepAction:=90; END_IF
		(* save done *)
		90:	T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActionDeleteProfile:=FALSE;
		(* Action not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xActionDeleteProfile:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			xActionDeleteProfile:=FALSE;
		END_CASE;
	END_IF;

(* Action start process machine or station *)
	IF xActionProcMachine OR xActionProcStation THEN
		(* Step process machine *)
		CASE iStepAction OF
		(* check process state *)
		1:	xTmp:=	T_Process.xEnable AND
					T_Process.xEnd AND
					T_Process.xRdy AND
					NOT(T_Process.xStop) AND
					NOT(T_Process.xStopCycle) AND
					NOT(T_Process.xError);
			(* next step *)
			IF NOT(xTmp) THEN
				iStepAction:=95;
			ELSE IF xActionProcMachine THEN iStepAction:=10; ELSE iStepAction:=20; END_IF
			END_IF
		(* check process number and start process machine *)
		10:	CASE T_Process.iFunctNr OF
			(* process available *)
			(*	10=Process AutoGeometry
				20=Process AutoGroove
				30=Process Reference
			*)
			10,20,30:	T_Visu.T_CtrleProcess.iFunction:=1;
						T_Visu.T_CtrleProcess.xExecute:=TRUE;
						iStepAction:=90;
			(* unknown process *)
			ELSE	iStepAction:=95;
			END_CASE
			(* next step *)
			xStepActionDone:=FALSE;
		(* check process number and start process station *)
		20:	CASE T_Process.iFunctNr OF
			(* process available *)
			(*	40=ToolCalibration
			*)
			40:	T_Visu.T_CtrleProcess.iFunction:=2;
				T_Visu.T_CtrleProcess.xExecute:=TRUE;
				iStepAction:=90;
			(* unknown process *)
			ELSE
				iStepAction:=95;
			END_CASE
			(* next step *)
			xStepActionDone:=FALSE;
		(* Display message, waiting timeout *)
		89:	IF TimerAction.Q THEN
				(* init. trigger FB_CtrleButton Start/Stop *)
				T_Visu.ptrT_ExchgParam^.T_Machine.T_Process.wState:=16#0;
				(* action done *)
				iStepAction:=90;
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActionProcMachine:=FALSE;
			xActionProcStation:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xActionProcMachine:=FALSE;
			xActionProcStation:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xActionProcMachine:=FALSE;
			xActionProcStation:=FALSE;
		END_CASE
	END_IF

(* Manage process execution *)
	(* ...done *)
	RisingEdgeProcessDone(CLK:=T_Visu.T_CtrleProcess.xDone);
	IF RisingEdgeProcessDone.Q THEN
		IF NOT(T_StartUp.T_State.xBlockChangeMovementVisu) THEN
			IF T_Visu.T_CtrleProcess.iFunction <> 0 AND T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState = 0 THEN
			(* call confirmation message *)
				IF NOT xStopImmediatly THEN
					IF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=22;
					END_IF;
					(*T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState
						:=iFctReturnConfMessage(iNumAction:=T_Process.iFunctNr+1100);*);
				(* Display message 'Process is aborded' *)
				ELSE T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=9; END_IF
			END_IF
		END_IF;
	END_IF
	(* ...error *)
	RisingEdgeProcessError(CLK:=T_Visu.T_CtrleProcess.xErr);
	IF RisingEdgeProcessError.Q THEN
	(* call function bloc action error *)
		IF NOT(T_StartUp.T_State.xBlockChangeMovementVisu) THEN
			(*
			fbQvisError(	udiActionError:=T_Visu.T_CtrleProcess.udiErrorID,
						T_Message:=T_Visu.ptrT_ExchgParam^.T_Visu.T_Message);
			*);
		END_IF;
		(* Init. variable *)
		T_Visu.T_CtrleProcess.xExecute:=FALSE;
		T_Visu.T_CtrleProcess.xDone:=TRUE;
		T_Visu.T_CtrleProcess.xErr:=FALSE;
		T_Visu.T_CtrleProcess.udiErrorID:=0;
		(*iStepProcess:=1;*)
		(*xStepProcessDone:=FALSE;*)
	END_IF
	(* ...reset *)
	RisingEdgeResetProcess(CLK:=T_Visu.T_CtrleProcess.xReset);
	IF RisingEdgeResetProcess.Q THEN
		(* Init. variable *)
		T_Visu.T_CtrleProcess.xExecute:=FALSE;
		T_Visu.T_CtrleProcess.xDone:=TRUE;
		T_Visu.T_CtrleProcess.xErr:=FALSE;
		T_Visu.T_CtrleProcess.udiErrorID:=0;
		(*iStepProcess:=1;*)
		(*xStepProcessDone:=FALSE;*)
		(* Release process *)
		T_Visu.T_CtrleProcess.xReset:=FALSE;
	END_IF
	RisingEdgeExecuteProcess(CLK:=T_Visu.T_CtrleProcess.xExecute);
	IF RisingEdgeExecuteProcess.Q THEN
		(* Release execution *)
		T_Visu.T_CtrleProcess.xExecute:=FALSE;
		CASE T_Visu.T_CtrleProcess.iFunction OF
		(* Process machine *)
		1:	xProcessMachine:=TRUE;
		(* Process station *)
		2:	xProcessStation:=TRUE;
		(* process not implemented *)
		ELSE	T_Visu.T_CtrleProcess.xDone:=FALSE;
				T_Visu.T_CtrleProcess.xErr:=TRUE;
				T_Visu.T_CtrleProcess.udiErrorID:=16#E000;
				(* exit FB *)
				RETURN;
		END_CASE
		(* Init. variable *)
		T_Visu.T_CtrleProcess.xDone:=FALSE;
		T_Visu.T_CtrleProcess.xErr:=FALSE;
		T_Visu.T_CtrleProcess.udiErrorID:=0;
		iStepProcess:=1;
		xStepProcessDone:=FALSE;
		(* exit FB *)
		RETURN;
	END_IF

(* Process machine *)
	IF xProcessMachine OR xProcessStation THEN
		CASE iStepProcess OF
		(* check process number and start process machine *)
		1:	T_Process.xStart:=TRUE;
			iStepProcess:=10;
			IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=2;
			ELSIF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=2;
			ELSIF (T_Visu.T_PlcParam.dwActualPage = 30) THEN
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=2;
			ELSIF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
				T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=2;
			END_IF;
			(* next step *)
			xStepProcessDone:=FALSE;
		(* wait confirmation *)
		10:	IF NOT(xStepProcessDone) THEN
			(* release execution *)
				T_Process.xStart:=FALSE;
				xStepProcessDone:=TRUE;
				IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xWarmUp THEN
					xWarmUpMessageActiv:=TRUE;
					xWarmUpMessageDone:=TRUE;
				END_IF;
			ELSE
				IF T_Process.xEnd THEN
					(* action done *)
					iStepProcess:=90;
					xStepProcessDone:=FALSE;
				ELSE
					IF T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xWarmUp AND xWarmUpMessageActiv THEN
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=124;	(* WarmUp cycle activ *)
						xWarmUpMessageActiv:=FALSE;
					END_IF;
					IF (T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState=124                                                 )	AND
					     NOT(T_Visu.ptrT_ExchgParam^.T_StationCommon.T_AutoGeometryPara.xWarmUp) 	AND
					     xWarmUpMessageDone 															THEN
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=125;	(*WarmUp cycle time arrived. <Press StopButton>*)
						xWarmUpMessageDone:=FALSE;
					END_IF;
					IF T_Process.xError THEN
						(* action error *)
						iStepProcess:=99;
						xStepProcessDone:=FALSE;
						IF xProcessMachine THEN
							T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
							IF(T_Process.iFunctNr = 10) THEN
								IF (T_Visu.T_PlcParam.dwActualPage <> 10) THEN
									T_Visu.T_PlcParam.dwSetNewPage:=10;
									T_Visu.T_CtrleVisu.iFunction:=1;
									T_Visu.T_CtrleVisu.xExecute:=TRUE;
								END_IF;
							END_IF;
							IF(T_Process.iFunctNr = 20) THEN
								IF (T_Visu.T_PlcParam.dwActualPage <> 20) THEN
									T_Visu.T_PlcParam.dwSetNewPage:=20;
									T_Visu.T_CtrleVisu.iFunction:=1;
									T_Visu.T_CtrleVisu.xExecute:=TRUE;
								END_IF;
							END_IF;
							IF(T_Process.iFunctNr = 30) THEN
								IF (T_Visu.T_PlcParam.dwActualPage <> 30) THEN
									T_Visu.T_PlcParam.dwSetNewPage:=30;
									T_Visu.T_CtrleVisu.iFunction:=1;
									T_Visu.T_CtrleVisu.xExecute:=TRUE;
								END_IF;
							END_IF;
							IF(T_Process.iFunctNr = 40) THEN
								IF (T_Visu.T_PlcParam.dwActualPage <> 110) THEN
									T_Visu.T_PlcParam.dwSetNewPage:=110;
									T_Visu.T_CtrleVisu.iFunction:=1;
									T_Visu.T_CtrleVisu.xExecute:=TRUE;
								END_IF;
							END_IF;
						END_IF;
					END_IF
				END_IF
				IF NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4) THEN
					(*T_Process.xEnable:=FALSE;*)
					(*iStepProcess:=21;*)
					iStepProcess:=99;
					RETURN;
				END_IF;
			END_IF
		21:	IF NOT(T_Process.xEnd) THEN
				T_Process.xEnable:=TRUE;
				iStepProcess:=22;
			ELSE
				T_Process.xEnable:=FALSE;
			END_IF;
		22:	IF T_Process.xEnd THEN
				T_Visu.T_CtrleProcess.xDone:=TRUE;
				T_Visu.T_CtrleProcess.xErr:=FALSE;
				T_Visu.T_CtrleProcess.udiErrorID:=0;
				xProcessMachine:=FALSE;
				xProcessStation:=FALSE;
			END_IF;
		(* call page *)
		30:	T_Visu.T_PlcParam.dwSetNewPage:=dwPageNrProcessStart;
			T_Visu.T_CtrleVisu.iFunction:=2;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			(* next step *)
			iStepProcess:=90;
		(* process done *)
		90:	IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
				IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=1;
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 20) THEN
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=1;
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 30) THEN
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=1;
				ELSIF (T_Visu.T_PlcParam.dwActualPage = 110) THEN
					T_Visu.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=1;
				END_IF;
				IF xProcessMachine THEN
					IF NOT(T_StartUp.T_State.xBlockChangeMovementVisu) THEN
						T_StartUp.T_Ctrle.xExecute:=TRUE;
						T_StartUp.T_Ctrle.iFunction:=11;	(* Acitvate Info Message Overlay *)
						IF (T_Process.iFunctNr = 30) THEN
							(* THE REFERENCE DRIVE  IS COMPLEATED! *)
							(* CONFIRM THIS MESSAGE AND *)
							(* THE MACHINE WILL BE READY! *)
							(*  *)
							T_StartUp.T_Ctrle.iMsgNumber:=3;
						END_IF;
						IF (T_Process.iFunctNr = 10) OR (T_Process.iFunctNr = 20) THEN
							(* THE  AUTO MODE CYCLE IS COMPLEATED! *)
							(* CONFIRM THIS MESSAGE AND *)
							(* THE MACHINE WILL BE READY! *)
							(*  *)
							T_StartUp.T_Ctrle.iMsgNumber:=2;
						END_IF;
					END_IF;
				END_IF;
				T_Visu.T_CtrleProcess.xDone:=TRUE;
				T_Visu.T_CtrleProcess.xErr:=FALSE;
				T_Visu.T_CtrleProcess.udiErrorID:=0;
				xProcessMachine:=FALSE;
				xProcessStation:=FALSE;
			END_IF;
		(* error *)
		99:	IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
				IF xProcessMachine THEN
					T_StartUp.T_Ctrle.xExecute:=TRUE;
					T_StartUp.T_Ctrle.iFunction:=10;	(* Activate Error Message Overlay *)
					IF (T_Process.iFunctNr = 30) THEN
						(* DURING MACHINE REFERENCE PROC. *)
						(* AN ERROR HAS OCCURRED *)
						(* PLEASE CONFIRM  AND CHECK *)
						(* THE ACCORDING ERROR *)
						T_StartUp.T_Ctrle.iMsgNumber:=14;
					END_IF;
					IF (T_Process.iFunctNr = 10) OR (T_Process.iFunctNr = 20) THEN
						(* DURING THE AUTO MODE *)
						(* AN ERROR HAS OCCURRED *)
						(* PLEASE CONFIRM AND CHECK *)
						(* THE ACCORDING ERROR *)
						T_StartUp.T_Ctrle.iMsgNumber:=13;
					END_IF;
				END_IF;
				T_Visu.T_CtrleProcess.xDone:=FALSE;
				T_Visu.T_CtrleProcess.xErr:=TRUE;
				T_Visu.T_CtrleProcess.udiErrorID:=16#E0000 + T_Visu.T_CtrleProcess.iFunction;
				xProcessMachine:=FALSE;
				xProcessStation:=FALSE;
			END_IF;
		END_CASE
	END_IF

(* Stop process *)
	IF xStopProcess OR xAction_StopCycle THEN
		(* Set stop process *)
		CASE iStepAction OF
		(* check process state and stop process if possible *)
		1:	IF NOT xStopButton THEN
				xTmp:=	T_Process.xRdy
						AND NOT T_Process.xStop
						AND NOT T_Process.xStopCycle
						AND NOT T_Process.xEnd
						AND NOT T_Process.xError
						AND NOT T_Process.xAbord;
				IF xStopProcess AND T_Process.xStopCycle AND NOT(T_Process.xEnd) AND NOT(T_Process.xError) AND NOT(T_Process.xStop) THEN
					xTmp:=TRUE;
				END_IF;
				IF xAction_StopCycle THEN
					IF (T_NovRAM.T_Data.T_ProcessImageData.T_AutoGeometryPara.iCycleGeometry <= 1) THEN
						xTmp:=FALSE;
					END_IF;
				END_IF;
				IF xTmp THEN
					IF xStopProcess THEN
					(* activ stop immediat *)
						T_Process.xStop:=TRUE;
						T_Process.xStopCycle:=NOT T_Process.xStop;
						xBlockConfirmMessage:=TRUE;
						(* Display info message *)
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=122;	(* Stop process immediately *)
						(* set variable *)
						xStopImmediatly:=TRUE;
						(* next step *)
						iStepAction:=20;
					END_IF;
					IF xAction_StopCycle THEN
						T_Process.xStopCycle:=TRUE;
						T_Process.xStop:=NOT T_Process.xStopCycle;
						xBlockConfirmMessage:=TRUE;
						(* Display message *)
						T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=103;	(* Process will be stopped at the end of the cycle *)
						(* next step *)
						iStepAction:=20;
					END_IF;
				(* not ready to execute stop *)
				ELSE iStepAction:=95; END_IF
			END_IF
			IF T_Process.xError THEN iStepAction:=99; END_IF
		(* waiting function done *)
		20:	IF T_Visu.T_CtrleVisu.xDone THEN
				IF (T_Visu.T_PlcParam.dwActualPage = 10) OR (T_Visu.T_PlcParam.dwActualPage = 20) OR (T_Visu.T_PlcParam.dwActualPage = 30) OR (T_Visu.T_PlcParam.dwActualPage = 110) THEN
					xWaitStopEnd:=xStopProcess;
					xWaitStopCycleEnd:=xAction_StopCycle;
					iStepWaitStopEnd:=1;
				ELSE
					xWaitStopEnd:=FALSE;
					xWaitStopCycleEnd:=FALSE;
				END_IF;
				(* no activ station for machine level *)
				IF T_Visu.T_PlcParam.dwActualPage < 100 THEN
					T_Visu.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
				END_IF
				(* next step *)
				iStepAction:=90;
			END_IF
			IF T_Visu.T_CtrleVisu.xErr THEN iStepAction:=99; END_IF
		(* End function *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=16#0;
			xStopProcess:=FALSE;
			xAction_StopCycle:=FALSE;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xStopProcess:=FALSE;
			xAction_StopCycle:=FALSE;
		(* Error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xStopProcess:=FALSE;
			xAction_StopCycle:=FALSE;
		END_CASE
	END_IF

(* Wait End of Stop Machine Process *)
	IF xWaitStopEnd OR xWaitStopCycleEnd THEN
		CASE iStepWaitStopEnd OF
			1:	IF T_Process.xEnd THEN
					iStepWaitStopEnd:=10;
				END_IF;
				IF T_Process.xError THEN
					xWaitStopEnd:=FALSE;
					xWaitStopCycleEnd:=FALSE;
					iStepWaitStopEnd:=1;
				END_IF;
			10:	IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					T_Visu.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
					IF (T_Process.iFunctNr = 30) THEN
						T_StartUp.T_Ctrle.xExecute:=TRUE;
						T_StartUp.T_Ctrle.iFunction:=11;	(* Acitvate Info Message Overlay *)
						(* THE REFERENCE DRIVE IS STOPPED! *)
						(* CONFIRM THIS MESSAGE AND *)
						(* THE MACHINE WILL BE READY! *)
						(*  *)
						T_StartUp.T_Ctrle.iMsgNumber:=5;
					END_IF;
					IF (T_Process.iFunctNr = 10) OR (T_Process.iFunctNr = 20) THEN
						T_StartUp.T_Ctrle.xExecute:=TRUE;
						T_StartUp.T_Ctrle.iFunction:=11;	(* Acitvate Info Message Overlay *)
						(* THE AUTO MODE CYCLE IS STOPPED! *)
						(* CONFIRM THIS MESSAGE AND *)
						(* THE MACHINE WILL BE READY! *)
						(*  *)
						T_StartUp.T_Ctrle.iMsgNumber:=4;
					END_IF;
					xWaitStopEnd:=FALSE;
					xWaitStopCycleEnd:=FALSE;
					iStepWaitStopEnd:=1;
				END_IF;
		END_CASE;
	END_IF;
(************************************************************************************************************************************************************************)
(***************                                             end for the section for defined function of the visualisation interface                                                ********************)
(************************************************************************************************************************************************************************)

(************************************************************************************************************************************************************************)
(***************                                                 management for the changement of a page on the visualisation                                                 ********************)
(************************************************************************************************************************************************************************)
(* waiting for changing page *)
	RisingEdgeExecute(CLK:=T_Visu.T_CtrleVisu.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_Visu.T_CtrleVisu.iFunction OF
		(* change page *)
		1:	xChangePage:=TRUE;
			dwInCount_QVisCmd:=T_CtrleQVis.dwInCount;
		ELSE
		(* function not implemented *)
			T_Visu.T_CtrleVisu.xDone:=FALSE;
			T_Visu.T_CtrleVisu.xErr:=TRUE;
			T_Visu.T_CtrleVisu.udiErrorID:=16#F000;
		END_CASE
		(* Init. variable *)
		T_Visu.T_CtrleVisu.xDone:=FALSE;
		T_Visu.T_CtrleVisu.xErr:=FALSE;
		T_Visu.T_CtrleVisu.udiErrorID:=0;
		(* exit FB *)
		RETURN;
	END_IF

(* waiting for changing page from the PLC *)
	IF xChangePage THEN
		IF dwInCount_QVisCmd = T_CtrleQVis.dwInCount THEN
			(* Init. command *)
			T_CtrleQVis.dwInCommand:=1;
			T_CtrleQVis.dwInQVisCtrlAddress:=ADR(T_CtrleQVis);
			T_CtrleQVis.dwInParameterAddress:=ADR(T_Visu.T_PlcParam.dwSetNewPage);
			(* start command *)
			T_CtrleQVis.dwInCount:=T_CtrleQVis.dwInCount+1;
		ELSE
			IF T_CtrleQVis.dwInCount = T_CtrleQVis.dwOutCount THEN
			(* command done *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				IF T_CtrleQVis.diOutStatus = 0 THEN
				(* command done without error *)
					T_Visu.T_CtrleVisu.xDone:=TRUE;
					T_Visu.T_CtrleVisu.xErr:=FALSE;
					T_Visu.T_CtrleVisu.udiErrorID:=0;
					(* update value *)
					T_Visu.T_PlcParam.dwPreviousPage:=T_Visu.T_PlcParam.dwActualPage;
					T_Visu.T_PlcParam.dwActualPage:=T_Visu.T_PlcParam.dwSetNewPage;
					IF (T_Visu.T_PlcParam.dwActualPage = 10) THEN
						wNormalLayerActivTask:=1;
						wNormalLayerActivPage:=10;
					END_IF;
				ELSE
				(* command done with error *)
					T_Visu.T_CtrleVisu.xDone:=FALSE;
					T_Visu.T_CtrleVisu.xErr:=TRUE;
					T_Visu.T_CtrleVisu.udiErrorID:=16#F400 + DINT_TO_UDINT(T_CtrleQVis.diOutStatus);
				END_IF
				(* reset variable 'xChangePage' *)
				xChangePage:=FALSE;
			END_IF
		END_IF
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBQVIS_CLEARERROR
VAR_INPUT
	xExecute:BOOL;				(* quit the error *)
	iError:INT;					(* occured error number *)
END_VAR
VAR_IN_OUT
	T_Message:ST_EXCHG_MESSAGE;		(* data structure for the message handling *)
	T_Station:ST_STATION;				(* data structure for the stationlevel *)
	T_Process : ST_PROCESS;			(* data structure for the processlevel *)
	T_NovRAM:ST_NOVRAM;				(* data structure for the Novram *)
	T_Profile:ST_PROFILE;				(* data structure for the profile management *)
	T_HDD:ST_HDD;						(* data structure for the file management *)
END_VAR
VAR_OUTPUT
	xDone:BOOL;
	xNotReady:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_VAR
VAR
(* Trigger *)
	RisingEdgeExecute:R_TRIG;
(* Pointer *)
	ptrActivStation:POINTER TO ST_STATION;
(* Variable *)
	xClearError_Done:BOOL;
	xClearError_Err:BOOL;
	xClearError_NotReady:BOOL;
	xStepClearDone:BOOL;
	udiClearError_ErrorID:UDINT;
	iStepClearErrorStation:INT;
	iStepClearErrorMachine:INT;
	iStepClearStandardError: INT;
	xClearProcess:BOOL;
	xClearStation:BOOL;
	xClearStandardError:BOOL;
	xClearConifgErrStation: BOOL;
	xTmp: BOOL;
	xClearAxis: BOOL;
	iStepClearErrorAxis: INT;
	xTmp1: BOOL;
	xActiveMicroRod: BOOL;
	iTryAgain: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********              This Functionblock manage an occured machine error so that the right component are quittet              ************)
(****************************************************************************************************************************************************)
	IF (T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigMachineType = 2) THEN
		xActiveMicroRod:=TRUE;
	ELSE
		xActiveMicroRod:=FALSE;
	END_IF;

	RisingEdgeExecute(CLK:=xExecute);
	IF RisingEdgeExecute.Q THEN
	(* Init. variable by start clear error *)
		(* ...output *)
		xDone:=FALSE;
		xNotReady:=FALSE;
		xErr:=FALSE;
		udiErrorID:=16#0;
		(* ...variable *)
		xClearError_Done:=FALSE;
		xClearError_Err:=FALSE;
		xClearError_NotReady:=FALSE;
		xStepClearDone:=FALSE;
		iStepClearErrorStation:=1;
		iStepClearErrorMachine:=1;
		iStepClearStandardError:=1;
		iStepClearErrorAxis:=1;
		(* determin clear action *)
		xClearProcess:=xClearStation:=xClearAxis:=xClearStandardError:=FALSE;
		xClearConifgErrStation:=FALSE;
		IF T_Process.xError THEN
			xClearProcess:=TRUE;
		ELSE
			IF T_Station.TControl.xError AND NOT(T_Station.TControl.xEnd) THEN ptrActivStation:=ADR(T_Station); xClearStation:=TRUE; END_IF
			xTmp:=	(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr OR
					(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xActiveMicroRod) OR
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr OR
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr OR
					T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr) AND
					NOT(xClearStation);
			IF xTmp THEN
				xClearAxis:=TRUE;
			END_IF;
			IF T_Station.TControl.xError AND T_Station.TControl.xEnd AND NOT(xClearAxis) THEN
				xClearConifgErrStation:=TRUE;
			END_IF
		END_IF
		IF NOT xClearProcess AND NOT xClearStation AND NOT xClearConifgErrStation AND NOT xClearAxis THEN xClearStandardError:=TRUE; END_IF
		(* Exit FB *)
		RETURN;
	END_IF

	IF xClearProcess THEN
	(* Reset Error machine *)
		CASE iStepClearErrorMachine OF
		(* check station *)
		1:	IF T_Process.xError THEN iStepClearErrorMachine:=10; ELSE iStepClearErrorMachine:=90; END_IF
		(* activ clear error *)
		10:	T_Process.xQuitError:=TRUE;
			(* next step *)
			iStepClearErrorMachine:=20;
			xStepClearDone:=FALSE;
		(* waiting end clearing error *)
		20:	IF NOT T_Process.xQuitError THEN
				iStepClearErrorMachine:=90;
				xStepClearDone:=FALSE;
			END_IF
			IF T_Process.xError THEN iStepClearErrorMachine:=90; END_IF
		(* Clear error station done *)
		90:	xClearError_Done:=TRUE;
		(* Error *)
		99:	xClearError_Err:=TRUE;
		END_CASE
	END_IF

	IF xClearStation THEN
	(* Reset Error station *)
		CASE iStepClearErrorStation OF
		(* check station *)
		1:	IF ptrActivStation^.TControl.xError THEN iStepClearErrorStation:=10;
			ELSE IStepClearErrorStation:=90; END_IF
		(* activ clear error *)
		10:	ptrActivStation^.TControl.xQuitError:=TRUE;
			(* next step *)
			iStepClearErrorStation:=20;
			xStepClearDone:=FALSE;
		(* waiting end clearing error *)
		20:	IF NOT(xStepClearDone) THEN
			(* release action *)
				ptrActivStation^.TControl.xQuitError:=FALSE;
				xStepClearDone:=TRUE;
			ELSE
				IF ptrActivStation^.TControl.xEnd THEN
				(* confirm clear error, next step *)
					iStepClearErrorStation:=90;
					xStepClearDone:=FALSE;
				END_IF
				IF ptrActivStation^.TControl.xError THEN iStepClearErrorStation:=99; END_IF
			END_IF
		(* Clear error station done *)
		90:	xClearError_Done:=TRUE;
		(* Error *)
		99:	xClearError_Done:=TRUE;
		END_CASE
	END_IF

	IF xClearConifgErrStation THEN
		T_Station.TControl.xError:=FALSE;
		xClearConifgErrStation:=FALSE;
		(* Clear error station done *)
		xClearError_Done:=TRUE;
	END_IF;

	IF xClearAxis THEN
	(* Reset Error axis *)
		CASE iStepClearErrorAxis OF
		(* check station *)
		1:	xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr OR
					(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xActiveMicroRod) OR
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr OR
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr OR
					T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr;
			IF xTmp THEN iStepClearErrorAxis:=10;
			ELSE iStepClearErrorAxis:=90; END_IF
			iTryAgain:=0;
		(* activ clear error *)
		10:	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr;
			IF xActiveMicroRod THEN
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=1;
				T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr;
			END_IF;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
			T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr;
			(* next step *)
			iStepClearErrorAxis:=20;
			xStepClearDone:=FALSE;
		(* waiting end clearing error *)
		20:	IF NOT(xStepClearDone) THEN
			(* release action *)
				xStepClearDone:=TRUE;
			ELSE
				xTmp:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone AND
						((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone AND xActiveMicroRod) OR NOT(xActiveMicroRod)) AND
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone AND
						T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone;
				xTmp1:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr OR
						(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xActiveMicroRod) OR
						T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr OR
						T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr OR
						T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr;
				IF xTmp THEN
				(* confirm clear error, next step *)
					iStepClearErrorAxis:=90;
					xStepClearDone:=FALSE;
				END_IF
				IF xTmp1 THEN
					iTryAgain:=iTryAgain + 1;
					IF (iTryAgain <= 3) THEN
						(* Reset maximal three times *)
						iStepClearErrorAxis:=10;
					ELSE
						iStepClearErrorAxis:=99;
					END_IF;
				END_IF

			END_IF
		(* Clear error station done *)
		90:	xClearError_Done:=TRUE;
		(* Error *)
		99:	xClearError_Done:=TRUE;
		END_CASE;
	END_IF;

	IF xClearStandardError THEN
	(* Reset Error standard *)
		CASE iStepClearStandardError OF
		(* check NovRAM state *)
		1:	iStepClearStandardError:=10;
			IF T_NovRAM.T_Ctrle.xErr THEN T_NovRAM.T_Ctrle.xReset:=TRUE; END_IF
		(* check Profile State *)
		10:	iStepClearStandardError:=20;
			IF T_Profile.T_Ctrle.xErr THEN T_Profile.T_Ctrle.xReset:=TRUE; END_IF
		(* check HDD state *)
		20:	iStepClearStandardError:=90;
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; END_IF
		(* Clear error station done *)
		90:	xClearError_Done:=TRUE;
		END_CASE
	END_IF

(* FB Done/Err/NotReady *)
	IF xClearError_Done OR xClearError_Err OR xClearError_NotReady THEN
	(* copy value *)
		T_Message.iState:=0;
		T_Message.sDynamicTextEnglish:='';
		T_Message.sDynamicTextDeutsch:='';
		T_Message.sDynamicTextFrancais:='';
		xDone:=xClearError_Done;
		xNotReady:=xClearError_NotReady;
		xErr:=FALSE;
		udiErrorID:=udiClearError_ErrorID;
		(* Init. function state *)
		xClearProcess:=FALSE;
		xClearStation:=FALSE;
		xClearAxis:=FALSE;
		xClearStandardError:=FALSE;
		xClearConifgErrStation:=FALSE;
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBQVIS_ERROR_LIST
VAR_INPUT
	T_ErrorList:ST_ERROR_LIST;					(* Static define Error List *)
	T_ErrorNrList:ST_RETAIN_ERROR_DATA;		(* Daten welche im NOVram abgelegt sind *)
END_VAR
VAR_IN_OUT
	T_MsgErrorEnglish:ST_EXCHG_MESSAGE_ERROR;	(* Daten die auf der Visu in der Errorliste visualisiert werden *)
	T_MsgErrorDeutsch:ST_EXCHG_MESSAGE_ERROR;	(* Daten die auf der Visu in der Errorliste visualisiert werden *)
	T_MsgErrorFrancais:ST_EXCHG_MESSAGE_ERROR;	(* Daten die auf der Visu in der Errorliste visualisiert werden *)
END_VAR
VAR_OUTPUT
END_VAR
VAR
	FBErrorMessage:FB_ErrorMessage;
	ii:INT;
	diErrorNr: DINT;
	sErrorTimeStamp: STRING(12);
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                              This Functionblock fills the errorlist with the errormesse and the timestamp                                  ************)
(****************************************************************************************************************************************************)
	FOR ii:=1 TO 20 DO
		diErrorNr:=T_ErrorNrList.adiErrorListMachine[ii];
		sErrorTimeStamp:=T_ErrorNrList.asErrorTimeStampMachine[ii];
		sErrorTimeStamp:=CONCAT(sErrorTimeStamp,'--');
		IF (diErrorNr <> 0) THEN
			FBErrorMessage(	diErrorNr:=diErrorNr ,
							T_ErrorList:=T_ErrorList);
			T_MsgErrorEnglish.asMsgErrorList[ii]:=CONCAT(sErrorTimeStamp,FBErrorMessage.sErrorTextEnglish);
			T_MsgErrorDeutsch.asMsgErrorList[ii]:=CONCAT(sErrorTimeStamp,FBErrorMessage.sErrorTextDeutsch);
			T_MsgErrorFrancais.asMsgErrorList[ii]:=CONCAT(sErrorTimeStamp,FBErrorMessage.sErrorTextFrancais);
		ELSE
			T_MsgErrorEnglish.asMsgErrorList[ii]:='                                                                    ';
			T_MsgErrorDeutsch.asMsgErrorList[ii]:='                                                                    ';
			T_MsgErrorFrancais.asMsgErrorList[ii]:='                                                                    ';
		END_IF;
	END_FOR;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBQVIS_INITPAGE
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Visu:ST_QVIS;			(* data structure of the visualisation *)
END_VAR
VAR
(* pointer *)
	ptrConfigPage: POINTER TO ST_CONFIGPAGE;
(* variable *)
	iIndexPage:INT;
	iPageNumber:INT;
(* variable Tmp *)
	i:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                    This Functionblock init all the defined page in QVis for the hole page management                            ************)
(****************************************************************************************************************************************************)
(* init. index array *)
FOR i:=0 TO 999 DO
	T_Visu.T_PageIndex[i].iIndexConfigPage:=0;
END_FOR
(* init. Number Page *)
iPageNumber:=0;

(* QVis page 0, start page *)
iIndexPage:=0;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Start page';
ptrConfigPage^.wMaskBtPanelLeft:=16#0;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#0;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=0;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=FALSE;

(* QVis page 1, BIOS Password StartUp *)
iIndexPage:=1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='BIOS Password StartUp';
ptrConfigPage^.wMaskBtPanelLeft:=16#0;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#0;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=0;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=FALSE;

(* QVis page 2, BIOS Parameter StartUp *)
iIndexPage:=2;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='BIOS Parameter StartUp';
ptrConfigPage^.wMaskBtPanelLeft:=16#0;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#0;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#200;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=0;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=FALSE;

(* QVis page 10, Auto Geometry, page 1 *)
iIndexPage:=10;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Auto Geometry, page 1';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
(*08.07.2014: KFS	{	*)
(*ptrConfigPage^.wMaskFunctionPanel:=16#F;*)
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(*08.07.2014: KFS	}	*)
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#F;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#220;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=801;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=102;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=103;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=106;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=107;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=108;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 11, Auto Geometry, page 2 *)
iIndexPage:=11;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Auto Geometry, page 2';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#EF;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=110;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=111;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=114;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=115;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=116;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=112;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=113;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 20, Auto Groove, page 1 *)
iIndexPage:=20;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Auto Groove, page 1';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#F;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#200;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=102;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=103;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=105;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=107;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=104;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 21, Auto Groove, page 2 *)
iIndexPage:=21;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Auto Groove, page 2';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#EF;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=110;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=111;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=114;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=115;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=116;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=112;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=113;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 30, Reference *)
iIndexPage:=30;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Reference';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#D;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#F;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#60;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=312;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=310;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=316;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=314;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=320;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=106;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 40, Setup --> change user level *)
iIndexPage:=40;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Setup --> change user level';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#200;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 41, Setup --> change language *)
iIndexPage:=41;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Setup --> change language';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#200;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 50, Axis informations *)
iIndexPage:=50;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Axis informations';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#200;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 51, System informations *)
iIndexPage:=51;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='System informations';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#200;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=12;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 60, Error List *)
iIndexPage:=60;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Error List';
ptrConfigPage^.wMaskBtPanelLeft:=16#F;
ptrConfigPage^.wMaskBtPanelRight:=16#60;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#60;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=20;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10010;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10020;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10030;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10040;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10050;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10060;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 110, Tool Calibration *)
iIndexPage:=110;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Tool Calibration';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#F;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=102;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=103;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=132;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=105;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=101;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 120, Tool Geometry *)
iIndexPage:=120;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Tool Geometry';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=201;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=202;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=203;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=204;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=205;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=1005;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 130, Profile *)
iIndexPage:=130;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Profile';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=1002;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=1003;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=1004;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 140, General Setup *)
iIndexPage:=140;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='General Setup';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 150, Configuration *)
iIndexPage:=150;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Configuration';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 160, Error List *)
iIndexPage:=160;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Error List';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#60;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#60;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=20;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 170, Parameter General *)
iIndexPage:=170;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Parameter General';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#3F;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1006;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10110;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10120;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10130;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=10140;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=10150;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10160;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 210, Teach-in Tool Rotation *)
iIndexPage:=210;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Teach-in Tool Rotation';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=312;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=310;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=316;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=314;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=322;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=323;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=321;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=320;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10210;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10220;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10230;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10260;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 220, Tool Torque *)
iIndexPage:=220;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Tool Torque';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#DF;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#DF;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=502;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=503;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=130;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=131;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=504;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=505;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10210;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10220;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10230;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10260;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 230, Tool Tension *)
iIndexPage:=230;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Tool Tension';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#20;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=501;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10210;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10220;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10230;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10260;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 260, Error List *)
iIndexPage:=260;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Error List';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#60;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#60;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=20;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10210;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10220;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10230;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10260;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 270, Parameter Tool Rotation *)
iIndexPage:=270;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Parameter Tool Rotation';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1006;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10210;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10220;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10230;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10260;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 310, Teach-in Wire Feeder *)
iIndexPage:=310;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Teach-in Wire Feeder';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=312;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=310;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=316;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=314;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=322;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=323;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=324;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=320;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=325;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10310;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10320;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10330;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10360;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 320, Setting-up *)
iIndexPage:=320;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Setting-up';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#60;
ptrConfigPage^.wMaskFunctionPanel:=16#F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=312;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=310;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=316;
ptrConfigPage^.aiDelayActionPanelRight[2]:=314;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=322;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=323;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=326;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=320;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10310;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10320;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10330;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10360;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 330, ReferenceMaxToolLength *)
iIndexPage:=330;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Reference max ToolLength';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#1B;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=312;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=310;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=316;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=314;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=322;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=323;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=320;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=501;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10310;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10320;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10330;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10360;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 360, Error List *)
iIndexPage:=360;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Error List';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#60;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#60;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=20;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10310;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10320;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10330;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10360;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 370, Parameter Wire Feeder *)
iIndexPage:=370;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Parameter Wire Feeder';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1006;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10310;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10320;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10330;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10360;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 410, Teach-in Grind Axis *)
iIndexPage:=410;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Teach-in Grind Axis';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#2B;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=312;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=310;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=316;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=314;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=301;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=322;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=323;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=320;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=325;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10410;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10420;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10430;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10460;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 420, Tool Diameter *)
iIndexPage:=420;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Tool Diameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#EF;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=110;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=111;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=114;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=115;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=116;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=112;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=113;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10410;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10420;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10430;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10460;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 430, Prism *)
iIndexPage:=430;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Prism';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=120;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=115;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=1005;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10410;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10420;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10430;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10460;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 460, Error List *)
iIndexPage:=460;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Error List';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#60;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#60;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=20;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10410;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10420;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10430;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10460;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;

(* QVis page 470, Parameter Grind Axis *)
iIndexPage:=470;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Parameter Grind Axis';
ptrConfigPage^.wMaskBtPanelLeft:=16#1F;
ptrConfigPage^.wMaskBtPanelRight:=16#200;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#27;
(* Active machine movement mask *)
ptrConfigPage^.wMaskActiveMachineBtPanelLeft:=16#0;
ptrConfigPage^.wMaskActiveMachineBtPanelRight:=16#0;
ptrConfigPage^.wMaskActiveMachineFunctionPanel:=16#0;
ptrConfigPage^.wMaskActiveMachineNavPanel:=16#27;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1006;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiDelayActionPanelRight[1]:=0;
ptrConfigPage^.aiDelayActionPanelRight[2]:=0;
ptrConfigPage^.aiDelayActionPanelRight[3]:=0;
ptrConfigPage^.aiDelayActionPanelRight[4]:=0;
ptrConfigPage^.aiDelayActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[1]:=10410;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[2]:=10420;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[3]:=10430;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[4]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[5]:=0;
ptrConfigPage^.aiFTrigActionTouchScreenNavPanel[6]:=10460;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION iFctExistProfileName : INT
VAR_INPUT
	sProfileName:STRING(30);											(* name of the profile, which will be saved *)
	ptrProfileList:POINTER TO ARRAY[1..csiMaxProfile] OF ST_PROFILE_ID;	(* list of profil names which are saved *)
END_VAR
VAR
	i:INT;
	sTmp:STRING;
	sTmp2:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                               This Function check if the name of the profile already exists                                              ************)
(****************************************************************************************************************************************************)
(* Init. function *)
	iFctExistProfileName:=0;
	sTmp:=FCT_UPLOW_CASE(	xLowConvert:=TRUE,
							sInString:=sProfileName);

(* Search if name already exists *)
	FOR i:=1 TO csiMaxProfile DO
		sTmp2:=	FCT_UPLOW_CASE(	xLowConvert:=TRUE,
								sInString:=ptrProfileList^[i].sName);
		IF sTmp = sTmp2 AND sTmp2 <> '' THEN iFctExistProfileName:=i; RETURN; END_IF
	END_FOR

END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION iFctGetEditParaList : INT
VAR_INPUT
	dwActualPage:DWORD;		(* activate page on the visualisation *)
	xMicroRodActive: BOOL;		(* choice of the machine MicroWire or MicroRod *)
	iSelectParaList:INT;			(* parameter list choiced on the QVis *)
	iSelectParaListTeachRot:INT;	(* parameter list choiced on the QVis for teach ToolRotation *)
END_VAR
VAR
	iTmpRetEditParaList: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********          This Function check the state of the parameter level and give the number of the parameter list                ************)
(****************************************************************************************************************************************************)
iTmpRetEditParaList:=0;
CASE dwActualPage OF
	110:	IF xMicroRodActive THEN
			iTmpRetEditParaList:=111;
		ELSE
			iTmpRetEditParaList:=110;
		END_IF;
	120:	IF (iSelectParaList = 0) OR (iSelectParaList = 1) THEN
			IF xMicroRodActive THEN
				iTmpRetEditParaList:=123;
			ELSE
				iTmpRetEditParaList:=120;
			END_IF;
		END_IF;
		IF (iSelectParaList = 2) THEN
			iTmpRetEditParaList:=121;
		END_IF;
		IF (iSelectParaList = 3) THEN
			IF xMicroRodActive THEN
				iTmpRetEditParaList:=125;
			ELSE
				iTmpRetEditParaList:=122;
			END_IF;
		END_IF;
	130:	IF xMicroRodActive THEN
			iTmpRetEditParaList:=131;
		ELSE
			iTmpRetEditParaList:=130;
		END_IF;
	140:	iTmpRetEditParaList:=140;
	150:	iTmpRetEditParaList:=150;
	210:	IF (iSelectParaListTeachRot = 0) OR (iSelectParaListTeachRot = 1) THEN
			iTmpRetEditParaList:=210;
		END_IF;
		IF (iSelectParaListTeachRot = 2) THEN
			iTmpRetEditParaList:=211;
		END_IF;
		IF (iSelectParaListTeachRot = 3) THEN
			iTmpRetEditParaList:=212;
		END_IF;
	220:	iTmpRetEditParaList:=0;
	230:	iTmpRetEditParaList:=230;
	310:IF xMicroRodActive THEN
			iTmpRetEditParaList:=311;
		ELSE
			iTmpRetEditParaList:=310;
		END_IF;
	320:	iTmpRetEditParaList:=0;
	410:	iTmpRetEditParaList:=410;
	420:	iTmpRetEditParaList:=0;
	430:	iTmpRetEditParaList:=0;
END_CASE;
iFctGetEditParaList:=iTmpRetEditParaList;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION iFctReturnConfMessage : INT
VAR_INPUT
	iNumAction:INT;	(* number of called action on the visualisation *)
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                      This Function check the action on the visu and gives a correspond message number                     ************)
(****************************************************************************************************************************************************)
	CASE iNumAction OF
	(* Action exceeded Timeout *)
	-1:	iFctReturnConfMessage:=102;
	(* NovRAM, 'Parameter saved' with confirmation *)
	1005:	iFctReturnConfMessage:=1;
	(* NovRAM, 'Parameter saved' without confirmation *)
	1006:	iFctReturnConfMessage:=1;
	(* Reference machine done *)
	1110:	iFctReturnConfMessage:=23;
	(* Process machine done *)
	1150:	iFctReturnConfMessage:=21;
	(* Process station done *)
	1151..1153:	iFctReturnConfMessage:=22;
	(* change page, no message *)
	10001..10999:	iFctReturnConfMessage:=0;
	(* Info , 'Confirm action' *)
	ELSE	iFctReturnConfMessage:=2;
	END_CASE
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION rFctCalcMaxToolDiameter : REAL
VAR_INPUT
	rDistanceD1:REAL;		(* distance d1 of the prisma *)
	rDistanceD2:REAL;		(* distance d2 of the prisma *)
	rAnglePrism:REAL;		(* angle of the prisma *)
END_VAR
VAR
	rTmp: REAL;
	rTmpMaxDia: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                    This Function calculate the maximum of the tooldiameter in case of the settled prisma                      ************)
(****************************************************************************************************************************************************)
rTmp:=SIN((90 - rAnglePrism/2) * PI/180);
IF rTmp <> 0 THEN
	rTmpMaxDia:=rDistanceD1/rTmp;
ELSE
	rTmpMaxDia:=0;
END_IF;
rFctCalcMaxToolDiameter:=rTmpMaxDia;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION rFctCalcMinToolDiameter : REAL
VAR_INPUT
	rDistanceD1:REAL;		(* distance d1 of the prisma *)
	rDistanceD2:REAL;		(* distance d2 of the prisma *)
	rAnglePrism:REAL;		(* angle of the prisma *)
	bStateInputPrisma:BYTE;	(* choice of selected prisma *)
END_VAR
VAR
	rTmp: REAL;
	rTmp1: REAL;
	rMinD1_1: REAL;
	rMinD1_2: REAL;
	rReturnValue: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                    This Function calculate the minimum of the tooldiameter in case of the settled prisma                      ************)
(****************************************************************************************************************************************************)
rFctCalcMinToolDiameter:=0;
rTmp:=TAN((rAnglePrism/2)*PI/180);
rTmp1:=SIN((rAnglePrism/2)*PI/180);
IF (rTmp <> 0) AND (rTmp1 <> 0) THEN
	rMinD1_1:=rDistanceD1/(rTmp * (1 + 1/rTmp1));
END_IF;
rMinD1_2:=rDistanceD2;
IF (bStateInputPrisma = 0) OR (bStateInputPrisma = 1) THEN
	IF (rMinD1_1 >= rMinD1_2) THEN
		rReturnValue:=rMinD1_1;
	ELSE
		rReturnValue:=rMinD1_2;
	END_IF;
ELSE
	rReturnValue:=rMinD1_1;
END_IF;
rFctCalcMinToolDiameter:=rReturnValue;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION rFctCalcPrismaFactor : REAL
VAR_INPUT
	rAnglePrism:REAL;	(* angle of the prisma *)
END_VAR
VAR
	rFactorPrisma: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********     This Function calculate the correctur factor for the GrindFeeder Axis dependent of the settled prisma         ************)
(****************************************************************************************************************************************************)
rFctCalcPrismaFactor:=0.0;
rFactorPrisma:=(1 + SIN((rAnglePrism / 2.0) * PI/180)) / (2.0 * SIN((rAnglePrism / 2.0) * PI / 180.0));
(* Auf 5 Kommastellen runden *)
rFactorPrisma:=	STRING_TO_REAL(	LREAL_TO_FMTSTR(	in:=rFactorPrisma,
														iPrecision:=5,
														bRound:=TRUE));

rFctCalcPrismaFactor:=rFactorPrisma;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctCopyDataFileToProfile : BOOL
VAR_INPUT
	ptrData_ProcessImageLoadData:POINTER TO ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram parameter structure for the profile value *)
	ptrDataFile:POINTER TO ARRAY[1..csiMaxFileLine] OF STRING(255);					(* structure of the data file *)
END_VAR
VAR
(* variable *)
	i:INT;
	iPosStartCarValue:INT;
	iPosStopCarValue:INT;
	sValue:STRING;
	sVariableName:STRING;
(* Tmp variable *)
	sTmp:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                     This Function make a copy from the readed profil parameter to the profile structure                           ************)
(****************************************************************************************************************************************************)
(* Init. variable *)
	xFctCopyDataFileToProfile:=FALSE;

(* copy value *)
	FOR i:= 1 TO csiMaxFileLine DO
		sTmp:=ptrDataFile^[i];
		IF FIND(sTmp,':=') <> 0 THEN
		(* read value *)
			iPosStartCarValue:= FIND(sTmp,':=')+2;
			iPosStopCarValue:= FIND(sTmp,';');
			sValue:=MID(sTmp,iPosStopCarValue - iPosStartCarValue,iPosStartCarValue);
		(* read variable name *)
			iPosStartCarValue:= FIND(sTmp,':')+1;
			iPosStopCarValue:= FIND(sTmp,':=');
			sVariableName:=FCT_UPLOW_CASE(	xLowConvert:=TRUE,
												sInString:=MID(sTmp,iPosStopCarValue - iPosStartCarValue,iPosStartCarValue));
			(* Value *)
				IF sVariableName = 'rstartdiameters1' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arStartDiameter[1]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'renddiameters1' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arEndDiameter[1]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rlengths1' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionLength[1]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rpitchs1' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionPitch[1]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'ractives1' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[1]:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[1]:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rstartdiameters2' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arStartDiameter[2]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'renddiameters2' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arEndDiameter[2]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rlengths2' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionLength[2]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rpitchs2' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionPitch[2]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'ractives2' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[2]:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[2]:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rstartdiameters3' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arStartDiameter[3]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'renddiameters3' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arEndDiameter[3]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rlengths3' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionLength[3]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rpitchs3' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionPitch[3]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'ractives3' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[3]:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[3]:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rstartdiameters4' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arStartDiameter[4]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'renddiameters4' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arEndDiameter[4]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rlengths4' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionLength[4]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rpitchs4' THEN ptrData_ProcessImageLoadData^.T_GeometryPara.arSectionPitch[4]:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'ractives4' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[4]:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_GeometryPara.axActiveSection[4]:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rprismadistanced1' THEN ptrData_ProcessImageLoadData^.T_PrismPara.rPrismaDistanceD1:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rprismadistanced2' THEN ptrData_ProcessImageLoadData^.T_PrismPara.rPrismaDistanceD2:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rprismaanglea' THEN ptrData_ProcessImageLoadData^.T_PrismPara.rPrismaAngleA:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'bstateinputprisma' THEN ptrData_ProcessImageLoadData^.T_PrismPara.bStateInputPrisma:=STRING_TO_BYTE(sValue); END_IF;
				IF sVariableName = 'rtooldiametermin' THEN ptrData_ProcessImageLoadData^.T_PrismPara.rToolDiameterMin:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rtooldiametermax' THEN ptrData_ProcessImageLoadData^.T_PrismPara.rToolDiameterMax:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rprismafactor' THEN ptrData_ProcessImageLoadData^.T_PrismPara.rPrismaFactor:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'icyclegeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.iCycleGeometry:=STRING_TO_INT(sValue); END_IF;
				IF sVariableName = 'rplungecyclegrindfeedgeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rdisplacelengthtoolfeedgeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rdisplacespeedgrindfeedgeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungelengthtoolfeedgeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.rPlungeLengthToolFeedGeometry:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungespeedgrindfeedgeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedtoolrotationgeometry' THEN ptrData_ProcessImageLoadData^.T_AutoGeometryPara.rSpeedToolRotationGeometry:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rdisplaceactivationgeometry' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_AutoGeometryPara.xDisplaceActivationGeometry:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_AutoGeometryPara.xDisplaceActivationGeometry:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rplungeactivationgeometry' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_AutoGeometryPara.xPlungeActivationGeometry:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_AutoGeometryPara.xPlungeActivationGeometry:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rdisplacelengthtoolfeedgroove' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.rDisplaceLengthToolFeedGroove:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rdisplacespeedgrindfeedgroove' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rpitchgroove' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.rPitchGroove:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungelengthtoolfeedgroove' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.rPlungeLengthToolFeedGroove:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungespeedgrindfeedgroove' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.rPlungeSpeedGrindFeedGroove:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedtoolrotationgroove' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.rSpeedToolRotationGroove:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'inumberofgrooves' THEN ptrData_ProcessImageLoadData^.T_AutoGroovePara.iNumberOfGrooves:=STRING_TO_INT(sValue); END_IF;
				IF sVariableName = 'rdisplaceactivationgroove' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_AutoGroovePara.xDisplaceActivationGroove:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_AutoGroovePara.xDisplaceActivationGroove:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rplungeactivationgroove' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_AutoGroovePara.xPlungeActivationGroove:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_AutoGroovePara.xPlungeActivationGroove:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rblockgrindfeeder' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_AutoGroovePara.xBlockGrindFeeder:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_AutoGroovePara.xBlockGrindFeeder:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rdisplacelengthtoolfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rDisplaceLengthToolFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rdisplacespeedgrindfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rDisplaceSpeedGrindFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rmeasureoffsettoolfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rMeasureOffsetToolFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rmeasurepostoolfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rMeasurePosToolFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rpitchcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rPitchCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungelengthgrindfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rPlungeLengthGrindFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungelengthtoolfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rPlungeLengthToolFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rplungespeedgrindfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rPlungeSpeedGrindFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedtoolrotationcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rSpeedToolRotationCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rstartpostoolfeedcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rStartPosToolFeedCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rtoollengthcylinderpartcalib' THEN ptrData_ProcessImageLoadData^.T_CalibrationPara.rToolLengthCylinderPartCalib:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rdisplaceactivationcalib' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_CalibrationPara.xDisplaceActivationCalib:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_CalibrationPara.xDisplaceActivationCalib:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'rplungeactivationcalib' THEN
					IF (STRING_TO_REAL(sValue) = 0) THEN
						ptrData_ProcessImageLoadData^.T_CalibrationPara.xPlungeActivationCalib:=FALSE;
					ELSE
						ptrData_ProcessImageLoadData^.T_CalibrationPara.xPlungeActivationCalib:=TRUE;
					END_IF;
				END_IF;
				IF sVariableName = 'roffsetbeforetooldiagrindfeedprocess' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rsecurityposgrindfeedprocess' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rSecurityPosGrindFeedProcess:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedbackwardgrindfeed' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rSpeedBackwardGrindFeed:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedforwardfastgrindfeed' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rSpeedForwardFastGrindFeed:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedforwardslowgrindfeed' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rSpeedForwardSlowGrindFeed:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rspeedstartpostoolfeedprocess' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rSpeedStartPosToolFeedProcess:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rstartpostoolfeedauto' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rStartPosToolFeedAuto:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rtooldiameterprocess' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rToolDiameterProcess:=STRING_TO_REAL(sValue); END_IF;
				IF sVariableName = 'rtooltensionprocess' THEN ptrData_ProcessImageLoadData^.T_ProcessPara.rToolTensionProcess:=STRING_TO_REAL(sValue); END_IF;
		END_IF
	END_FOR
	(* confirm copy value *)
	xFctCopyDataFileToProfile:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctCopyProfileToDataFile : BOOL
VAR_INPUT
	ptrData_ProcessImageData:POINTER TO ST_RETAIN_DATA_PROCESSIMAGE;	(* Novram parametre structure for the process parameter *)
	ptrDataFile:POINTER TO ARRAY[1..csiMaxFileLine] OF STRING(255);				(* structure of the data file *)
END_VAR
VAR
(* variable *)
	i:INT;
(* Tmp *)
	sTmp:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                     This Function make a copy from the profile structure to the readed profil parameter                           ************)
(****************************************************************************************************************************************************)
(* Init. variable *)
	xFctCopyProfileToDataFile:=FALSE;
	i:=1;

(* copy value *)
	ptrDataFile^[i]:='/* Geometry Section 1 */';i:=i+1;
	sTmp:=CONCAT('01:rStartDiameterS1:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arStartDiameter[1]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('02:rEndDiameterS1:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arEndDiameter[1]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('03:rLengthS1:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionLength[1]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('04:rPitchS1:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionPitch[1]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_GeometryPara.axActiveSection[1] THEN
		sTmp:=CONCAT('05:rActiveS1:=','1');
	ELSE
		sTmp:=CONCAT('05:rActiveS1:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Geometry Section 2 */';i:=i+1;
	sTmp:=CONCAT('06:rStartDiameterS2:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arStartDiameter[2]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('07:rEndDiameterS2:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arEndDiameter[2]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('08:rLengthS2:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionLength[2]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('09:rPitchS2:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionPitch[2]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_GeometryPara.axActiveSection[2] THEN
		sTmp:=CONCAT('10:rActiveS2:=','1');
	ELSE
		sTmp:=CONCAT('10:rActiveS2:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Geometry Section 3 */';i:=i+1;
	sTmp:=CONCAT('11:rStartDiameterS3:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arStartDiameter[3]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('12:rEndDiameterS3:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arEndDiameter[3]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('13:rLengthS3:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionLength[3]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('14:rPitchS3:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionPitch[3]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_GeometryPara.axActiveSection[3] THEN
		sTmp:=CONCAT('15:rActiveS3:=','1');
	ELSE
		sTmp:=CONCAT('15:rActiveS3:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Geometry Section 4 */';i:=i+1;
	sTmp:=CONCAT('16:rStartDiameterS4:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arStartDiameter[4]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('17:rEndDiameterS4:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arEndDiameter[4]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('18:rLengthS4:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionLength[4]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('19:rPitchS4:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_GeometryPara.arSectionPitch[4]));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_GeometryPara.axActiveSection[4] THEN
		sTmp:=CONCAT('20:rActiveS4:=','1');
	ELSE
		sTmp:=CONCAT('20:rActiveS4:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Prism Parameter */';i:=i+1;
	sTmp:=CONCAT('21:rPrismaDistanceD1:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.rPrismaDistanceD1));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('22:rPrismaDistanceD2:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.rPrismaDistanceD2));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('23:rPrismaAngleA:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.rPrismaAngleA));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('24:bStateInputPrisma:=',BYTE_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.bStateInputPrisma));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('25:rToolDiameterMin:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.rToolDiameterMin));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('26:rToolDiameterMax:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.rToolDiameterMax));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('27:rPrismaFactor:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_PrismPara.rPrismaFactor));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Auto Geometry */';i:=i+1;
	sTmp:=CONCAT('28:iCycleGeometry:=',INT_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.iCycleGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('29:rPlungeCycleGrindFeedGeometry:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.rPlungeCycleGrindFeedGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('30:rDisplaceLengthToolFeedGeometry:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.rDisplaceLengthToolFeedGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('31:rDisplaceSpeedGrindFeedGeometry:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.rDisplaceSpeedGrindFeedGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('32:rPlungeLengthToolFeedGeometry:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.rPlungeLengthToolFeedGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('33:rPlungeSpeedGrindFeedGeometry:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.rPlungeSpeedGrindFeedGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('34:rSpeedToolRotationGeometry:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGeometryPara.rSpeedToolRotationGeometry));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_AutoGeometryPara.xDisplaceActivationGeometry THEN
		sTmp:=CONCAT('35:rDisplaceActivationGeometry:=','1');
	ELSE
		sTmp:=CONCAT('35:rDisplaceActivationGeometry:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_AutoGeometryPara.xPlungeActivationGeometry THEN
		sTmp:=CONCAT('36:rPlungeActivationGeometry:=','1');
	ELSE
		sTmp:=CONCAT('36:rPlungeActivationGeometry:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Auto Groove */';i:=i+1;
	sTmp:=CONCAT('37:rDisplaceLengthToolFeedGroove:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.rDisplaceLengthToolFeedGroove));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('38:rDisplaceSpeedGrindFeedGroove:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.rDisplaceSpeedGrindFeedGroove));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('39:rPitchGroove:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.rPitchGroove));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('40:rPlungeLengthToolFeedGroove:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.rPlungeLengthToolFeedGroove));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('41:rPlungeSpeedGrindFeedGroove:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.rPlungeSpeedGrindFeedGroove));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('42:rSpeedToolRotationGroove:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.rSpeedToolRotationGroove));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
(*20091207*)
	sTmp:=CONCAT('43:iNumberOfGrooves:=',INT_TO_STRING(ptrData_ProcessImageData^.T_AutoGroovePara.iNumberOfGrooves));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	IF ptrData_ProcessImageData^.T_AutoGroovePara.xDisplaceActivationGroove THEN
		sTmp:=CONCAT('44:rDisplaceActivationGroove:=','1');
	ELSE
		sTmp:=CONCAT('44:rDisplaceActivationGroove:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_AutoGroovePara.xPlungeActivationGroove THEN
		sTmp:=CONCAT('45:rPlungeActivationGroove:=','1');
	ELSE
		sTmp:=CONCAT('45:rPlungeActivationGroove:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_AutoGroovePara.xBlockGrindFeeder THEN
		sTmp:=CONCAT('46:rBlockGrindFeeder:=','1');
	ELSE
		sTmp:=CONCAT('46:rBlockGrindFeeder:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Calibration */';i:=i+1;
	sTmp:=CONCAT('47:rDisplaceLengthToolFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rDisplaceLengthToolFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('48:rDisplaceSpeedGrindFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rDisplaceSpeedGrindFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('49:rMeasureOffsetToolFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rMeasureOffsetToolFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('50:rMeasurePosToolFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rMeasurePosToolFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('51:rPitchCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rPitchCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('52:rPlungeLengthGrindFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rPlungeLengthGrindFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('53:rPlungeLengthToolFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rPlungeLengthToolFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('54:rPlungeSpeedGrindFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rPlungeSpeedGrindFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('55:rSpeedToolRotationCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rSpeedToolRotationCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('56:rStartPosToolFeedCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rStartPosToolFeedCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('57:rToolLengthCylinderPartCalib:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_CalibrationPara.rToolLengthCylinderPartCalib));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_CalibrationPara.xDisplaceActivationCalib THEN
		sTmp:=CONCAT('58:rDisplaceActivationCalib:=','1');
	ELSE
		sTmp:=CONCAT('58:rDisplaceActivationCalib:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	IF ptrData_ProcessImageData^.T_CalibrationPara.xPlungeActivationCalib THEN
		sTmp:=CONCAT('59:rPlungeActivationCalib:=','1');
	ELSE
		sTmp:=CONCAT('59:rPlungeActivationCalib:=','0');
	END_IF;
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	ptrDataFile^[i]:='/* Process Para */';i:=i+1;
	sTmp:=CONCAT('60:rOffsetBeforeToolDiaGrindFeedProcess:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rOffsetBeforeToolDiaGrindFeedProcess));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('61:rSecurityPosGrindFeedProcess:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rSecurityPosGrindFeedProcess));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('62:rSpeedBackwardGrindFeed:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rSpeedBackwardGrindFeed));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('63:rSpeedForwardFastGrindFeed:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rSpeedForwardFastGrindFeed));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('64:rSpeedForwardSlowGrindFeed:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rSpeedForwardSlowGrindFeed));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('65:rSpeedStartPosToolFeedProcess:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rSpeedStartPosToolFeedProcess));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('66:rStartPosToolFeedAuto:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rStartPosToolFeedAuto));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('67:rToolDiameterProcess:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rToolDiameterProcess));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
	sTmp:=CONCAT('68:rToolTensionProcess:=',REAL_TO_STRING(ptrData_ProcessImageData^.T_ProcessPara.rToolTensionProcess));
	ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	(* add empty line to set the end *)
	ptrDataFile^[i]:='';

	(* confirm copy *)
	xFctCopyProfileToDataFile:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctCtrleProfileName : BOOL
VAR_INPUT
	sNewProfileName:STRING(30);		(* profile name to save *)
	ptrProfileList:POINTER TO ARRAY[1..csiMaxProfile] OF ST_PROFILE_ID;	(* list of the saved profil names *)
END_VAR
VAR
(* variable *)
	i: INT;
	sTmp:STRING;
	sTmp2:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                              This Function check the name of the profile if it is correct                                                     ************)
(****************************************************************************************************************************************************)
(* Init. function *)
	xFctCtrleProfileName:=FALSE;
	sTmp:=FCT_UPLOW_CASE(	xLowConvert:=TRUE,
							sInString:=sNewProfileName);

(* Search if name already exists *)
	FOR i:=1 TO csiMaxProfile DO
		sTmp2:=	FCT_UPLOW_CASE(	xLowConvert:=TRUE,
								sInString:=ptrProfileList^[i].sName);
		IF sTmp = sTmp2 AND sTmp2 <> '' THEN RETURN; END_IF
	END_FOR

(* Confirm function *)
	xFctCtrleProfileName:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_VISU_LAYER5' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_VISU
VAR
	fbVisuQVis: FBQVIS;
	xSecurityKey: BOOL;
	FBCtrleButton: FB_CTRLEBUTTON;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 6
_NETWORK

_COMMENT
'VISUALISATION LEVEL-->LAYER 5'
_END_COMMENT
_FUNCTIONBLOCK
FBCtrleButton
_BOX_EXPR : 9
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[1]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[2]
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis.T_PlcParam.dwActualPage
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeOut.QxContactor_K3
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeOut.QxContactor_K4
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Start
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Stop
_EXPRESSION
_POSITIV
FB_CTRLEBUTTON
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_JUMP
_EXPRESSION
_POSITIV
StepVisu
_OPERAND
_EXPRESSION
_NEGATIV
T_StartUp.T_State.xCompleted
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Start.xLedState
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[1]
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Stop.xLedState
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QarxDigitalOutput[2]
_NETWORK
StepVisu
_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
fbVisuQVis
_BOX_EXPR : 16
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Start.xInputState
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Stop.xInputState
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[3]
_OPERAND
_EXPRESSION
_POSITIV
UDINT_TO_WORD(T_CtrlePanel.udiButton)
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeOut
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafeIn
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[9]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[10]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[11]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[12]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[13]
_OPERAND
_EXPRESSION
_POSITIV
IarxDigitalInput[14]
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis
_OPERAND
_EXPRESSION
_POSITIV
QVisCtrl
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam
_OPERAND
_EXPRESSION
_POSITIV
T_StartUp
_EXPRESSION
_POSITIV
FBQVIS
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_VisuQVis.T_CtrleVisu.xReset
_OUTPUT
_POSITIV
_NO_SET
T_VisuQVis.T_CtrleVisu.xExecute

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_STARTUP
VAR
	xRdy: BOOL;
	iStepAction: INT := 10;
	xFirstExecution: BOOL;
	xPLCWait: BOOL := TRUE;
	TONPLCWait: TON;
	tTimeOutFunction: TIME;
	TimerFunction: TON;
	RisingEdgeExecute: R_TRIG;
	xInitVisu: BOOL;
	xLoading: BOOL;
	TONStartUp: TON;
	xReboot: BOOL;
	xEmergency: BOOL;
	xStartBooting: BOOL;
	xNoAirPressure: BOOL;
	xNodeFailCANOpen: BOOL;
	xActiveErrorMsg: BOOL;
	iMsgNumber: INT;
	xActiveInfoMsg: BOOL;
	iStepFunction: INT;
	RisingEdgeQuitButton: R_TRIG;
	RisingEdgeStartButton: R_TRIG;
	TONWaitResetOutput: TON;
	xStartCheck: BOOL:=TRUE;
	xDeleteErrorMessage: BOOL;
	TONWaitCircuitOn: TON;
	xCheckSecurityDoor: BOOL;
	tTimeStartUp: TIME := T#120ms;
	TimerDelayStartStation: TON;
	xTmp: BOOL;
	xReadHardware: BOOL;
	xTmp1: BOOL;
	xCheckConfirm: BOOL;
(* variable *)
(* Execute *)
	xSetOutputDisable:BOOL;
(* Init Error List *)
	FallingEdgeSecurityCircuit1:F_TRIG;
	FallingEdgeSecurityCircuit2:F_TRIG;
	RisingEdgeSecurityCircuit1:R_TRIG;
	RisingEdgeSecurityCircuit2:R_TRIG;
	FallingEdgeEnergyOff:F_TRIG;
	RisingEdgeEnergyOn:R_TRIG;
	TONWaitEndMessage:TON;
	xCheckAirPressure: BOOL;
	TONWaitCheckAirPressure: TON;
	xSwitchOffMachine: BOOL;
	TONWaitSwitchOffMachine: TON;
	iStepSwitchOffMachine: INT;
	xSwitchOffMachineReady: BOOL;
	xBlockChecking: BOOL;
	xCheckStateSecurityDoor: BOOL;
	xProcessAbordet: BOOL;
(* Init Error List *)
	FBInitErrorList:FB_InitErrorList;
	FBBIOSPARAMETER: FB_BIOSPARAMETER;
	FBErrorMessage : FB_ErrorMessage;
	diTmpErrorNr: DINT;
	FBCheckActiveMovement: FB_CHECKACTIVEMOVEMENT;
	xResetFBActiveMovement: BOOL;
	RisingEdgeTemp: R_TRIG;
	xTmpSecurityKey: BOOL;
	xMicroRodActive: BOOL;
	iStepFunctionON: INT;
	xReadFirstTime: BOOL;
	TONWaitSetSecStateON: TON;
	xCheckStateOfDrive: BOOL;
	TONChkStateDrive: TON;
	xSwitchOffHardwareLayer: BOOL;
	xTmp2: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(**********      This Functionblock manage the booting of the machine and the security mangament of the machine during   ********)
(**********       the machine operating                           														    ************)
(****************************************************************************************************************************************************)
(* First execution of the start up *)
IF NOT(xFirstExecution) THEN
	(* Init. Startup structure *)
	T_StartUp.T_Ctrle.xExecute:=FALSE;
	T_StartUp.T_Ctrle.xDone:=FALSE;
	T_StartUp.T_Ctrle.xErr:=FALSE;
	T_StartUp.T_Ctrle.xReset:=FALSE;
	T_StartUp.T_State.xPLCReady:=FALSE;
	T_StartUp.T_Ctrle.iFunction:=0;
	T_StartUp.T_Ctrle.udiErrorID:=16#0;
	T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;
	T_StartUp.T_Ctrle.iMsgNumber:=0;
	(* Timer *)
	TimerFunction(IN:=FALSE);
	(* confirm first execution *)
	xFirstExecution:=TRUE;
	TONPLCWait(IN:=FALSE);
	RETURN;
END_IF

(* waiting 5 sec before starting *)
	IF xPLCWait THEN
		TONPLCWait(IN:=TRUE,PT:=T#5s);
		IF TONPLCWait.Q THEN
			TONPLCWait(IN:=FALSE);
			xPLCWait:=FALSE;
			(* activ function "Start PLC" *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=1;
			tTimeOutFunction:=T#2s;
		END_IF;
		RETURN;
	END_IF;

(****************************************************************************************************************************************************)
(***********                                start of the check for the emergeny button, air and axis communication error                              ************)
(****************************************************************************************************************************************************)
(* check the emergency stop and the air pressure after booting the machine *)
	IF NOT(xStartCheck) THEN
	(* check emergency stop, only if it is not already in this state *)
		IF NOT(xStartBooting AND ((iStepFunction = 1) OR (iStepFunction = 10))) THEN
			IF NOT(T_TwinSafeIn.IxEmergencyStopMachine) OR NOT(T_TwinSafeIn.IxEmergencyStopStuder) THEN
				IF NOT((xEmergency AND (iStepFunction < 40))) THEN
					RisingEdgeExecute(CLK:=FALSE);
					(* Set emergency function *)
					T_StartUp.T_Ctrle.xExecute:=TRUE;
					T_StartUp.T_Ctrle.iFunction:=4;
					xInitVisu:=FALSE;
					xLoading:=FALSE;
					xReboot:=FALSE;
					xStartBooting:=FALSE;
					xActiveErrorMsg:=FALSE;
					xActiveInfoMsg:=FALSE;
					xCheckConfirm:=FALSE;
					xSwitchOffMachineReady:=FALSE;
					xSwitchOffMachine:=FALSE;
					xNoAirPressure:=FALSE;
					xNodeFailCANOpen:=FALSE;
					xResetFBActiveMovement:=TRUE;
					tTimeOutFunction:=T#0s;
					T_StartUp.T_State.xCompleted:=FALSE;
				END_IF;
			END_IF;
		END_IF;
	
	(* check air pressure, only if it is not already in this state *)
		IF NOT(xStartBooting) AND NOT(xEmergency) THEN
			IF T_TwinSafeIn.IxEmergencyStopMachine AND T_TwinSafeIn.IxEmergencyStopStuder AND NOT(IarxDigitalInput[4]) THEN
				IF T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4 AND NOT(xNoAirPressure) THEN
					xCheckAirPressure:=TRUE;
				END_IF;
			ELSE
				TONWaitCheckAirPressure(IN:=FALSE);
				xCheckAirPressure:=FALSE;
			END_IF;
			IF xCheckAirPressure THEN
				TONWaitCheckAirPressure(IN:=TRUE,PT:=T#2s);
				IF TONWaitCheckAirPressure.Q THEN
					xCheckAirPressure:=FALSE;
					TONWaitCheckAirPressure(IN:=FALSE);
					IF NOT(IarxDigitalInput[4]) THEN
						RisingEdgeExecute(CLK:=FALSE);
						(* Set No Air pressure function *)
						T_StartUp.T_Ctrle.xExecute:=TRUE;
						T_StartUp.T_Ctrle.iFunction:=6;
						xInitVisu:=FALSE;
						xLoading:=FALSE;
						xReboot:=FALSE;
						xStartBooting:=FALSE;
						xActiveErrorMsg:=FALSE;
						xActiveInfoMsg:=FALSE;
						xCheckConfirm:=FALSE;
						xCheckSecurityDoor:=FALSE;
						xCheckStateSecurityDoor:=FALSE;
						xSwitchOffMachineReady:=FALSE;
						xSwitchOffMachine:=FALSE;
						xResetFBActiveMovement:=TRUE;
						tTimeOutFunction:=T#0s;
						T_StartUp.T_State.xCompleted:=FALSE;
					END_IF;
				END_IF;
			END_IF;
		ELSE
			xCheckAirPressure:=FALSE;
			TONWaitCheckAirPressure(IN:=FALSE);
		END_IF;
	END_IF;

	(* check Node of the Ventilinsel, only if it is not already in this state *)
	IF NOT(xStartBooting) AND NOT(xEmergency) AND NOT(xCheckAirPressure) AND T_StartUp.T_State.xCompleted AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		xTmp:=	(T_AxisNodeState.bToolLeftNodeState <> 0) OR
				((T_AxisNodeState.bToolCenterNodeState <> 0) AND xMicroRodActive) OR
				(T_AxisNodeState.bToolRightNodeState <> 0) OR
				(T_AxisNodeState.bToolFeederNodeState <> 0) OR
				(T_AxisNodeState.bGrindFeederNodeState <> 0);
		IF xTmp THEN
			RisingEdgeExecute(CLK:=FALSE);
			(* Set CANOpen NodeFail function *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=7;
			xInitVisu:=FALSE;
			xLoading:=FALSE;
			xReboot:=FALSE;
			xStartBooting:=FALSE;
			xActiveErrorMsg:=FALSE;
			xActiveInfoMsg:=FALSE;
			xCheckConfirm:=FALSE;
			xCheckSecurityDoor:=FALSE;
			xCheckStateSecurityDoor:=FALSE;
			xSwitchOffMachineReady:=FALSE;
			xSwitchOffMachine:=FALSE;
			xResetFBActiveMovement:=TRUE;
			tTimeOutFunction:=T#0s;
			T_StartUp.T_State.xCompleted:=FALSE;
		END_IF;
	END_IF;
(****************************************************************************************************************************************************)
(***********                                end of the check for the emergeny button, air and axis communication error                              ************)
(****************************************************************************************************************************************************)

(****************************************************************************************************************************************************)
(***********                                               start of the management for calling of the start up function                                                   ************)
(****************************************************************************************************************************************************)
(* execute *)
	RisingEdgeExecute(CLK:=T_StartUp.T_Ctrle.xExecute);
	T_StartUp.T_Ctrle.xExecute:=FALSE;
	IF RisingEdgeExecute.Q THEN
		T_StartUp.T_Ctrle.xExecute:=FALSE;
		CASE T_StartUp.T_Ctrle.iFunction OF
		(* Start PLC *)
		1:	xInitVisu:=TRUE;
			tTimeOutFunction:=T#2s;
		(* Start loading *)
		2:	xLoading:=TRUE;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage:=1;
			tTimeOutFunction:=T#60s;
			TONStartUp(IN:=FALSE);
		(* Start reboot *)
		3:	xReboot:=TRUE;
			tTimeOutFunction:=T#5s;
		(* Emergency *)
		4:	xEmergency:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
		(* Start Booting *)
		5:	xStartBooting:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
		(* No Air pressure *)
		6:	xNoAirPressure:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
		(* Node CANOpen fail *)
		7:	xNodeFailCANOpen:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
		(* Read NovRAM Parameter *)
		8:	xReadHardware:=TRUE;
			tTimeOutFunction:=T#5s;
		(* Activate Error Message Overlay *)
		10:	xActiveErrorMsg:=TRUE;
			iMsgNumber:=T_StartUp.T_Ctrle.iMsgNumber;
			T_StartUp.T_Ctrle.iMsgNumber:=0;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
		(* Acitvate Info Message Overlay *)
		11:	xActiveInfoMsg:=TRUE;
			iMsgNumber:=T_StartUp.T_Ctrle.iMsgNumber;
			T_StartUp.T_Ctrle.iMsgNumber:=0;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
		ELSE
		(* function not implemented *)
			T_StartUp.T_Ctrle.xDone:=FALSE;
			T_StartUp.T_Ctrle.xErr:=TRUE;
			T_StartUp.T_Ctrle.udiErrorID:=16#F000;
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		iStepFunction:=1;
		T_StartUp.T_Ctrle.xDone:=FALSE;
		T_StartUp.T_Ctrle.xErr:=FALSE;
		T_StartUp.T_Ctrle.udiErrorID:=0;
		TimerFunction(IN:=FALSE);
	(* Exit FB *)
		RETURN;
	END_IF
(****************************************************************************************************************************************************)
(***********                                               end of the management for calling of the start up function                                                   ************)
(****************************************************************************************************************************************************)

(* Start and Quit Button *)
	RisingEdgeStartButton(CLK:=IarxDigitalInput[1]);
	RisingEdgeQuitButton(CLK:=T_TwinSafeIn.IxRealseButton);

(* Check of the failed function for the drive. If an error exist on the Axis and the current is off, than it gives not a possibility to switch on the energy. This part will check this state and reset the error *)
	IF (NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4)) THEN
		IF RisingEdgeQuitButton.Q THEN
			xCheckStateOfDrive:=TRUE;
			TONChkStateDrive(IN:=FALSE);
		END_IF;
		IF xCheckStateOfDrive THEN
			TONChkStateDrive(IN:=TRUE,PT:=T#2s);
			IF TONChkStateDrive.Q THEN
				xCheckStateOfDrive:=FALSE;
				IF NOT(T_Station.TControl.xActiveHardware) THEN
					xSwitchOffHardwareLayer:=TRUE;
					T_Station.TControl.xActiveHardware:=TRUE;
				END_IF;
				IF T_TwinSafeIn.IxReadyToolLeft AND T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr AND
				     NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute) THEN
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.iFunction:=1;
					T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF xMicroRodActive THEN
					IF T_TwinSafeIn.IxReadyToolCenter AND T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND
					     NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute) THEN
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.iFunction:=1;
						T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				IF T_TwinSafeIn.IxReadyToolRight AND T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr AND
				     NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute) THEN
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.iFunction:=1;
					T_Station.THardware.TAxisToolRight.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF T_TwinSafeIn.IxReadyToolFeeder AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr AND
				     NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute) THEN
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.iFunction:=1;
					T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF T_TwinSafeIn.IxReadyGrindFeeder AND T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr AND
				     NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone) AND NOT(T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute) THEN
					T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.iFunction:=1;
					T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	ELSE
		xCheckStateOfDrive:=FALSE;
		TONChkStateDrive(IN:=FALSE);
	END_IF;
	IF xSwitchOffHardwareLayer THEN
		xTmp2:=	T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xDone AND ((T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xDone AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
				T_Station.THardware.TAxisToolRight.T_CtrleSingle.xDone AND T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xDone AND
				T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xDone;
		IF xTmp2 THEN
			xSwitchOffHardwareLayer:=FALSE;
			T_Station.TControl.xActiveHardware:=FALSE;
		END_IF;
	END_IF;

(* Time out function *)
	IF tTimeOutFunction <> T#0s THEN TimerFunction(IN:=TRUE,PT:=tTimeOutFunction); ELSE TimerFunction(IN:=FALSE); END_IF
	IF TimerFunction.Q AND NOT T_StartUp.T_Ctrle.xDone AND NOT T_StartUp.T_Ctrle.xErr THEN
	(* Error, timeout action activ *)
		T_StartUp.T_Ctrle.xErr:=TRUE;
		(* Init. variable *)
		xInitVisu:=FALSE;
		xLoading:=FALSE;
		xReboot:=FALSE;
		xStartBooting:=FALSE;
		xActiveErrorMsg:=FALSE;
		xActiveInfoMsg:=FALSE;
		xCheckSecurityDoor:=FALSE;
		xCheckStateSecurityDoor:=FALSE;
		(* Set output disable *)
		xSetOutputDisable:=TRUE;
		(* Display error message *)
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState:=203;
		(* exit FB, do not continue the execution of action! *)
		(* Overlay Message Error *)
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=7;	(* WHILE THE MACHINE IS BOOTING *)
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=7;	(* AN ERROR IS OCCURRED *)
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=7;	(* PLEASE CONFIRM THIS MESSAGE AND READ AFTER *)
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=7;	(* THE ACCORDING ERROR *)
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
		xCheckConfirm:=TRUE;
	END_IF
	IF xCheckConfirm AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			xCheckConfirm:=FALSE;
			xStartBooting:=TRUE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			(* next step *)
			iStepFunction:=1;
		END_IF;
	ELSE
		xCheckConfirm:=FALSE;
	END_IF;

(* Check Lamp State of external Button *)
	IF NOT(T_StartUp.T_State.xCompleted) THEN
		IF (NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4)) THEN
			QarxDigitalOutput[1]:=FALSE;
			QarxDigitalOutput[2]:=FALSE;
			QarxDigitalOutput[3]:=TRUE;
		END_IF;
		IF T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4 THEN
			QarxDigitalOutput[3]:=FALSE;
		END_IF;
		IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN
			QarxDigitalOutput[3]:=FALSE;
		END_IF;
		IF (T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError <> 0) THEN
			QarxDigitalOutput[1]:=FALSE;
			QarxDigitalOutput[2]:=FALSE;
			QarxDigitalOutput[3]:=FALSE;
		END_IF;
	ELSE
		IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN
			QarxDigitalOutput[3]:=FALSE;
		END_IF;
		IF T_TwinSafeIn.IxPowerSupplyEcoStep AND (NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4)) THEN
			QarxDigitalOutput[3]:=TRUE;
		END_IF;
	END_IF;

(* Check Machine active movement *)
	FBCheckActiveMovement(	T_TwinSafeOut:= T_TwinSafeOut,
							xKeySwitch:= IarxDigitalInput[3],
							xBlockChecking:= xBlockChecking,
							xReset:= xResetFBActiveMovement,
							T_Visu:= T_VisuQVis,
							T_Station:= T_Station,
							T_Process:= T_Process);

(* Message Energy on/off *)
	FallingEdgeEnergyOff(CLK:=NOT(T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4));
	RisingEdgeEnergyOn(CLK:=NOT(T_TwinSafeOut.QxContactor_K3 AND T_TwinSafeOut.QxContactor_K4));
	IF T_StartUp.T_State.xCompleted AND FallingEdgeEnergyOff.Q AND NOT(xCheckStateSecurityDoor) THEN
		IF (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 0) OR (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 119) THEN
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState:=118;	(* The energy supply is ON *)
			TONWaitEndMessage(IN:=FALSE);
		END_IF;
	END_IF;
	IF T_StartUp.T_State.xCompleted AND RisingEdgeEnergyOn.Q AND NOT(xCheckStateSecurityDoor) THEN
		IF (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 0) OR (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 118) THEN
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState:=119;	(* The energy supply is OFF *)
			TONWaitEndMessage(IN:=FALSE);
		END_IF;
	END_IF;
	IF (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 118) OR (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 119) THEN
		TONWaitEndMessage(IN:=TRUE,PT:=T#2s);
		IF TONWaitEndMessage.Q THEN
			TONWaitEndMessage(IN:=FALSE);
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;	(* Close Message *)
		END_IF;
	END_IF;

(* Check Power switch off from the security circuit *)
	FallingEdgeSecurityCircuit1(CLK:=T_TwinSafeOut.QxContactor_K3);
	FallingEdgeSecurityCircuit2(CLK:=T_TwinSafeOut.QxContactor_K4);
	IF T_StartUp.T_State.xCompleted AND (FallingEdgeSecurityCircuit1.Q OR FallingEdgeSecurityCircuit2.Q) THEN
		IF (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState <> 401) THEN
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=3;
			T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=3;
		END_IF;
		IF T_Station.TControl.xActiveHardware THEN
			T_Station.TControl.xSecurityCircuitOff:=TRUE;
			T_Station.TControl.xSecurityCircuitOn:=FALSE;
		END_IF;
		IF T_Process.xEnable AND NOT(T_Process.xEnd) AND ((T_Process.iFunctNr = 10) OR (T_Process.iFunctNr = 20) OR (T_Process.iFunctNr = 30) OR (T_Process.iFunctNr = 40)) THEN
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			xProcessAbordet:=TRUE;
		ELSE
			xProcessAbordet:=FALSE;
		END_IF;
		IF NOT(T_Process.xError) THEN
			T_Process.xEnable:=FALSE;
		END_IF;
		QarxDigitalOutput[3]:=TRUE;	(* QxCtrlLampReleaseButton *)
		IF FBCheckActiveMovement.xActiveSetupLevel AND (FBCheckActiveMovement.xActiveProcess OR FBCheckActiveMovement.xActiveStation OR FBCheckActiveMovement.xActiveHWStation) THEN
			xBlockChecking:=TRUE;
		ELSE
			xBlockChecking:=FALSE;
		END_IF;
	END_IF;
	IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=4;
		T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=4;
	END_IF;
	IF T_TwinSafeIn.IxPowerSupplyEcoStep AND (NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4)) THEN
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=3;
		T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=3;
	END_IF;
	IF (T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState = 401) THEN
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=0;
		T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=0;
	END_IF;

(* Check Power switch on from the security circuit *)
	RisingEdgeSecurityCircuit1(CLK:=T_TwinSafeOut.QxContactor_K3);
	RisingEdgeSecurityCircuit2(CLK:=T_TwinSafeOut.QxContactor_K4);
	IF T_StartUp.T_State.xCompleted AND (RisingEdgeSecurityCircuit1.Q OR RisingEdgeSecurityCircuit2.Q) THEN
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=1;
		T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=1;
		IF T_Station.TControl.xActiveHardware THEN
			T_Station.TControl.xSecurityCircuitOn:=TRUE;
			T_Station.TControl.xSecurityCircuitOff:=FALSE;
		END_IF;
		T_Process.xEnable:=TRUE;
		QarxDigitalOutput[3]:=FALSE;	(* QxCtrlLampReleaseButton *)
	END_IF;

(****************************************************************************************************************************************************)
(***********                   start of the check for the hardware configuration changement and error during the startup                  ************)
(****************************************************************************************************************************************************)
(* Check changement of the Hardware Configuration *)
	IF T_StartUp.T_State.xCompleted AND NOT(xSwitchOffMachine) AND NOT(xSwitchOffMachineReady) THEN
		IF T_Station.TControl.xHardwareConfigError THEN
			xSwitchOffMachine:=TRUE;
		END_IF;
		IF xSwitchOffMachine THEN
			TONWaitSwitchOffMachine(IN:=FALSE);
			iStepSwitchOffMachine:=1;
		END_IF;
	END_IF;
	IF xSwitchOffMachine THEN
		TONWaitSwitchOffMachine(IN:=TRUE,PT:=T#5s);
		CASE iStepSwitchOffMachine OF
		1:	IF NOT(T_VisuQVis.T_CtrleVisu.xExecute) AND T_VisuQVis.T_CtrleVisu.xDone THEN
				T_NovRAM.T_Ctrle.xReset:=TRUE;
				T_VisuQVis.ptrT_ExchgParam^.T_TouchScreenBtPanel.iStateBtLeft:=0;
				T_VisuQVis.T_PlcParam.dwSetNewPage:=16#A;	(* Main Page wird aufgerufen *)
				T_VisuQVis.T_CtrleVisu.iFunction:=1;
				T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
				iStepSwitchOffMachine:=10;
			END_IF;
		10:	IF NOT(T_VisuQVis.T_CtrleVisu.xExecute) AND T_VisuQVis.T_CtrleVisu.xDone THEN
				T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
				(* Overlay Message Error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=19;	(* THE HARDWARE CONFIGURATION *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=19;	(* HAS BEEN CHANGED! *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=19;	(* THE MACHINE WILL BE SWITCHED OFF *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=19;	(* IN 5 SECONDS *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
				(* next step *)
				iStepSwitchOffMachine:=20;
			END_IF;
		20:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				iStepSwitchOffMachine:=1;
				xSwitchOffMachine:=FALSE;
				xSwitchOffMachineReady:=TRUE;
			END_IF;
		END_CASE;
		IF TONWaitSwitchOffMachine.Q  THEN
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			iStepSwitchOffMachine:=1;
			xSwitchOffMachine:=FALSE;
			xSwitchOffMachineReady:=TRUE;
		END_IF;
	END_IF;
	IF xSwitchOffMachineReady THEN
		TONWaitSwitchOffMachine(IN:=FALSE);
		xSwitchOffMachineReady:=FALSE;
		xSwitchOffMachine:=FALSE;
		T_StartUp.T_State.xCompleted:=FALSE;
		xSetOutputDisable:=TRUE;
		T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
		T_StartUp.T_Ctrle.xDone:=TRUE;
		T_StartUp.T_Ctrle.xErr:=FALSE;
		T_StartUp.T_Ctrle.udiErrorID:=0;
		xInitVisu:=FALSE;
		tTimeOutFunction:=T#0s;
		(* Start Booting *)
		T_StartUp.T_Ctrle.xExecute:=TRUE;
		T_StartUp.T_Ctrle.iFunction:=5;
	END_IF;

(* Check Hardware Error *)
	IF T_StartUp.T_State.xCompleted AND T_Station.TControl.xEnd AND NOT(T_Station.TControl.xError) AND T_Process.xEnd AND NOT(T_Process.xError) THEN
		xTmp:=	T_VisuQVis.T_CtrleAction.xDone AND
				(*T_VisuQVis.T_CtrleProcess.xDone AND
				T_VisuQVis.T_CtrleVisu.xDone AND*)
				(T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState <> 401);
		IF xTmp THEN
			diTmpErrorNr:=0;
			IF T_Station.THardware.TAxisToolLeft.T_CtrleSingle.xErr THEN
				diTmpErrorNr:=(T_Station.THardware.TAxisToolLeft.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolLeft.T_CtrleSingle.udiErrorID;
			END_IF;
			IF T_Station.THardware.TAxisToolCenter.T_CtrleSingle.xErr AND xMicroRodActive THEN
				diTmpErrorNr:=(T_Station.THardware.TAxisToolCenter.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolCenter.T_CtrleSingle.udiErrorID;
			END_IF;
			IF T_Station.THardware.TAxisToolRight.T_CtrleSingle.xErr THEN
				diTmpErrorNr:=(T_Station.THardware.TAxisToolRight.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolRight.T_CtrleSingle.udiErrorID;
			END_IF;
			IF T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.xErr THEN
				diTmpErrorNr:=(T_Station.THardware.TAxisToolFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisToolFeeder.T_CtrleSingle.udiErrorID;
			END_IF;
			IF T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.xErr THEN
				diTmpErrorNr:=(T_Station.THardware.TAxisGrindFeeder.T_Config_Gen.iTyp * 1000000) + T_Station.THardware.TAxisGrindFeeder.T_CtrleSingle.udiErrorID;
			END_IF;
			IF (diTmpErrorNr <> 0) THEN
				FBErrorMessage(	diErrorNr:=diTmpErrorNr,
								T_ErrorList:=T_ErrorList);
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=diTmpErrorNr;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			END_IF;
		END_IF;
	END_IF;

(****************************************************************************************************************************************************)
(***********                                            end of the check for the hardware configuration changement                                               ************)
(****************************************************************************************************************************************************)

(* Manage BIOS Parameter *)
	IF T_StartUp.T_State.xPLCReady THEN
		FBBIOSPARAMETER(	dwBIOSPasswordPage:= 1,
							dwBIOSParameterPage:= 2,
							T_TwinSafeOut:= T_TwinSafeOut,
							T_Visu:= T_VisuQVis,
							T_HDD:= T_HDD,
							T_NovRam:= T_NovRam,
							T_CtrlePanel:= T_CtrlePanel,
							T_DeviceID:= T_DeviceID,
							T_BoxID:= T_BoxID,
							T_Profile:= T_Profile);
	END_IF;

(****************************************************************************************************************************************************)
(***********                                                      start of the execution for the function of the start up                                                          ************)
(****************************************************************************************************************************************************)
(* Function Init PLC *)
	IF xInitVisu AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		CASE iStepFunction OF
		1:	T_VisuQVis.T_CtrleVisu.xActive:=TRUE;
			T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
			(* next step *)
			iStepFunction:=10;
		(* Confirm Reset *)
		10:	IF T_VisuQVis.T_CtrleVisu.xDone THEN
				T_StartUp.T_State.xPLCReady:=TRUE;
				(* next step *)
				iStepFunction:=90;
			END_IF
		(* end function or time out *)
		90:	T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=0;
			xInitVisu:=FALSE;
			tTimeOutFunction:=T#0s;
			(* Start Read Hardware *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=8;
		END_CASE
	END_IF

(* Function ReadHardware with NovRAM Parameter *)
	IF xReadHardware AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		CASE iStepFunction OF
		(* Start station, reset FB *)
		1:	T_HDD.T_Ctrle.xReset:=TRUE;
			T_DeviceID.T_Ctrle.xReset:=TRUE;
			T_BoxID.T_Ctrle.xReset:=TRUE;
			T_NovRAM.T_Ctrle.xReset:=TRUE;
			T_Profile.T_Ctrle.xReset:=TRUE;
			(* next step *)
			iStepFunction:=10;
		(* waiting reset confirmation *)
		10:	xTmp:=	T_HDD.T_Ctrle.xDone
					AND T_DeviceID.T_Ctrle.xDone
					AND T_NovRAM.T_Ctrle.xDone
					AND T_BoxID.T_Ctrle.xDone;
			IF xTmp THEN  iStepFunction:=20; END_IF
		(* Init. device name *)
		20:	(* PLC name *)
			T_DeviceID.T_CX1020.sDeviceName:='CX1000_PLC';
			(* feldbus name *)
			T_DeviceID.T_CANOpenMaster.sDeviceName:='CANOpenMaster';
			T_DeviceID.T_CANOpenMaster.xDeviceOption:=TRUE;
			T_DeviceID.T_LightbusMaster.sDeviceName:='LightbusMaster';
			T_DeviceID.T_LightbusMaster.xDeviceOption:=TRUE;
			(* NovRAM *)
			T_DeviceID.T_NovRAM.sDeviceName:='NovRAM';
			(* read device ID *)
			T_DeviceID.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=30;
		(* waiting ID confirmation, Start BoxID *)
		30:	IF NOT(T_DeviceID.T_Ctrle.xExecute) AND T_DeviceID.T_Ctrle.xDone THEN iStepFunction:=40; END_IF
		(* waiting Box ID confirmation *)
		40:	IF NOT(T_BoxID.T_Ctrle.xExecute) AND T_BoxID.T_Ctrle.xDone THEN
				(* next step *)
				iStepFunction:=50;
			END_IF
		50:	T_NovRAM.T_Ctrle.iFunction:=1;
			T_NovRam.T_Ctrle.xBlockReadFirstTime:=FALSE;
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			iStepFunction:=60;
		60:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone THEN
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iConfigAxisType:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigAxisType;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iConfigMachineType:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigMachineType;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iConfigVisuNavigation:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.iConfigVisuNavigation;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLength:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLength;
				(*08.12.2010 KFS:	{	*)
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.rConfigMaxToolLengthOriginal:=T_NovRAM.T_Data.T_Standard.T_MachineConfig.rConfigMaxToolLengthOriginal;
				(*08.12.2010 KFS:	}	*)
				T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
				iStepFunction:=70;
			END_IF;
		(* end function or time out *)
		70:	IF T_VisuQVis.T_CtrleVisu.xDone THEN
				T_VisuQVis.ptrT_ExchgParam^.T_Config.xNoTouchScreenBtPanel:=TRUE;
				T_StartUp.T_Ctrle.xDone:=TRUE;
				T_StartUp.T_Ctrle.xErr:=FALSE;
				T_StartUp.T_Ctrle.udiErrorID:=0;
				xReadHardware:=FALSE;
				tTimeOutFunction:=T#0s;
				(* Start Boot *)
				T_StartUp.T_Ctrle.xExecute:=TRUE;
				T_StartUp.T_Ctrle.iFunction:=5;
			END_IF;
		END_CASE;
	END_IF;

(* Function Start Booting *)
	IF xStartBooting AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage:=1;
		CASE iStepFunction OF
		1:	IF (T_NovRam.T_Data.T_Standard.T_MachineConfig.iConfigMachineType = 2) THEN
				xMicroRodActive:=TRUE;
			ELSE
				xMicroRodActive:=FALSE;
			END_IF;
			T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
			QarxDigitalOutput[1]:=FALSE;	(* QxCtrlLampStartButton *)
			QarxDigitalOutput[2]:=FALSE;	(* QxCtrlLampStopButton *)
			QarxDigitalOutput[3]:=FALSE;	(* QxCtrlLampReleaseButton *)
			IF NOT(T_TwinSafeIn.IxEmergencyStopMachine) OR NOT(T_TwinSafeIn.IxEmergencyStopStuder) THEN		(* check state of emergency button *)
				(* Overlay Message Error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=1;	(* EMERGENCY STOP BUTTON IS ACITVE! *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=1;	(* PLEASE RELEASE THIS BUTTON *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=1;	(* AND AFTER CONFIRM THIS MESSAGE *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=1;	(*  *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
				(* next step *)
				iStepFunction:=10;
			ELSE
				(* next step *)
				iStepFunction:=11;
				TONWaitResetOutput(IN:=FALSE);
			END_IF;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;	(* Releas System Level *)
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Level.iActLevel:=1;
		10:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=1;
			END_IF;
		11:	TONWaitResetOutput(IN:=TRUE,PT:=T#500ms);
			IF TONWaitResetOutput.Q THEN
				TONWaitResetOutput(IN:=FALSE);
				iStepFunction:=20;
			END_IF;
		20:	xStartCheck:=FALSE;
			T_TwinSafeCtrleOUT.xTwinSAFE_Run:=TRUE;	(* Start TwinSafe Groupe *)
			TONWaitResetOutput(IN:=FALSE);
			(* next step *)
			iStepFunction:=21;
		21:	TONWaitResetOutput(IN:=TRUE,PT:=T#200ms);
			IF TONWaitResetOutput.Q THEN
				IF T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error OR T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error THEN
					T_TwinSafeCtrleOUT.xTwinSAFE_Reset:=TRUE;
					TONWaitResetOutput(IN:=FALSE);
					iStepFunction:=22;
					RETURN;
				END_IF;
				TONWaitResetOutput(IN:=FALSE);
				iStepFunction:=24;
			END_IF;
		22:	TONWaitResetOutput(IN:=TRUE,PT:=T#200ms);
			IF TONWaitResetOutput.Q THEN
				T_TwinSafeCtrleOUT.xTwinSAFE_Reset:=FALSE;
				T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
				TONWaitResetOutput(IN:=FALSE);
				iStepFunction:=23;
			END_IF;
		23:	TONWaitResetOutput(IN:=TRUE,PT:=T#200ms);
			IF TONWaitResetOutput.Q THEN
				TONWaitResetOutput(IN:=FALSE);
				iStepFunction:=20;
			END_IF;
		24:	IF T_TwinSafeIn.IxReadyToolLeft OR T_TwinSafeIn.IxReadyToolCenter OR T_TwinSafeIn.IxReadyToolRight OR T_TwinSafeIn.IxReadyToolFeeder OR T_TwinSafeIn.IxReadyGrindFeeder THEN
				T_Station.TControl.xResetHardware:=TRUE;
				iStepFunction:=25;
			ELSE
				iStepFunction:=30;
			END_IF;
		25:	IF NOT(T_Station.TControl.xResetHardware) THEN
				iStepFunction:=30;
			END_IF;
		30:	QarxDigitalOutput[3]:=TRUE;	(* QxCtrlLampReleaseButton *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=1;	(* Press external Quit Button *)
			(* next step *)
			iStepFunction:=40;
		40:	T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=1;	(* Press external Quit Button *)
			IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN
				QarxDigitalOutput[4]:=TRUE;	(* QxCtrlLampCurEcoButton *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=4;	(* Message: Release AxesCurrentButton *)
				RETURN;	(* Do nothing if the Button AxesCurrent is Active *)
			END_IF;
			IF RisingEdgeQuitButton.Q THEN		(* Wait until the Operator press the external quit button *)
				QarxDigitalOutput[3]:=FALSE;	(* QxCtrlLampReleaseButton *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=0;	(* No Text *)
				xDeleteErrorMessage:=TRUE;	(* Reset the line message error *)
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=50;
			END_IF;
		50:	TONWaitCircuitOn(IN:=TRUE,PT:=T#500ms);
			IF TONWaitCircuitOn.Q THEN
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=60;
			END_IF;
		60:	IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN	(* Check if the power supply of the EcoStep is switched Off *)
				T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
				(* Overlay Message Error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=4;	(* FOR BOOTING THE MACHINE *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=4;	(* SWITCH ON THE POWER SUPPLY ECOSTEP *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=4;	(* CONFIRM THIS MESSAGE AND  *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=4;	(* PRESS THE  RELEASE BUTTON *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
				(* next step *)
				iStepFunction:=70;
			ELSE
				IF NOT(T_TwinSafeOut.QxContactor_K3) AND NOT(T_TwinSafeOut.QxContactor_K4) THEN
					T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
					T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
					T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
					T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
					T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
					T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
					IF NOT(T_TwinSafeIn.IxReadyToolLeft) AND ((NOT(T_TwinSafeIn.IxReadyToolCenter) AND xMicroRodActive) OR NOT(xMicroRodActive)) AND
					     NOT(T_TwinSafeIn.IxReadyToolRight) AND NOT(T_TwinSafeIn.IxReadyToolFeeder) AND NOT(T_TwinSafeIn.IxReadyGrindFeeder) THEN
						(* Overlay Message Error *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=6;	(* THE CONNECTOR K3 OR K4 *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=6;	(* ARE NOT WORKING PROPERLY *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=6;	(* PLEASE CONFIRM AND TRY AGAIN  *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=6;	(*OTHERWISE CHECK THE EQUIPMENT *)
					ELSE
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=21;	(* AT LEAST ONE CANOPEN CONTROLLER FAILED! *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=21;	(* PLEASE CHECK THE ECOSTEP AXIS *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=21;	(* AND CONFIRM THIS MESSAGE *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=21;	(*  *)
						FBErrorMessage(	diErrorNr:=6,		(* At least one Ecostep CANOpen Controller failed! *)
										T_ErrorList:=T_ErrorList);
						T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
						T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
						T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
						(* Safe the error *)
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=6;
						T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
					END_IF;
					(* next step *)
					iStepFunction:=70;
				ELSE
					TONWaitCircuitOn(IN:=FALSE);
					(* next step *)
					iStepFunction:=80;
				END_IF;
			END_IF;
		70:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				xCheckSecurityDoor:=FALSE;
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=1;
			END_IF;
		80:	TONWaitCircuitOn(IN:=TRUE,PT:=T#2000ms);
			IF TONWaitCircuitOn.Q OR IarxDigitalInput[4] THEN	(* Check if the pressure of the air is present *)
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=90;
			END_IF;
			xCheckSecurityDoor:=TRUE;
		90:	IF NOT(IarxDigitalInput[4]) THEN		(* check state of air pressure *)
				xCheckSecurityDoor:=FALSE;
				T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
				(* Overlay Message Error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=2;	(* NO AIR PRESSURE! *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=2;	(* PLEASE ACTIVATE THE AIR PRESSURE *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=2;	(* AND AFTER CONFIRM THIS MESSAGE *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=2;	(*  *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
				FBErrorMessage(	diErrorNr:=7,		(* No Air Pressure *)
							T_ErrorList:=T_ErrorList);
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
				(* Safe the error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=7;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
				(* next step *)
				iStepFunction:=100;
			ELSE
				(* next step *)
				iStepFunction:=110;
			END_IF;
		100:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=20;
			END_IF;
		110:	QarxDigitalOutput[1]:=TRUE;	(* QxCtrlLampStartButton *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=2;	(* Press external start button *)
			(* next step *)
			iStepFunction:=120;
		120:	QarxDigitalOutput[1]:=TRUE;	(* QxCtrlLampStartButton *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=2;	(* Press external start button *)
			IF RisingEdgeStartButton.Q THEN		(* Wait until the Operator press the external start button *)
				QarxDigitalOutput[1]:=FALSE;	(* QxCtrlLampStartButton *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=0;
				xDeleteErrorMessage:=TRUE;	(* Reset the line message error *)
				(* next step *)
				iStepFunction:=130;
			END_IF;
			IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN	(* Check if the power supply of the EcoStep is switched Off *)
				(* next step *)
				iStepFunction:=60;
				RETURN;
			END_IF;
		130:	IF IarxDigitalInput[3] THEN	(* Check if the key switch is active *)
				(* Overlay Message Error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=5;	(* FOR BOOTING THE MACHINE IT IS MANDATORY *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=5;	(* THAT YOU SWITCH OFF THE KEY SWITCH *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=5;	(* CONFIRM THIS MESSAGE AND TRY AGAIN *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=5;	(* TO PRESS THE EXTERNAL START BUTTON *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
				(* next step *)
				iStepFunction:=140;
			ELSE
				(* next step *)
				iStepFunction:=150;
			END_IF;
		140:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=110;
			END_IF;
			IF (NOT(T_TwinSafeOut.QxContactor_K3) OR NOT(T_TwinSafeOut.QxContactor_K4)) THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=1;
			END_IF;
		150:	(* Start Booting is ended, the machine has now the right state to boot the machine *)
			IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN	(* Check if the power supply of the EcoStep is switched Off *)
				(* next step *)
				iStepFunction:=60;
				RETURN;
			END_IF;
			xCheckSecurityDoor:=FALSE;
			xStartBooting:=FALSE;
			(* Start Loading *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=2;
		END_CASE;
	END_IF;

(* Function start loading *)
	IF xLoading AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		(* Timer bargraph *)
		IF (iStepFunction < 999) THEN
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=3;	(* Machine is booting *)
			TONStartUp(IN:=TRUE,PT:=tTimeStartUp);
			IF TONStartUp.Q THEN
				TONStartUp(IN:=FALSE);
				IF (T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage <=100) THEN
					T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage:=T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage +1; END_IF
			END_IF;
		END_IF;
		IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) AND (T_VisuQVis.T_PlcParam.dwActualPage = 0) THEN	(* Check if the power supply of the EcoStep is switched Off *)
			T_Station.TControl.xEnable:=FALSE;
			xLoading:=FALSE;
			xStartBooting:=TRUE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			(* next step *)
			iStepFunction:=60;
			RETURN;
		END_IF;
		CASE iStepFunction OF
		(* Check *)
		1:	 IF T_StartUp.T_State.xPLCReady THEN iStepFunction:=10; END_IF
		(* Init. Visu and Set Power *)
		10:	xDeleteErrorMessage:=TRUE;	(* Reset the line message error *)
			T_VisuQVis.T_PlcParam.dwSetNewPage:=16#0;
			T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
			T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
			T_VisuQVis.T_CtrleVisu.iFunction:=1;
			(* Init. timer *)
			TimerDelayStartStation(IN:=FALSE);
			(* next Step *)
			iStepFunction:=20;
		(* Delay before start station *)
		20:	TimerDelayStartStation(IN:=TRUE, PT:=T#200ms);
			IF TimerDelayStartStation.Q THEN
				(* Init. timer *)
				TimerDelayStartStation(IN:=FALSE);
				(* Next step *)
				iStepFunction:=30;
			END_IF;
		30:	(* Check NodeState of the CANOpen for the Ecostep Axis *)
			xTmp:=	(T_AxisNodeState.bToolLeftNodeState <> 0) OR
					((T_AxisNodeState.bToolCenterNodeState <> 0) AND xMicroRodActive) OR
					(T_AxisNodeState.bToolRightNodeState <> 0) OR
					(T_AxisNodeState.bToolFeederNodeState <> 0) OR
					(T_AxisNodeState.bGrindFeederNodeState <> 0);
			IF xTmp THEN
				(* next step *)
				iStepFunction:=40;	(* At least one CANOpen Controller from the Ecostep Axis failed *)
			ELSE
				(* next step *)
				iStepFunction:=100;
			END_IF;
		(* Error CanOpen-->Ventilinsel *)
		40:	FBErrorMessage(	diErrorNr:=6,		(* At least one Ecostep CANOpen Controller failed! *)
							T_ErrorList:=T_ErrorList);
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			(* Safe the error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=6;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			iStepFunction:=999;
		100:	T_Station.TControl.xActiveStation:=TRUE;
			iStepFunction:=200;
		200:	T_Station.TControl.xEnable:=TRUE;
			iStepFunction:=300;
		300:	IF T_Station.TControl.xEnd AND T_Station.TControl.xError THEN
				FBErrorMessage(	diErrorNr:=T_Station.TControl.diErrorNr,
								T_ErrorList:=T_ErrorList);
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
				T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
				(* Safe the error *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=T_Station.TControl.diErrorNr;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
				iStepFunction:=999;
				RETURN;
			END_IF;
			IF T_Station.TControl.xEnd AND T_Station.TControl.xRdy THEN
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_ToolLeftSoftwareInfo:=T_Station.THardware.TAxisToolLeft.T_SoftwareDetails;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_ToolCenterSoftwareInfo:=T_Station.THardware.TAxisToolCenter.T_SoftwareDetails;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_ToolRightSoftwareInfo:=T_Station.THardware.TAxisToolRight.T_SoftwareDetails;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_ToolFeederSoftwareInfo:=T_Station.THardware.TAxisToolFeeder.T_SoftwareDetails;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_GrindFeederSoftwareInfo:=T_Station.THardware.TAxisGrindFeeder.T_SoftwareDetails;
				iStepFunction:=310;
			END_IF;
		310:	T_Process.xEnable:=TRUE;
			iStepFunction:=320;
		320:	IF T_Process.xRdy AND T_Process.xEnd THEN
				iStepFunction:=330;
			END_IF;
		330:	T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.iProfile:=T_NovRam.T_Data.T_Standard.T_InfoProcess.iProfile;
			T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.T_InfoProcess.sProfileName:=T_NovRam.T_Data.T_Standard.T_InfoProcess.sProfileName;
			T_VisuQVis.ptrT_ExchgParam^.T_ProfileCommon.T_Id.iNumber:=T_NovRam.T_Data.T_Standard.T_InfoProcess.iProfile;
			T_VisuQVis.ptrT_ExchgParam^.T_ProfileCommon.T_Id.sName:=T_NovRam.T_Data.T_Standard.T_InfoProcess.sProfileName;
			T_VisuQVis.T_CtrleAction.xExecute:=TRUE;
			T_VisuQVis.T_CtrleAction.iFunction:=1001;
			iStepFunction:=340;
		340:	IF NOT(T_VisuQVis.T_CtrleAction.xExecute) AND T_VisuQVis.T_CtrleAction.xDone THEN
				T_VisuQVis.T_CtrleAction.xResetParaListValue:=TRUE;
				iStepFunction:=400;
			END_IF;
		400:	IF NOT(T_VisuQVis.T_CtrleAction.xResetParaListValue) THEN
				IF T_VisuQVis.T_CtrleAction.xDone THEN iStepFunction:=984; END_IF;
				IF T_VisuQVis.T_CtrleAction.xErr THEN iStepFunction:=999; END_IF
				IF T_VisuQVis.T_CtrleAction.xDone OR T_VisuQVis.T_CtrleAction.xErr THEN
					T_VisuQVis.T_PlcParam.dwSetNewPage:=16#A;	(* Main Page wird aufgerufen *)
					T_VisuQVis.T_CtrleVisu.iFunction:=1;
					T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
				END_IF;
			END_IF;
		984:	tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine1:=1;	(* BOOTING OF THE MACHINE COMPLEATED! *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine2:=1;	(* CONFIRM AND THE MACHINE *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine3:=1;	(* WILL BE READY TO USE IT! *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine4:=1;	(*  *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			xRdy:=TRUE;
			(* next step *)
			iStepFunction:=985;
		985:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgInfo THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGeometry:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateAutoGroove:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateReference:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolCalibration:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateToolTorque:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolLeft:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolCenter:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolRight:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInToolFeeder:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateTeachInGrindFeeder:=1;
				T_VisuQVis.ptrT_ExchgParam^.T_StationCommon.iWireFeederRefIndexState:=1;
				(* next step *)
				iStepFunction:=990;
			END_IF;
		(* End function *)
		990:	T_StartUp.T_State.xCompleted:=TRUE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			T_StartUp.T_State.xBlockVisuNavigation:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
			T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=16#0;
			xLoading:=FALSE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
		(* Error function, set output disable *)
		999:	tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			T_Station.TControl.xEnable:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=0;	(* No Text *)
			(* next step *)
			iStepFunction:=9994;
		9994:(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=7;	(* WHILE BOOTING THE MACHINE *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=7;	(* AN ERROR HAS OCCURRED *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=7;	(* PLEASE CONFIRM AND CHECK *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=7;	(* THE ACCORDING ERROR *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
			(* next step *)
			iStepFunction:=9995;
		9995:IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=9996;
			END_IF;
		9996:	xLoading:=FALSE;
				xStartBooting:=TRUE;
				tTimeOutFunction:=T#0s;	(* deactivate the time out *)
				(* next step *)
				iStepFunction:=1;
		END_CASE
	END_IF;
(****************************************************************************************************************************************************)
(***********                                                      start of the execution for the function of the start up                                                          ************)
(****************************************************************************************************************************************************)

(* Control Lamp for the power supply of the Ecostep *)
	IF NOT(T_TwinSafeIn.IxPowerSupplyEcoStep) THEN
		QarxDigitalOutput[4]:=TRUE;	(* QxCtrlLampCurEcoButton *)
		T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=4;	(* Message: Release AxesCurrentButton *)
	ELSE
		QarxDigitalOutput[4]:=FALSE;	(* QxCtrlLampCurEcoButton *)
	END_IF;

(****************************************************************************************************************************************************)
(***********                           start of the controlling of the message overlay and blocking of the visualisation                             ************)
(****************************************************************************************************************************************************)
(* Activate Error Message Overlay *)
	IF xActiveErrorMsg AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		CASE iStepFunction OF
		(* Check *)
		1:	T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
			(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			(* next step *)
			iStepFunction:=10;
		10:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				T_StartUp.T_Ctrle.xDone:=TRUE;
				T_StartUp.T_Ctrle.xErr:=FALSE;
				T_StartUp.T_Ctrle.udiErrorID:=16#0;
				xActiveErrorMsg:=FALSE;
				(* next step *)
				iStepFunction:=1;
			END_IF;
		END_CASE;
	END_IF;

(* Acitvate Info Message Overlay *)
	IF xActiveInfoMsg AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xNodeFailCANOpen) THEN
		CASE iStepFunction OF
		(* Check *)
		1:	T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
			(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine1:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine2:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine3:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgInfoLine4:=iMsgNumber;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			(* next step *)
			iStepFunction:=10;
		10:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgInfo THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
				T_StartUp.T_Ctrle.xDone:=TRUE;
				T_StartUp.T_Ctrle.xErr:=FALSE;
				T_StartUp.T_Ctrle.udiErrorID:=16#0;
				xActiveInfoMsg:=FALSE;
				(* next step *)
				iStepFunction:=1;
			END_IF;
		END_CASE;
	END_IF;
(****************************************************************************************************************************************************)
(***********                           end of the controlling of the message overlay and blocking of the visualisation                             ************)
(****************************************************************************************************************************************************)

	IF T_StartUp.T_Ctrle.xSetSecurityStateON THEN
		IF NOT(xReadFirstTime) THEN
			xReadFirstTime:=TRUE;
			iStepFunctionON:=1;
			TONWaitSetSecStateON(IN:=FALSE);
		END_IF;
		CASE iStepFunctionON OF
		1:	T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
			QarxDigitalOutput[1]:=FALSE;	(* QxCtrlLampStartButton *)
			QarxDigitalOutput[2]:=FALSE;	(* QxCtrlLampStopButton *)
			QarxDigitalOutput[3]:=FALSE;	(* QxCtrlLampReleaseButton *)
			TONWaitSetSecStateON(IN:=FALSE);
			iStepFunctionON:=2;
		2:	TONWaitSetSecStateON(IN:=TRUE,PT:=T#50ms);
			IF TONWaitSetSecStateON.Q THEN
				TONWaitSetSecStateON(IN:=FALSE);
				iStepFunctionON:=3;
			END_IF;
		3:	T_TwinSafeCtrleOUT.xTwinSAFE_Run:=TRUE;	(* Start TwinSafe Groupe *)
			T_StartUp.T_Ctrle.xSetSecurityStateON:=FALSE;
			xReadFirstTime:=FALSE;
			TONWaitSetSecStateON(IN:=FALSE);
			iStepFunctionON:=1;
		END_CASE;
	ELSE
		xReadFirstTime:=FALSE;
	END_IF;

(****************************************************************************************************************************************************)
(***********                   start of the execution of an emergeny stop, missing of air or an axis communication error                  ************)
(****************************************************************************************************************************************************)
(* Emergency or air supply *)
	IF xEmergency OR xNoAirPressure OR xNodeFailCANOpen THEN
		CASE iStepFunction OF
		1:	xSetOutputDisable:=TRUE;
			T_NovRAM.T_Ctrle.xReset:=TRUE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;
			T_StartUp.T_Ctrle.iMsgNumber:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iStateStartPage:=0;	(* No Text *)
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Level.iPwSystem:=999;	(* Releas System Level *)
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Level.iActLevel:=1;
			T_Process.xError:=FALSE;
			IF T_Process.xEnable AND NOT(T_Process.xEnd) AND ((T_Process.iFunctNr >= 50) AND (T_Process.iFunctNr <= 53)) THEN
				(* Prozess ist aktiv und wurde unterbrochen, daher müssen die letzten änderungen an den InfoProzess Parameter in den NovRam abgespeichert werden *)
				(* next step *)
				iStepFunction:=2;
			ELSE
				IF xProcessAbordet THEN
					xProcessAbordet:=FALSE;
					(* next step *)
					iStepFunction:=2;
				ELSE
					(* next step *)
					iStepFunction:=3;
				END_IF;
			END_IF;
		2:	IF NOT(T_NovRAM.T_Ctrle.xReset) AND T_NovRAM.T_Ctrle.xDone THEN
				iStepFunction:=3;
			END_IF;
		3:	IF NOT(T_NovRAM.T_Ctrle.xReset) AND T_NovRAM.T_Ctrle.xDone THEN
				T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
				iStepFunction:=10;
			END_IF;
		(* waiting confirm *)
		10:	IF NOT(xSetOutputDisable) AND NOT(T_VisuQVis.T_CtrleVisu.xReset) THEN
				IF xNoAirPressure THEN
					(* next step *)
					iStepFunction:=60;
				END_IF;
				IF xEmergency THEN
					(* next step *)
					iStepFunction:=20;
				END_IF;
				IF xNodeFailCANOpen THEN
					(* next step *)
					iStepFunction:=80;
				END_IF;
			END_IF
		20:	(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=1;	(* EMERGENCY STOP BUTTON IS ACITVE! *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=1;	(* PLEASE RELEASE THIS BUTTON *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=1;	(* AND AFTER CONFIRM THIS MESSAGE *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=1;	(*  *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			(* next step *)
			iStepFunction:=30;
		30:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				IF NOT(T_TwinSafeIn.IxEmergencyStopMachine) OR NOT(T_TwinSafeIn.IxEmergencyStopStuder) THEN
					(* next step *)
					iStepFunction:=20;
				ELSE
					(* next step *)
					iStepFunction:=90;
				END_IF;
			END_IF;
		60:	(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=2;	(* NO AIR PRESSURE! *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=2;	(* PLEASE ACTIVATE THE AIR PRESSURE *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=2;	(* AND AFTER CONFIRM THIS MESSAGE *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=2;	(*  *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			FBErrorMessage(	diErrorNr:=7,		(* No Air Pressure *)
							T_ErrorList:=T_ErrorList);
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			(* Safe the error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=7;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			(* next step *)
			iStepFunction:=70;
		70:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=90;
			END_IF;
		80:	(* Overlay Message Error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=1;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageInfo:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageWarning:=0;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine1:=21;	(* AT LEAST ONE CANOPEN CONTROLLER FAILED! *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine2:=21;	(* PLEASE CHECK THE ECOSTEP AXIS *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine3:=21;	(* AND CONFIRM THIS MESSAGE *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.iMsgErrorLine4:=21;	(*  *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=TRUE;
			FBErrorMessage(	diErrorNr:=6,		(* At least one Ecostep CANOpen Controller failed! *)
							T_ErrorList:=T_ErrorList);
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
			T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
			(* Safe the error *)
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.diSetForceErrorNr:=6;
			T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xSetForceError:=TRUE;
			(* next step *)
			iStepFunction:=81;
		81:	IF T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError THEN
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xBlockVisuObject:=FALSE;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.bStateMessageError:=0;
				T_VisuQVis.ptrT_ExchgParam^.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				(* next step *)
				iStepFunction:=90;
			END_IF;
		(* end function or time out *)
		90:	xActiveErrorMsg:=FALSE;
			xActiveInfoMsg:=FALSE;
			T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=0;
			xEmergency:=FALSE;
			xNoAirPressure:=FALSE;
			xNodeFailCANOpen:=FALSE;
			xStartBooting:=TRUE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			(* next step *)
			iStepFunction:=1;
		END_CASE
	END_IF;
(****************************************************************************************************************************************************)
(***********                   start of the execution of an emergeny stop, missing of air or an axis communication error                  ************)
(****************************************************************************************************************************************************)

(* Delete of the line error message *)
	IF xDeleteErrorMessage THEN
		xDeleteErrorMessage:=FALSE;
		FBInitErrorList(T_ErrorList:= T_ErrorList);	(* Init Static Text for Error List *)
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextEnglish:='';
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextDeutsch:='';
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.sDynamicTextFrancais:='';
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.T_Message.iState:=0;
	END_IF;

(* Set Output disabled *)
	IF xSetOutputDisable THEN
		T_TwinSafeCtrleOUT.xTwinSAFE_Run:=FALSE;	(* Stop TwinSafe Groupe *)
		T_Process.xEnable:=FALSE;
		QarxDigitalOutput[1]:=FALSE;	(* QxCtrlLampStartButton *)
		QarxDigitalOutput[2]:=FALSE;	(* QxCtrlLampStopButton *)
		QarxDigitalOutput[3]:=FALSE;	(* QxCtrlLampReleaseButton *)
		QarxDigitalOutput[4]:=FALSE;	(* QxCtrlLampCurEcoButton *)
		T_Station.TControl.xEnable:=FALSE;
		T_VisuQVis.ptrT_ExchgParam^.T_Visu.iLoadingStartPage:=1;
		(* confirm *)
		xSetOutputDisable:=FALSE;
	END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_TWINSAFE
VAR
	TwinSAFEinputKlemme1: TwinSAFE_input;
	TwinSAFEinputKlemme2: TwinSAFE_input;
	TwinSAFEinputKlemme3: TwinSAFE_input;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 3
_NETWORK

_COMMENT
'Read of the TwinSAFE inputs'
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
TwinSAFEinputKlemme1
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
_EMPTY
_OPERAND
_EXPRESSION
_POSITIV
1
_EXPRESSION
_POSITIV
TwinSAFE_input
_OUTPUTS : 5
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxReadyToolRight
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxReadyToolFeeder
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxReadyGrindFeeder
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxReadyToolLeft
_NETWORK

_COMMENT
'Read of the TwinSAFE inputs'
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
TwinSAFEinputKlemme2
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
_EMPTY
_OPERAND
_EXPRESSION
_POSITIV
1
_EXPRESSION
_POSITIV
TwinSAFE_input
_OUTPUTS : 5
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxEmergencyStopMachine
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxPowerSupplyEcoStep
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxEmergencyStopStuder
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxRealseButton
_NETWORK

_COMMENT
'Read of the TwinSAFE inputs'
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
TwinSAFEinputKlemme3
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
_EMPTY
_OPERAND
_EXPRESSION
_POSITIV
1
_EXPRESSION
_POSITIV
TwinSAFE_input
_OUTPUTS : 5
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxReadyToolCenter
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_TwinSafeIn.IxContactorAuxContact

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_USB_IO_PANEL
VAR
(* Panel tastatur *)
	(* function bloc *)
	fbCtrlePanel_IO:FBHW_PANEL_IO;
	(* IO connection *)

	IarxCtrlePanelButton AT %I* : ARRAY[1..10] OF BOOL;
	QarxCtrlePanelLed AT %Q* : ARRAY[1..10] OF BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                This Programm Unit make the connection for read and set the ControlPanel Led and Button               ************)
(****************************************************************************************************************************************************)
(* Call FB *)
	fbCtrlePanel_IO(	arxButton:=IarxCtrlePanelButton,
					T_CtrlePanel:=T_CtrlePanel,
					arxLed=>QarxCtrlePanelLed);
END_PROGRAM

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS :
STRUCT
	T_CtrleSingle:ST_CTRLESINGLE;
	T_CtrleMulti:ST_CTRLEMULTI;
	T_ParamFileObj:ARRAY[1..40] OF ST_PARAM_FILE_OBJ;
	T_Config_Gen:ST_CONFIG_GENERAL;
	T_Config_ObjFileValue:ST_CONFIG_OBJECT;	(* Gilt nicht für Ecostep *)
 	T_Config_Setting:ST_CONFIG_SETTING;			(* Gilt nicht für Ecostep *)
	T_LiveValue:ST_LIVEVALUE;
	T_Oscillation:ST_OSCILLATION;					(* Gilt nicht für Ecostep *)
	T_Torque:ST_AXISTORQUE;					(* Gilt nicht für Ecostep *)
	T_FileObj:ST_AXIS_FILE_OBJ;
	T_RxPdoParameter:ST_RX_PDO_PARA;
	T_TxPdoParameter:ST_TX_PDO_PARA;
	T_SoftwareDetails:ST_SOFTWARE_INFO;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS_FILE_OBJ :
STRUCT
	sData: ARRAY[1..csiMaxAxisFileObj] OF STRING(120);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXISTORQUE :
STRUCT
(* input *)
	xActive:BOOL;
(* output *)
	rAverage:REAL;
	rMinAverage:REAL;
	rMaxAverage:REAL;
	rLastValue:REAL;
	rMinValue:REAL;
	rMaxValue:REAL;
	iSensitivity:INT;
	rMaxVariationSpindle:REAL;
	rActualVariationSpindle:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_GENERAL :
STRUCT
	sDeviceName:STRING(32);
	sDeviceFileName:STRING(32);
	sFileNamePDOMapping:STRING(32);
	sServoNetId:STRING(23);		(* Beckhoff *)
	sAmsNetId:T_AmsNetId;		(* Ecostep *)
	udiNC_TaskIdxGrp:UDINT;		(* Beckhoff *)
	udiNodeId:UDINT;				(* Ecostep *)
	iTyp:INT;
	iMachineType:INT;			(* 1 = MicroWire, 2 = MicroRod *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_OBJECT :
STRUCT
(* Object value *)
	lrMaxVelocity:LREAL;
	lrCalVelocityForward:LREAL;
	lrCalVelocityBackward:LREAL;
	lrAcceleration:LREAL;
	lrDecceleration:LREAL;
	lrJerk:LREAL;
	xSWLimitPos:BOOL;
	xHWLimitPos:BOOL;
	lrSWLimitPos:LREAL;
	xSWLimitNeg:BOOL;
	xHWLimitNeg:BOOL;
	lrSWLimitNeg:LREAL;
	lrScaleFactor:LREAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_SETTING :
STRUCT
	lrJogFast:LREAL;
	lrJogSlow:LREAL;
	lrJogStepFast:LREAL;
	lrJogStepSlow:LREAL;
	lrVelocityAbs:LREAL;
	lrVelocityRel:LREAL;
	lrVelocityProcess:LREAL;
	lrSpindleCurrentLimit:LREAL;
	xHardwareLimitPos:BOOL;
	xHardwareLimitNeg:BOOL;
	lrHWLimitDecceleration:LREAL;
	rHCRampDeceleration:REAL;
	rHCRampJerk:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEMULTI :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iNumerator:INT:=1;
	uiDenominator:UINT:=1;
	iFunction:INT:=0;

(* Ouput *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLESINGLE :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;
	iFunction:INT:=0;
	xReset:BOOL:=FALSE;
	iInput:INT:=0;
	lrPosition:LREAL:=0;
	lrDistance:LREAL:=0;
	lrVelocity:LREAL:=0;
	lrAcceleration:LREAL:=0;
	lrDecceleration:LREAL:=0;
	lrJerk:REAL:=0;
	dwOverride:DWORD:=100;
	rSetPosition:REAL:=0;
	rSetTorque:REAL:=0;
	sSend:STRING(20):='';
	lrScaleFactor:LREAL:=0;
	lrGearRatioFactor:LREAL:=0;
	lrGearRatioDivider:LREAL:=0;
	lrGearRatio:LREAL:=0;	(* calculate lrGearRatioFactor / lrGearRatioDivider *)
	iModuloDirection:INT;		(*	Enum Werte:
									 MC_Positive_Direction := 1,
    									MC_Shortest_Way :=2,
    									MC_Negative_Direction :=3,
    									MC_Current_Direction :=4
							*)
	lrHomingMethode:LREAL;
	lrHomeOffset:LREAL;
	lrHomeSpeedSwitch:LREAL;
	lrHomeSpeedZero:LREAL;
	lrHomeAcceleration:LREAL;
	lrGearFactor:LREAL;
	lrGearDivider:LREAL;
	lrSWNegLimitSwitch:LREAL;
	lrSWPosLimitSwitch:LREAL;
	xBlockAcclDeclParameter:BOOL;

(* Output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
	xPower:BOOL:=FALSE;
	xReady:BOOL:=FALSE;
	xNotMoving:BOOL:=FALSE;
	xRef:BOOL:=FALSE;
	xSlave:BOOL:=FALSE;
	xConstantVel:BOOL:=FALSE;
	xBusyNewPosAndVel:BOOL:=FALSE;
	xDriveTorque:BOOL:=FALSE;
	iOutput:INT:=0;
	xSWLimitPos:BOOL:=FALSE;
	xSWLimitNeg:BOOL:=FALSE;
	xHWLimitPos:BOOL:=FALSE;
	xHWLimitNeg:BOOL:=FALSE;
	xSpindleBlocked:BOOL:=FALSE;
	iStrokeAngleRefIndex:INT;	(* Gilt für die Prozedur für das einstellen des Referenzindex der Achse *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_LIVEVALUE :
STRUCT
	dwState:DWORD;
	uiActualTorque:UINT;
	diActualTorqueCalc:DINT;	(* entsricht dem uiActualTorque, nur dass positiver und negativer Torque berücksichtigt wird *)
	lrActualVelocity:LREAL;
	lrActualPosition:LREAL;
	bDigitalInput:BYTE;
	lrSollPosition:LREAL;
	lrActualPositionNotModulo:LREAL;
	lrActualPositionRelativ:LREAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_NODESTATE :
STRUCT
	bToolLeftNodeState:BYTE;
	bToolCenterNodeState:BYTE;
	bToolRightNodeState:BYTE;
	bToolFeederNodeState:BYTE;
	bGrindFeederNodeState:BYTE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_OSCILLATION :
STRUCT
	rFrequence:REAL;
	rOffset:REAL;
	rPosTorqueLimitOffset:REAL;
	iCycle:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PARAM_FILE_OBJ :
STRUCT
	udiIdxGroup:UDINT:=0;
	udiIndexOffset:UDINT:=0;
	udiLength:UDINT:=0;
	lrReal:LREAL:=0;
	sName:STRING(20);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RX_PDO_PARA :
STRUCT
	udiProfileVelocity:UDINT;
	diTargetVelocity:DINT;
	udiProfileDeceleration:UDINT;
	udiProfileAcceleration:UDINT;
	diTargetPosition:DINT;
	iGearFactor:INT;
	uiGearDivider:UINT;
	iControlWord:INT;
	siOperationModes:SINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_SOFTWARE_INFO :
STRUCT
	lrSoftwareVersion:REAL;
	lrBuildVersion:REAL;
	lrDateCode:REAL;
	sDateCode:STRING;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/AXIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TX_PDO_PARA :
STRUCT
	diActualPosition:DINT;
	diActualVelocity:DINT;
	uiStatusWord:UINT;
	iActualCurrent:INT;
	udiDigitalInput:UDINT;
	siOperationModesDisplay:SINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/CX1020' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_BOXID :
STRUCT
(* control structure *)
	T_Ctrle:ST_CTRLE_DEVICEID;
(* Data *)
	(* servo Beckhoff-->Lightbus *)
	T_Servo_ToolLeft:ST_BOXID_DATA_ADR;
	T_Servo_ToolCenter:ST_BOXID_DATA_ADR;
	T_Servo_ToolRight:ST_BOXID_DATA_ADR;
	T_Servo_ToolFeeder:ST_BOXID_DATA_ADR;
	T_Servo_GrindFeeder:ST_BOXID_DATA_ADR;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/CX1020' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_BOXID_DATA_ADR :
STRUCT
	sDeviceName:T_MaxString;
	sBoxName:T_MaxString;
	xDeviceOption:BOOL;
	wAddrBox:WORD;
	sAmsNetId:T_AmsNetId;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/CX1020' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_DEVICEID :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	xLocked:BOOL:=FALSE;
(*
	iStationNr:INT:=0;
	iStationType:INT:=0;
	iSpindleType:INT:=0;
*)
	iMachineType:INT:=0;

(* output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/CX1020' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_DEVICEID :
STRUCT
(* control structure *)
	T_Ctrle:ST_CTRLE_DEVICEID;
(* Data *)
	(* PLC *)
		T_CX1020:ST_DEVICEID_DATA_ADR;
	(* feldbus *)
		T_CANOpenMaster:ST_DEVICEID_DATA_ADR;
		T_LightbusMaster:ST_DEVICEID_DATA_ADR;
	(* NovRAM *)
		T_NovRAM:ST_DEVICEID_DATA_ADR;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/CX1020' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_DEVICEID_DATA_ADR :
STRUCT
	sDeviceName:T_MaxString;
	xDeviceOption:BOOL;
	udiDeviceID:UDINT;
	sAmsNetId:T_AmsNetId;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_ANALOG :
STRUCT
(* input *)
	tDelayActiv:TIME;
	iAnalogIN:INT;
	rForceIn:REAL;
	iRampFctOn:INT;
	iRampFctOff:INT;
	rStepValue:REAL;
	rLengthIn:REAL;
(* Output *)
	xActiv:BOOL;
	iAnalogOut:INT;
	rForceOut:REAL;
	tTimeActivOn:TIME;
	tTimeActivOff:TIME;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_ANALOG_CYL :
STRUCT
(* input *)
	tDelayActiv:TIME;
	iAnalogIN:INT;
	rForceIn:REAL;
(* Output *)
	xActiv:BOOL;
	iAnalogOut:INT;
	rForceOut:REAL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG :
STRUCT
	tDelayOn:TIME;
	tDelayOff:TIME;
	tDelayPreOn:TIME;
	tDelayPreOff:TIME;
	xCtrlePosOn:BOOL;
	xCtrlePosOff:BOOL;
	tTimeOut:TIME;
	xActivState:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLECYL :
STRUCT
(* input *)
	xFBActiv:BOOL;
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
(* output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
	xStatePosOn:BOOL;
	xStatePosOff:BOOL;
	T_AnalogCylinder:ST_ANALOG_CYL;
	T_Standard:ST_STANDARD;
	T_Analog:ST_ANALOG;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CYLINDER :
STRUCT
	T_Config:ST_CONFIG;
	T_CtrleCyl:ST_CTRLECYL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STANDARD :
STRUCT
(* Input *)
	tDelayActiv:TIME;
	tDelayAfterSensor:TIME;
(* Output *)
	xActivOn:BOOL;
	xActivOff:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Geometry' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_GEOMETRY :
STRUCT
	arStartDiameter: ARRAY [1..4] OF REAL;
	arEndDiameter: ARRAY [1..4] OF REAL;
	arSectionLength: ARRAY [1..4] OF REAL;
	arSectionPitch: ARRAY [1..4] OF REAL;
	axActiveSection:ARRAY [1..4] OF BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Geometry' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_GEOMETRY_COMMON :
STRUCT
	abSectionSelectForm:ARRAY [1..4] OF BYTE; (* 0=Disactivate Section, 1=Zylindre large, 2=Zylindre small, 3=Cone Negative, 4=Cone Positive *)
	wWrongInput:WORD;
	rMinToolDiameter:REAL;
	rMaxToolDiameter:REAL;
	rMinToolLength:REAL;
	rMaxToolLength:REAL;
	T_Geometry:ST_GEOMETRY;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_HDD :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
	tTimeOut:TIME;
	xLocked:BOOL:=FALSE;

(* output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD :
STRUCT
	T_Ctrle:ST_CTRLE_HDD;
	T_Config:ST_HDD_CONFIG;
	T_File:ST_HDD_FILE;
	T_Data:ST_HDD_DATA;
END_STRUCT
END_TYPE


(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD_CONFIG :
STRUCT
	sNetId:T_AmsNetId;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD_DATA :
STRUCT
	sData: ARRAY[1..csiMaxFileLine] OF STRING(255);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD_FILE :
STRUCT
	sPathAndFileName:STRING(255):='';
	sOldPathAndFileName:STRING(255):='';
	dwPtrWriteBuffer:DWORD:=0;
	udiLenBuffer:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Panel' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEPANEL :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;
	iFunction:INT:=0;
	xReset:BOOL:=FALSE;
(* output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
	udiButton:UDINT:=0;
	udiLED:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Process' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_FCTPROCESS :
STRUCT
	xEnable : BOOL :=FALSE;
	xStart: BOOL := FALSE;
	xStop: BOOL := FALSE;
	xStopCycle : BOOL :=FALSE;
	xQuitErr : BOOL := FALSE;
	xAbord : BOOL := FALSE;
	xProcessHold : BOOL;
	xEnd : BOOL := FALSE;
	xError : BOOL := FALSE;
	diErrorNr : DINT := 0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Process' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROCESS :
STRUCT
	iFunctNr : INT :=0;
	xEnable : BOOL := FALSE;
	xStart : BOOL := FALSE;
	xEnd : BOOL := FALSE;
	xStop : BOOL := FALSE;
	xStopCycle : BOOL :=FALSE;
	xRdy : BOOL := FALSE;
	xError : BOOL := FALSE;
	diErrorNr : DINT :=0;
	xQuitError : BOOL := FALSE;
	xProcessHold : BOOL;
	wStatus : WORD := 0;
	xAbord : BOOL := FALSE;
	xReferenced : BOOL := FALSE;
	TFctProcess : ST_FCTPROCESS;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE :
STRUCT
	T_Ctrle:ST_PROFILE_CTRLE;
	T_Id:ST_PROFILE_ID;
	(*T_DataOnline:ST_PROFILEONLINECHANGE;*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_CTRLE :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;

(* Output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_ID :
STRUCT
	iNumber:INT;
	sName:STRING(30);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_LIST :
STRUCT
	iNumber:INT;
	sName:STRING(30);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_LIST_MANAGE :
STRUCT
	xListProfileUp:BOOL;
	xListProfileDown:BOOL;
	xListProfileUpFast:BOOL;
	xListProfileDownFast:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_BUTTON :
STRUCT
	xInputState:BOOL;
	xLedState:BOOL;
	xResetTime:BOOL;
	tPressTime:TIME;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIGPAGE :
STRUCT
	sName:STRING(32);
	wMaskBtPanelLeft:WORD;
	wMaskBtPanelRight:WORD;
	wMaskFunctionPanel:WORD;
	wMaskTouchScreenNavPanel:WORD;
	(* active movement mask *)
	wMaskActiveMachineBtPanelLeft:WORD;
	wMaskActiveMachineBtPanelRight:WORD;
	wMaskActiveMachineFunctionPanel:WORD;
	wMaskActiveMachineNavPanel:WORD;
	(* functions *)
	aiRTrigActionPanelRight:ARRAY[1..5] OF INT:=5(0);
	aiFTrigActionPanelRight:ARRAY[1..5] OF INT:=5(0);
	aiDelayActionPanelRight:ARRAY[1..5] OF INT:=5(0);
	aiRTrigActionFunctionPanel:ARRAY[1..12] OF INT:=12(0);
	aiFTrigActionTouchScreenNavPanel:ARRAY[1..6] OF INT:=6(0);
	(* start/stop button *)
	xMaskBtStart:BOOL;
	xMaskBtStop:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEACTION :
STRUCT
(* Input *)
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
	xResetParaListValue:BOOL;
(* Output *)
	xDone:BOOL;
	xNotReady:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEBUTTON :
STRUCT
	T_Start:ST_BUTTON;
	T_Stop:ST_BUTTON;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEPROCESS :
STRUCT
(* Input *)
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
(* Output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEVISU :
STRUCT
(* Input *)
	xActive:BOOL;
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
(* Output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
	xQvis:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_BTFUNCTIONPANEL :
STRUCT
	wState:WORD;
	wActivBt:WORD;
	wNotMasktext:WORD;
	bF1SelectText:BYTE;
	bF2SelectText:BYTE;
	bF3SelectText:BYTE;
	bF4SelectText:BYTE;
	bF5SelectText:BYTE;
	bF6SelectText:BYTE;
	bF7SelectText:BYTE;
	bF8SelectText:BYTE;
	bF9SelectText:BYTE;
	bF10SelectText:BYTE;
	bF11SelectText:BYTE;
	bF12SelectText:BYTE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_CONFIG :
STRUCT
	xNoTouchScreenBtPanel:BOOL;
	iEditParam:INT;
	xBlockParaListNavi:BOOL;
	xBlockParaListNavi1:BOOL;
	xBlockNavParaList:BOOL;
	xBlockNavParaListTeachRot:BOOL;
	xBlockProfilList:BOOL;
	iSelectParaList:INT;
	iSelectParaListTeachRot:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_CYLINDER :
STRUCT
(*	iSelectCylToolTension:INT; *)
	xToolTension:BOOL;
	bPosToolTension:BYTE;

	T_ParamToolTension:ST_EXCHG_PARAM_CYL_FORCE;
	iSelectToolTensionForce:INT;
	rToSetToolTensionForce:REAL;
(*22.12.2009: KFS	{	*)
	iSelectCylinder_Sonder1:INT;

	xCylToolLeft:BOOL;
	bPosCylToolLeft:BYTE;

	xCylToolRight:BOOL;
	bPosCylToolRight:BYTE;

	xCylToolCenter:BOOL;
	bPosCylToolCenter:BYTE;

	xCylToolPrismaLeft:BOOL;
	bPosCylToolPrismaLeft:BYTE;

	xCylToolPrismaRight:BOOL;
	bPosCylToolPrismalRight:BYTE;
(*22.12.2009: KFS	}	*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_FUNCTION_COMMON :
STRUCT
	(* Overlay for input measured Tool diameter *)
	xOpenOverlayMeasureInput:BOOL;
	(* Overlay for input the correction of the GrindFeeder Plunge *)
	xOpenOverlaySetGrindPlunge:BOOL;
	(* Overlay for open a Messagebox *)
	xOpenOverlayMessageBox:BOOL;
	sMessageBoxLine1:STRING(50);
	sMessageBoxLine2:STRING(50);
	sMessageBoxLine3:STRING(50);
	sMessageBoxLine4:STRING(50);
	sMessageBoxLine5:STRING(50);
	sMessageBoxLine6:STRING(50);
	xSaveButton:BOOL;
	xExitButton:BOOL;
	rInputMeasToolDiameter:REAL;
	rInputGrindPlunge:REAL;
	xHideProgressbar:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_INFO_PROCESS :
STRUCT
	iProfile:INT;
	sProfileName:STRING(30);
	xOnlineValueModified:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_INFOVALUE_COMMON :
STRUCT
	rActualGrindAxisPosition:REAL;
	rActualGrindAxisSpeed:REAL;
	rActualToolRotSpeed:REAL;
	rActualWireFeedPosition:REAL;
	rActualWireFeedSpeed:REAL;
	rActualToolLeftTorque:REAL;
	rCalculToolLeftTorque:REAL;
	rActualToolCenterTorque:REAL;
	rCalculToolCenterTorque:REAL;
	rActualToolRightTorque:REAL;
	rCalculToolRightTorque:REAL;
	rToolLengthCalibration:REAL;
	rToolDiameter:REAL;
	rToolTotalLength:REAL;
	rPitchCalibration:REAL;
	rToolTensionForce:REAL;
	iTotalCountDownCycle:INT;
	iCountDownCycle:INT;
	iTotalCountDownPlungeCycle:INT;
	iCountDownPlungeCycle:INT;
	iTotalCountDownGrooveCycle:INT;
	iCountDownGrooveCycle:INT;
	tAutoTimeTotal:TIME;
	tAutoTimeLeft:TIME;

	rCorrectionToolDiameter:REAL;
	xKeyPadActivation:BOOL;

	(* Progressbar for Tool Calibration *)
	bProgressbarToolCalibration:BYTE;
	bProgressbarAutoGeometry:BYTE;
	bProgressbarAutoGroove:BYTE;

	(* Effectiv working geometry *)
	arStartDiameter: ARRAY [1..4] OF REAL;
	arEndDiameter: ARRAY [1..4] OF REAL;
	(* Part State display *)
	bActivePartNumber:BYTE;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_LEVEL :
STRUCT
	iActLevel:INT;
	iPwSystem:INT;
	iRandom:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_MACHINE :
STRUCT
	iFunction:INT;
	udiState_Input:UDINT;
	T_Process:ST_EXCHG_PROCESS;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_MESSAGE :
STRUCT
	iState:INT;
	iStateBIOS:INT;
	sDynamicTextEnglish:STRING(100);
	sDynamicTextDeutsch:STRING(100);
	sDynamicTextFrancais:STRING(100);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_MESSAGE_ERROR :
STRUCT
	asMsgErrorList:ARRAY [1..20] OF STRING(100);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_AUTOGEOMETRY :
STRUCT
	rPlungeLengthToolFeedGeometry:REAL;
	rPlungeSpeedGrindFeedGeometry:REAL;
	rDisplaceLengthToolFeedGeometry:REAL;
	rDisplaceSpeedGrindFeedGeometry:REAL;
	xPlungeActivationGeometry:BOOL;
	xDisplaceActivationGeometry:BOOL;
	iCycleGeometry:INT;
	rPlungeCycleGrindFeedGeometry:REAL;
	rSpeedToolRotationGeometry:REAL;
(*08.07.2014: KFS	{	*)
	xWarmUp:BOOL;
(*08.07.2014: KFS	}	*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_AUTOGROOVE :
STRUCT
	rPlungeLengthToolFeedGroove:REAL;
	rPlungeSpeedGrindFeedGroove:REAL;
	rDisplaceLengthToolFeedGroove:REAL;
	rDisplaceSpeedGrindFeedGroove:REAL;
	xPlungeActivationGroove:BOOL;
	xDisplaceActivationGroove:BOOL;

	rPitchGroove:REAL;
	rSpeedToolRotationGroove:REAL;
	xBlockGrindFeeder:BOOL;
	(*20091207 Number of grooves*)
	iNumberOfGrooves:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_CALIBRATION :
STRUCT
	rPlungeLengthToolFeedCalib:REAL;
	rPlungeSpeedGrindFeedCalib:REAL;
	rDisplaceLengthToolFeedCalib:REAL;
	rDisplaceSpeedGrindFeedCalib:REAL;
	xPlungeActivationCalib:BOOL;
	xDisplaceActivationCalib:BOOL;

	rPitchCalib:REAL;
	rSpeedToolRotationCalib:REAL;
	rPlungeLengthGrindFeedCalib:REAL;
	rToolLengthCylinderPartCalib:REAL;
	rStartPosToolFeedCalib:REAL;
	rMeasurePosToolFeedCalib:REAL;	(* Für MicroRod *)
	rMeasureOffsetToolFeedCalib:REAL; (* Für MicroWire *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_CYL_FORCE :
STRUCT
	rForce:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_MACHINE_CONFIG :
STRUCT
	iConfigMachineType:INT;
	iConfigAxisType:INT;
	iConfigVisuNavigation:INT;
	rConfigMaxToolLength:REAL;
	rConfigMaxToolLengthOriginal:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_POSITION :
STRUCT
	rLoadPosToolFeedAuto:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_PRISM :
STRUCT
	rPrismaDistanceD1:REAL;
	rPrismaDistanceD2:REAL;
	rPrismaAngleA:REAL;
	rToolDiameterMin:REAL;
	rToolDiameterMax:REAL;
	bStateInputPrisma:BYTE;	(* 0= 3 value prisma, 1 = 3 value prisma input para, 2 = 2 value prisma, 3 = 2 value prisma input para *)
	rPrismaFactor:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_PROCESS :
STRUCT
	rStartPosToolFeedAuto:REAL;
	rSpeedForwardFastGrindFeed:REAL;
	rSpeedForwardSlowGrindFeed:REAL;
	rSpeedBackwardGrindFeed:REAL;
	rToolTensionProcess:REAL;
	rToolDiameterProcess:REAL;
	rSecurityPosGrindFeedProcess:REAL;
	rOffsetBeforeToolDiaGrindFeedProcess:REAL;
	rSpeedStartPosToolFeedProcess:REAL;
	rStartPosAutoGrooveToolRotation:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_TEACHIN :
STRUCT
	rIncSlow:REAL;
	rIncFast:REAL;
	rVelSlow:REAL;
	rVelFast:REAL;
	rRefPosition:REAL;
	rRefSpeed:REAL;
	rPositionSpeed:REAL;
	rAcceleration:REAL;
	rDeceleration:REAL;
	rOffsetSWPosEndSwitch:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_TOOLTENSIONSYSTEM :
STRUCT
	rPistonDiameterTT:REAL;		(* the piston diameter of the clinder ToolTension  *)
	rPistonDiameterTT2:REAL;		(* the piston diameter of the cylinder ToolTension (Kolbenstange)*)
	rAirPressureTT:REAL;			(* max air pressure of the servo ventil *)
	rMaxForceTT:REAL;			(* calculated max. force of the ToolTension *)
	rFactorForce:REAL;			(* gear ratio of cylinder *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PROCESS :
STRUCT
	wState:WORD;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PROFILE_COMMON :
STRUCT
(* State *)
	xImportProzessData:BOOL:=FALSE;
(* Array *)
	T_Id:ST_PROFILE_ID;
	T_ProfileManage:ST_PROFILE_LIST_MANAGE;
	T_ProfileList:ARRAY[1..10] OF ST_PROFILE_LIST;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_SAFETY_CTRL :
STRUCT
	bStateMessageError:BYTE;
	bStateMessageWarning:BYTE;
	bStateMessageInfo:BYTE;
	xConfirmMsgError:BOOL;
	xConfirmMsgWarning:BOOL;
	xConfirmMsgInfo:BOOL;
	iMsgErrorLine1:INT;
	iMsgErrorLine2:INT;
	iMsgErrorLine3:INT;
	iMsgErrorLine4:INT;
	iMsgInfoLine1:INT;
	iMsgInfoLine2:INT;
	iMsgInfoLine3:INT;
	iMsgInfoLine4:INT;
	iStateStartPage:INT;
	xSetForceError:BOOL;
	diSetForceErrorNr:DINT;
	(* State Function *)
	bStateToolCalibration:BYTE;
	bStateToolTorque:BYTE;
	bStateAutoGeometry:BYTE;
	bStateAutoGroove:BYTE;
	bStateReference:BYTE;
	bStateTeachInToolLeft:BYTE;
	bStateTeachInToolCenter:BYTE;
	bStateTeachInToolRight:BYTE;
	bStateTeachInToolFeeder:BYTE;
	bStateTeachInGrindFeeder:BYTE;
	bStateReferenceMaxToolLength:BYTE;
	xBlockVisuObject:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_STATION_COMMON :
STRUCT
	(* Parameter *)
	T_InfoProcess:ST_EXCHG_INFO_PROCESS;
	T_ParamToolTensionSystem:ST_EXCHG_PARAM_TOOLTENSIONSYSTEM;
	T_PrismPara:ST_EXCHG_PARAM_PRISM;
	T_ProcessPara:ST_EXCHG_PARAM_PROCESS;
	T_AutoGeometryPara:ST_EXCHG_PARAM_AUTOGEOMETRY;
	T_AutoGroovePara:ST_EXCHG_PARAM_AUTOGROOVE;
	T_CalibrationPara:ST_EXCHG_PARAM_CALIBRATION;

	(* State Machine *)
	bStateMachine:BYTE;
	bStateMachineLED:BYTE;

	(* State Axis*)
	wState:DWORD;
	bStateAxisReelLeft:BYTE;
	bStateAxisReelCenter:BYTE;
	bStateAxisReelRight:BYTE;
	bStateAxisWireFeeder:BYTE;
	bStateAxisGrind:BYTE;

	(* State Cylinder *)

	bStateToolDiameter:BYTE;

	(* Max ToolLength *)
	rConvertMaxToolLength:REAL;	(* Convert from cm to mm-->it need for the max value for ToolFeed Position *)

(* Machine Configuration *)
	iConfigMachineType:INT;
	iConfigAxisType:INT;
	iConfigVisuNavigation:INT;
	rConfigMaxToolLength:REAL;
	(* 30.11.2010 KFS:	{	*)
	rConfigMaxToolLengthOriginal:REAL;
	(* 30.11.2010 KFS:	}	*)
(* TeachIn ToolRotation *)
	rActualToolRotationSpeed:REAL;
	rNewToolRotationSpeed:REAL;
(* TeachIn ToolFeeder *)
	rActualToolFeederSpeed:REAL;
	rActualToolFeederPosition:REAL;
	rNewToolFeederPosition:REAL;
	rOldToolFeederPosition:REAL;
(* TeachIn GrindFeeder *)
	rActualGrindFeederSpeed:REAL;
	rActualGrindFeederPosition:REAL;
	rNewGrindFeederPosition:REAL;
	rOldGrindFeederPosition:REAL;

(* Firmware Information ToolLeft *)
	T_ToolLeftSoftwareInfo:ST_SOFTWARE_INFO;
(* Firmware Information ToolCenter *)
	T_ToolCenterSoftwareInfo:ST_SOFTWARE_INFO;
(* Firmware Information ToolRight *)
	T_ToolRightSoftwareInfo:ST_SOFTWARE_INFO;
(* Firmware Information ToolFeeder *)
	T_ToolFeederSoftwareInfo:ST_SOFTWARE_INFO;
(* Firmware Information GrindFeeder *)
	T_GrindFeederSoftwareInfo:ST_SOFTWARE_INFO;

(* Max value ToolRotation *)
	rMaxSpeedToolRotation:REAL;

(* Gilt für die Prozedur für das einstellen des Referenzindex der Achse *)
	iWireFeederAngleRefIndex:INT;
	iWireFeederRefIndexState:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TEACHIN :
STRUCT
	xSlowFastToolRotation:BOOL;
	xSlowFastToolFeed:BOOL;
	xSlowFastGrindFeeder:BOOL;
	iSelectAxisToolRotation:INT;
	iSelectAxisWireFeeder:INT;
	iSelectAxisGrind:INT;
	iSaveToolFeederPos:INT;
	iSaveGrindFeederPos:INT;
	TParam_ToolLeft:ST_EXCHG_PARAM_TEACHIN;
	TParam_ToolCenter:ST_EXCHG_PARAM_TEACHIN;
	TParam_ToolRight:ST_EXCHG_PARAM_TEACHIN;
	TParam_ToolFeeder:ST_EXCHG_PARAM_TEACHIN;
	TParam_GrindFeeder:ST_EXCHG_PARAM_TEACHIN;
	TParam_AxisPosition:ST_EXCHG_PARAM_POSITION;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TOUCHSCREENBTPANEL :
STRUCT
	iNotMaskTextBt:INT;
	iActivBtLeft:INT;
	iStateBtLeft:INT;
	iActivBtRight:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TOUCHSCREENNAVPANEL :
STRUCT
	wState:WORD;
	wNotMasktext:WORD;
	wActivBt:WORD;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_VISU :
STRUCT
(* Message structure *)
	T_Message:ST_EXCHG_MESSAGE;
(* Error List Structure *)
	T_MsgErrorEnglish:ST_EXCHG_MESSAGE_ERROR;
	T_MsgErrorDeutsch:ST_EXCHG_MESSAGE_ERROR;
	T_MsgErrorFrancais:ST_EXCHG_MESSAGE_ERROR;
(* Delete Error List *)
	xDeleteErrorList:BOOL;
(* Level structure *)
	T_Level:ST_EXCHG_LEVEL;
(* Variable *)
	iQVisActivNewPage:INT:=0;
	iLoadingStartPage:INT:=1;
	bActivSpecialLayer:BYTE:=0;
	xKey_Enter:BOOL;
	xKey_Escape:BOOL;
	xLoadingProcessDone:BOOL;
	rSWVersion:REAL:=4500304;	(* V4500304.pro *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PAGE :
STRUCT
	iIndexConfigPage:INT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_QVIS :
STRUCT
	T_PageIndex:ARRAY[1..999] OF ST_PAGE;
	T_ConfigPage:ARRAY[1..csiMaxPage] OF ST_CONFIGPAGE;
	T_CtrleVisu:ST_CTRLEVISU;
	T_PlcParam:ST_VISU_PLC_PARAM;
	T_CtrleAction:ST_CTRLEACTION;
	T_CtrleProcess:ST_CTRLEPROCESS;
	ptrT_ExchgParam:POINTER TO ST_QVIS_EXCHG_PARAM;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_QVIS_EXCHG_PARAM :
STRUCT
	T_Config:ST_EXCHG_CONFIG;
	T_Visu:ST_EXCHG_VISU;
	T_TouchScreenBtPanel:ST_EXCHG_TOUCHSCREENBTPANEL;
	T_BtFunctionPanel:ST_EXCHG_BTFUNCTIONPANEL;
	T_TouchScreenNavPanel:ST_EXCHG_TOUCHSCREENNAVPANEL;
	T_SafetyCtrl:ST_EXCHG_SAFETY_CTRL;

	T_Machine:ST_EXCHG_MACHINE;

	T_TeachIn:ST_EXCHG_TEACHIN;

	T_Cylinder:ST_EXCHG_CYLINDER;

	T_GeometryCommon:ST_GEOMETRY_COMMON;
	T_ProfileCommon:ST_EXCHG_PROFILE_COMMON;
	T_StationCommon:ST_EXCHG_STATION_COMMON;
	T_FunctionCommon:ST_EXCHG_FUNCTION_COMMON;
	T_InfoValueCommon:ST_EXCHG_INFOVALUE_COMMON;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_QVISCTRLE :
STRUCT
	dwInCommand:DWORD;
	dwInCount:DWORD;
	dwInQVisCtrlAddress:DWORD;
	dwInParameterAddress:DWORD;
	dwOutCount:DWORD;
	diOutStatus:DINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/QVis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_VISU_PLC_PARAM :
STRUCT
	dwSetNewPage:DWORD;
	dwActualPage:DWORD;
	dwPreviousPage:DWORD;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_DATA_RETAIN :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
	udiSrcLen:UDINT;
	udiDestLen:UDINT;
	udipSrcAddr:UDINT;
	udipDestAddr:UDINT;
	tTimeOut:TIME;
	xBlockReadFirstTime:BOOL;

(* Output *)
	xFirstRead:BOOL:=FALSE;
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_DATA_RETAIN :
STRUCT
	T_ProcessImageLoadData:ST_RETAIN_DATA_PROCESSIMAGE;		(* All value for a profile, is the value of the profile *)
	T_ProcessImageData:ST_RETAIN_DATA_PROCESSIMAGE;			(* All value for a profile, is the value of the process image parameter *)
	T_Standard:ST_RETAIN_DATA;							(*  *)
	T_IDProfileStation:ARRAY[1..csiMaxProfile] OF ST_PROFILE_ID;	(* List of saved profil *)
	T_ErrorNrList:ST_RETAIN_ERROR_DATA;					(* List of occured error *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_NOVRAM :
STRUCT
	T_Ctrle:ST_CTRLE_DATA_RETAIN;
	T_Data:ST_DATA_RETAIN;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA :
STRUCT
	T_MachineConfig:ST_EXCHG_PARAM_MACHINE_CONFIG;
	T_TeachINToolLeft:ST_EXCHG_PARAM_TEACHIN;
	T_TeachINToolCenter:ST_EXCHG_PARAM_TEACHIN;
	T_TeachINToolRight:ST_EXCHG_PARAM_TEACHIN;
	T_TeachINToolFeeder:ST_EXCHG_PARAM_TEACHIN;
	T_TeachINGrindFeeder:ST_EXCHG_PARAM_TEACHIN;
	T_Cyl_ToolTension:ST_EXCHG_PARAM_CYL_FORCE;
	T_ToolTensionSystem:ST_EXCHG_PARAM_TOOLTENSIONSYSTEM;
	T_InfoProcess:ST_EXCHG_INFO_PROCESS;
	T_AxisPosition:ST_EXCHG_PARAM_POSITION;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA_PROCESSIMAGE :
STRUCT
	T_GeometryPara:ST_GEOMETRY;
	T_PrismPara:ST_EXCHG_PARAM_PRISM;
	T_ProcessPara:ST_EXCHG_PARAM_PROCESS;
	T_AutoGeometryPara:ST_EXCHG_PARAM_AUTOGEOMETRY;
	T_AutoGroovePara:ST_EXCHG_PARAM_AUTOGROOVE;
	T_CalibrationPara:ST_EXCHG_PARAM_CALIBRATION;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_ERROR_DATA :
STRUCT
	adiErrorListMachine:ARRAY [1..20] OF DINT;
	asErrorTimeStampMachine:ARRAY [1..20] OF STRING(12);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StartUp' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLESTARTUP :
STRUCT
(* Input *)
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
	iMsgNumber:INT;
	xSetSecurityStateON:BOOL;
(* Output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StartUp' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STARTUP :
STRUCT
	T_Ctrle:ST_CTRLESTARTUP;
	T_State:ST_STARTUPSTATE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StartUp' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STARTUPSTATE :
STRUCT
	xPLCReady:BOOL;
	xCompleted:BOOL;
	xBlockChangeMovementVisu:BOOL;	(* For active message overlay, block the visu *)
	xSecurityCircuitActive:BOOL;	(* TRUE = No Energy-->Circuit is open, FALSE = Energy is on-->Circuit is closed *)
	xBlockVisuNavigation:BOOL;		(* For active movement, block the visu *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Static_Error_List' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_ERROR_LIST :
STRUCT
	asErrorListEnglish: ST_LANGUAGE_LIST;
	asErrorListDeutsch: ST_LANGUAGE_LIST;
	asErrorListFrancais: ST_LANGUAGE_LIST;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Static_Error_List' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_LANGUAGE_LIST :
STRUCT
	T_LanguagList:ARRAY [1..255] OF STRING(100);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Station' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONTROL :
STRUCT
	xActiveStation : BOOL;
	xActiveHardware : BOOL;
	xHardwareConfigError : BOOL;
	iFunctNr : INT :=0;
	xEnable : BOOL := FALSE;
	xSecurityCircuitOn : BOOL := FALSE;
	xSecurityCircuitOff : BOOL := FALSE;
	xStart : BOOL := FALSE;
	xEnd : BOOL := FALSE;
	xStop : BOOL := FALSE;
	xRdy : BOOL := FALSE;
	xError : BOOL := FALSE;
	diErrorNr : DINT :=0;
	xQuitError : BOOL := FALSE;
	wStatus : WORD := 0;
	xAbord : BOOL := FALSE;
	xReferenced : BOOL := FALSE;
	xResetReference : BOOL :=FALSE;
	xSetReference : BOOL :=FALSE;
	xHWAxesActive : BOOL := FALSE;
	xActiveMovement : BOOL;
	xResetHardware:BOOL;
	iCountDownPlungeCycle:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Station' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRL_FUNCTION :
STRUCT
	xStart: BOOL := FALSE;
	xStop: BOOL := FALSE;
	xQuitErr : BOOL := FALSE;
	xStepByStep : BOOL := FALSE;
	xAbord : BOOL := FALSE;
	xEnd : BOOL := FALSE;
	xError : BOOL := FALSE;
	iErrorNr : DINT := 0;
	xReset:BOOL:=FALSE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Station' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HARDWARE :
STRUCT
	TAxisToolLeft:ST_AXIS;
	TAxisToolCenter:ST_AXIS;
	TAxisToolRight:ST_AXIS;
	TAxisToolFeeder:ST_AXIS;
	TAxisGrindFeeder:ST_AXIS;
	TCylToolTension:ST_CYLINDER;
(*22.12.2009: KFS {    *)
	TCylToolLeftActive:ST_CYLINDER;
	TCylToolRightActive:ST_CYLINDER;
	TCylToolCenterActive:ST_CYLINDER;
	TCylToolPrismaLeftActive:ST_CYLINDER;
	TCylToolPrismaRightActive:ST_CYLINDER;
	TToolFeederWorkLength:ST_CYLINDER;
(*22.12.2009: KFS }   *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Station' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STATION :
STRUCT
	xActive : BOOL;
	TControl:ST_CONTROL;
	TCtrlFunction:ST_CTRL_FUNCTION;
	T_WorkTool:ST_WORKTOOL;
	THardware:ST_HARDWARE;
	T_MachineConfig:ST_EXCHG_PARAM_MACHINE_CONFIG;
	rStartPosAutoGrooveToolRotation:REAL;
	xOverwriteMaxToolLength:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Station' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_WORKTOOL :
STRUCT
(* Input parameter *)
	rToolRotationSpeed:REAL;		(* U/Min *)
	rPitch:REAL;						(* mm/U *)
	rToolLength:REAL;				(* cm *)
	rGrindFeederPlunge:REAL;			(* um *)
	iBaseGearDivider:INT;				(* No Unit *)
	rPrismaFactor:REAL;				(* No Unit *)
	rToolRightGearRatio:REAL;			(* No Unit *)
	rToolFeederGearRatio:REAL;		(* No Unit *)
	rToolFeederScaleFactor:REAL;		(* inc/mm *)
	rGrindFeederScaleFactor:REAL;		(* inc/um *)
	rPlungeLengthToolFeed:REAL;		(* mm *)
	rPlungeSpeedGrindFeed:REAL;		(* um/s *)
	rDisplaceLengthToolFeed:REAL;	(* mm *)
	rDisplaceSpeedGrindFeed:REAL;	(* um/s *)
	xPlungeActivation:BOOL;			(* No Unit *)
	xDisplaceActivation:BOOL;			(* No Unit *)
(* Output parameter *)
	rToolRotationSpeedMotor:REAL;	(* inc/64s *)
	rToolFeederSpeedUnit:REAL;		(* mm/s *)
	rToolFeederSpeedMotorRel:REAL;	(* inc/64s *)
	rToolFeederSpeedMotorAbs:REAL;	(* inc/64s *)
	iToolFeederGearFactor:INT;		(* No Unit *)
	iToolFeederGearDivider:INT;		(* No Unit *)
	rToolFeederRelPositionUnit:REAL;	(* mm *)
	rToolFeederRelPositionMotor:REAL;	(* inc *)
	rGrindFeederSpeedUnit:REAL;		(* um/s *)
	rGrindFeederSpeedMotor:REAL;	(* inc/um *)
	rTimeLeftWork:REAL;				(* s *)
	iTotalCountDownPlungeCycle:INT;	(* No Unit *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_CTRLE_IN :
STRUCT
	xTwinSAFE_Group_FB_Error: BOOL;
	xTwinSAFE_Group_COM_Error: BOOL;
	xTwinSAFE_Group_OUT_Error: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_CTRLE_OUT :
STRUCT
	xTwinSAFE_Run: BOOL;
	xTwinSAFE_Reset: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_IN :
STRUCT
(* KL1904, Input *)
	IxReadyToolLeft:BOOL;
	IxReadyToolCenter:BOOL;
	IxReadyToolRight:BOOL;
	IxReadyToolFeeder:BOOL;
	IxReadyGrindFeeder:BOOL;
	IxRealseButton:BOOL;
	IxEmergencyStopStuder:BOOL;
	IxEmergencyStopMachine:BOOL;
	IxPowerSupplyEcoStep:BOOL;
	IxContactorAuxContact:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_OUT :
STRUCT
(* KL6904, Output *)
	QxEmergencyStopStuder:BOOL;
	QxAirSupply:BOOL;
	QxContactor_K3:BOOL;
	QxContactor_K4:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Constant_Variablen' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL CONSTANT
	(* developpement *)
	(*sRootPLC:STRING(255):='C:';*)
	(* machine *)
	cssRootPLC:STRING(255):='';
	(* HDD *)
	csiMaxFileLine:INT:=255;
	(* Axis *)
	csiMaxAxisFileObj:INT:=50;
	ciMaxWireStretch:INT:=32767;
	(* Visualisation *)
	csiMaxPage:INT:=50;
	csiMaxUserLevel:INT:=3;
	(* Profile *)
	csiMaxProfile:INT:=100;
END_VAR

(* @OBJECT_END := 'Constant_Variablen' *)
(* @CONNECTIONS := Constant_Variablen
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Globale_Variablen' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
(* Structure layer 2 *)
	T_HDD:ST_HDD;
	T_NovRam : ST_NOVRAM;
	T_CtrlePanel:ST_CTRLEPANEL;
	T_DeviceID:ST_DEVICEID;
	T_BoxID:ST_BOXID;
	 T_AxisNodeState AT %I* :ST_NODESTATE;
(* Visualization *)
	QVisCtrl :ST_QVISCTRLE;(*~	(QVis) (InOut:2)	~*)
	T_ExchgParam :ST_QVIS_EXCHG_PARAM;(*~	(QVis) (InOut:2)	~*)
	T_VisuQVis:ST_QVIS;
(* Control Button Start/Stop *)
	T_CtrleBtStartStop:ST_CTRLEBUTTON;
(* StartUp *)
	T_StartUp:ST_STARTUP;
(* Station *)
	T_Station:ST_STATION;
(* Process *)
	T_Process : ST_PROCESS;
(* Profile *)
	T_Profile:ST_PROFILE;
(* Static Error List *)
	T_ErrorList:ST_ERROR_LIST;	(* Static define Error List *)
(* IO's *)
	IarxDigitalInput AT %I* : ARRAY[1..64] OF BOOL;
	QarxDigitalOutput AT %Q* : ARRAY[1..64] OF BOOL;
	IariAnalogInput AT %I* : ARRAY[1..32] OF INT;
	QariAnalogOutput AT %Q* : ARRAY[1..32] OF INT;
	QarxCylinder AT %Q* : ARRAY[1..32] OF BOOL;
(* TwinSafe *)
	T_TwinSafeCtrleIN AT %I*:ST_TWINSAFE_CTRLE_IN;
	T_TwinSafeCtrleOUT AT %Q*:ST_TWINSAFE_CTRLE_OUT;
	T_TwinSafeIn:ST_TWINSAFE_IN;
	T_TwinSafeOut AT %I*:ST_TWINSAFE_OUT;
END_VAR
(* @OBJECT_END := 'Globale_Variablen' *)
(* @CONNECTIONS := Globale_Variablen
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'TwinCAT_Configuration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(* Generated automatically by TwinCAT - (read only) *)
VAR_CONFIG
	PRG_HW_STATION.TToolLeftRxPdoPara AT %QB0 : ST_RX_PDO_PARA;
	PRG_HW_STATION.TToolLeftTxPdoPara AT %IB0 : ST_TX_PDO_PARA;
	PRG_HW_STATION.TToolCenterRxPdoPara AT %QB27 : ST_RX_PDO_PARA;
	PRG_HW_STATION.TToolCenterTxPdoPara AT %IB17 : ST_TX_PDO_PARA;
	PRG_HW_STATION.TToolRightRxPdoPara AT %QB54 : ST_RX_PDO_PARA;
	PRG_HW_STATION.TToolRightTxPdoPara AT %IB34 : ST_TX_PDO_PARA;
	PRG_HW_STATION.TToolFeederRxPdoPara AT %QB81 : ST_RX_PDO_PARA;
	PRG_HW_STATION.TToolFeederTxPdoPara AT %IB51 : ST_TX_PDO_PARA;
	PRG_HW_STATION.TGrindFeederRxPdoPara AT %QB108 : ST_RX_PDO_PARA;
	PRG_HW_STATION.TGrindFeederTxPdoPara AT %IB68 : ST_TX_PDO_PARA;
	PRG_HW_STATION.stToolLeftRefOut AT %QB135 : PLCTONC_AXLESTRUCT;
	PRG_HW_STATION.stToolLeftRefIn AT %IB85 : NCTOPLC_AXLESTRUCT;
	PRG_HW_STATION.stToolCenterRefOut AT %QB263 : PLCTONC_AXLESTRUCT;
	PRG_HW_STATION.stToolCenterRefIn AT %IB213 : NCTOPLC_AXLESTRUCT;
	PRG_HW_STATION.stToolRightRefOut AT %QB391 : PLCTONC_AXLESTRUCT;
	PRG_HW_STATION.stToolRightRefIn AT %IB341 : NCTOPLC_AXLESTRUCT;
	PRG_HW_STATION.stToolFeederRefOut AT %QB519 : PLCTONC_AXLESTRUCT;
	PRG_HW_STATION.stToolFeederRefIn AT %IB469 : NCTOPLC_AXLESTRUCT;
	PRG_HW_STATION.stGrindFeederRefOut AT %QB647 : PLCTONC_AXLESTRUCT;
	PRG_HW_STATION.stGrindFeederRefIn AT %IB597 : NCTOPLC_AXLESTRUCT;
	PRG_HW_STATION.auiActualAxisTorqueBeckhoff AT %IB725 : ARRAY [1..5] OF UINT;
	PRG_HW_STATION.axInputAxisBeckhoff AT %IB735 : ARRAY [1..5, 1..8] OF BOOL;
	PRG_TWINSAFE.TwinSAFEinputKlemme1.KLx904_SafetyIn AT %IB920 : TwinSAFE_SafetyIn;	(*  ~ {LinkedWith:TIID^CX1000_PLC^CX1100-KB^Klemme 9 (KL1904)^Kanal 1^Safety In} *)
	PRG_TWINSAFE.TwinSAFEinputKlemme2.KLx904_SafetyIn AT %IB926 : TwinSAFE_SafetyIn;	(*  ~ {LinkedWith:TIID^CX1000_PLC^CX1100-KB^Klemme 10 (KL1904)^Kanal 1^Safety In} *)
	PRG_TWINSAFE.TwinSAFEinputKlemme3.KLx904_SafetyIn AT %IB932 : TwinSAFE_SafetyIn;	(*  ~ {LinkedWith:TIID^CX1000_PLC^CX1100-KB^Klemme 11 (KL1904)^Kanal 1^Safety In} *)
	PRG_USB_IO_PANEL.IarxCtrlePanelButton AT %IB775 : ARRAY [1..10] OF BOOL;
	PRG_USB_IO_PANEL.QarxCtrlePanelLed AT %QB775 : ARRAY [1..10] OF BOOL;
	.T_AxisNodeState AT %IB940 : ST_NODESTATE;
	.IarxDigitalInput AT %IB785 : ARRAY [1..64] OF BOOL;
	.QarxDigitalOutput AT %QB785 : ARRAY [1..64] OF BOOL;
	.IariAnalogInput AT %IB849 : ARRAY [1..32] OF INT;
	.QariAnalogOutput AT %QB849 : ARRAY [1..32] OF INT;
	.QarxCylinder AT %QB913 : ARRAY [1..32] OF BOOL;
	.T_TwinSafeCtrleIN AT %IB913 : ST_TWINSAFE_CTRLE_IN;
	.T_TwinSafeCtrleOUT AT %QB945 : ST_TWINSAFE_CTRLE_OUT;
	.T_TwinSafeOut AT %IB916 : ST_TWINSAFE_OUT;
END_VAR
(* @OBJECT_END := 'TwinCAT_Configuration' *)
(* @CONNECTIONS := TwinCAT_Configuration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Variablen_Konfiguration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_CONFIG
END_VAR

(* @OBJECT_END := 'Variablen_Konfiguration' *)
(* @CONNECTIONS := Variablen_Konfiguration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)


_ALARMCONFIG
_ALARMCONFIGNEXTTEXTID : 10002
_ALARMCONFIGFORMATS : 'hh$':$'mm$':$'ss','dd$'-$'MM$'-$'yyyy'
_ALARMCLASSLIST : 1
_ALARMCLASSID : 0
_ALARMCLASSACKTYPE : 0
_ALARMCLASSNAME : 'DEFAULT'
_ALARMCLASSDESCRIPTION : ''
_ALARMCLASSBGCOLORS : 16777215,16777215,16777215
_ALARMCLASSTEXTCOLORS : 3394560,255,16711680
_ALARMCLASSBITMAPS : '','',''
_ALARMACTIONLIST : 0
(* @ALARMCLASSRESETCOLORS := '_ALARMCLASSRESETCOLORS: 33023,16777215' *)
(* @ALARMCLASSRESETBITMAP := '_ALARMCLASSRESETBITMAP: $'$'' *)
_ALARMGROUPLISTNAME : 'System'
_ALARMGROUPPATH : 'System'
_ALARMGROUPLIST : 0
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0

(* @ALARMCONFIGFLAGS := '_ALARMCONFIGFLAGS: 0' *)
(* @ALARMCONFIGGLOBALDB_STR := '_ALARMCONFIGGLOBALDB_STRINGS: $'$',$'$',$'$',$'$'' *)
(* @ALARMCONFIGGLOBALDB_NUM := '_ALARMCONFIGGLOBALDB_NUMBERS: 0,0' *)
_END_ALARMCONFIG


_WORKSPACE
_GLOBALVISUALSETTINGS
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0
_VISUALBITMAPLISTCOUNT : 0
_END_GLOBALVISUALSETTINGS
_END_WORKSPACE


LIBRARY
ConnectionDiagnose.lib 3.7.07 16:35:00
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 3
TwinSAFE_input: 2048
TwinSAFE_logic: 2048
TwinSAFE_output: 2048
NumOfGVLs: 1
Globale_Variablen: 2048
END_LIBRARY

LIBRARY
PLC_EposCmd.lib 23.7.04 12:26:00
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 53
FB_ClearFault: 2048
FB_FindHome: 2048
FB_GetAllDigitalInputs: 2048
FB_GetAllDigitalOutputs: 2048
FB_GetAnalogInput: 2048
FB_GetCurrentIs: 2048
FB_GetCurrentMust: 2048
FB_GetCurrentRegulatorGain: 2048
FB_GetDisableState: 2048
FB_GetEnableState: 2048
FB_GetEncoderParameter: 2048
FB_GetFaultState: 2048
FB_GetHomingParameter: 2048
FB_GetMotorParameter: 2048
FB_GetMovementState: 2048
FB_GetObject: 2048
FB_GetOperationMode: 2048
FB_GetPositionIs: 2048
FB_GetPositionMust: 2048
FB_GetPositionProfile: 2048
FB_GetPositionRegulatorGain: 2048
FB_GetQuickStopState: 2048
FB_GetTargetPosition: 2048
FB_GetTargetVelocity: 2048
FB_GetVelocityIs: 2048
FB_GetVelocityMust: 2048
FB_GetVelocityProfile: 2048
FB_GetVelocityRegulatorGain: 2048
FB_GetVersion: 2048
FB_HaltPositionMovement: 2048
FB_HaltVelocityMovement: 2048
FB_MoveToPosition: 2048
FB_MoveWithVelocity: 2048
FB_Restore: 2048
FB_SetAllDigitalOutputs: 2048
FB_SetCurrentMust: 2048
FB_SetCurrentRegulatorGain: 2048
FB_SetDisableState: 2048
FB_SetEnableState: 2048
FB_SetEncoderParameter: 2048
FB_SetHomingParameter: 2048
FB_SetMotorParameter: 2048
FB_SetObject: 2048
FB_SetOperationMode: 2048
FB_SetPositionMust: 2048
FB_SetPositionProfile: 2048
FB_SetPositionRegulatorGain: 2048
FB_SetQuickStopState: 2048
FB_SetVelocityMust: 2048
FB_SetVelocityProfile: 2048
FB_SetVelocityRegulatorGain: 2048
FB_StopHoming: 2048
FB_Store: 2048
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
STANDARD.LIB 5.6.98 12:03:02
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 20
CONCAT: 0
CTD: 0
CTU: 0
CTUD: 0
DELETE: 0
F_TRIG: 0
FIND: 0
INSERT: 0
LEFT: 0
LEN: 0
MID: 0
R_TRIG: 0
REPLACE: 0
RIGHT: 0
RS: 0
SEMA: 0
SR: 0
TOF: 0
TON: 0
TP: 0
NumOfGVLs: 1
'Global Variables 0': 0
END_LIBRARY

LIBRARY
TcBase.lib 14.5.09 12:14:08
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 30
FW_AdsClearEvents: 0
FW_AdsLogDINT: 0
FW_AdsLogEvent: 0
FW_AdsLogLREAL: 0
FW_AdsLogSTR: 0
FW_AdsRdWrt: 0
FW_AdsRdWrtInd: 0
FW_AdsRdWrtRes: 0
FW_AdsRead: 0
FW_AdsReadDeviceInfo: 0
FW_AdsReadInd: 0
FW_AdsReadRes: 0
FW_AdsReadState: 0
FW_AdsWrite: 0
FW_AdsWriteControl: 0
FW_AdsWriteInd: 0
FW_AdsWriteRes: 0
FW_DRand: 0
FW_GetCpuAccount: 0
FW_GetCpuCounter: 0
FW_GetCurTaskIndex: 0
FW_GetSystemTime: 0
FW_GetVersionTcBase: 0
FW_LptSignal: 0
FW_MemCmp: 0
FW_MemCpy: 0
FW_MemMove: 0
FW_MemSet: 0
FW_PortRead: 2048
FW_PortWrite: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcBaseMath.lib 27.7.04 12:07:56
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 4
FW_Floor: 2048
FW_LrealFrac: 2048
FW_LrealModP: 2048
FW_LrealTrunc: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcIoFunctions.lib 27.1.17 17:22:22
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 99
F_ByteSwap: 2048
F_CheckForSwapBytes: 2048
F_CreateDpv1ReadReqPkg: 2048
F_CreateDpv1ReadReqPkgPNET: 2048
F_CreateDpv1WriteReqPkg: 2048
F_CreateDpv1WriteReqPkgPNET: 2048
F_GetDataString: 2048
F_GetPDTypeSize: 2048
F_GetVersionTcIoFunctions: 0
F_SplitDpv1ReadResPkg: 2048
F_SplitDpv1ReadResPkgPNET: 2048
F_SplitDpv1WriteResPkg: 2048
F_SplitDpv1WriteResPkgPNET: 2048
FB_ASI_Addressing: 0
FB_ASI_ParameterControl: 2048
FB_ASI_Parameterinterface: 0
FB_ASI_Processdata_analog: 0
FB_ASI_Processdata_digital: 0
FB_ASI_Projecting: 0
FB_ASI_ReadParameter: 0
FB_ASI_SlaveDiag: 0
FB_ASI_WriteParameter: 0
FB_ASI_WriteReadParameter: 2048
FB_AX2000_AXACT: 0
FB_AX2000_AXACT.a_MapInputs: 2048
FB_AX2000_AXACT.a_MapOutputs: 2048
FB_AX2000_AXACT.a_RW_CtrlWord: 2048
FB_AX2000_AXACT.a_RW_PZD: 2048
FB_AX2000_JogMode: 0
FB_AX2000_JogMode.a_MapInputs: 2048
FB_AX2000_JogMode.a_MapOutputs: 2048
FB_AX2000_Parameter: 0
FB_AX2000_Reference: 0
FB_AX2000_Reference.a_MapInputs: 2048
FB_AX2000_Reference.a_MapOutputs: 2048
FB_AX200X_Profibus: 0
FB_Dpv1Read: 2048
FB_Dpv1ReadPNET: 2048
FB_Dpv1Write: 2048
FB_Dpv1WritePNET: 2048
FB_FCxxxxDpv0PkwRead: 0
FB_FCxxxxDpv0PkwWrite: 0
FB_GetDPRAMInfo: 2048
FB_GetDPRAMInfoEx: 2048
FB_GetUPSStatus: 2048
FB_KL1501Config: 2048
FB_KL1501Config.A_ReadConfigTable: 2048
FB_KL1501Config.A_SetConfigTable: 2048
FB_KL27x1Config: 2048
FB_KL27x1Config.A_ReadConfigTable: 2048
FB_KL27x1Config.A_SetConfigTable: 2048
FB_KL3208Config: 2048
FB_KL3208Config.A_ReadConfigTable: 2048
FB_KL3208Config.A_SetConfigTable: 2048
FB_KL320xConfig: 2048
FB_KL320xConfig.A_ReadConfigTable: 2048
FB_KL320xConfig.A_SetConfigTable: 2048
FB_KL3228Config: 2048
FB_KL3228Config.A_ReadConfigTable: 2048
FB_KL3228Config.A_SetConfigTable: 2048
FB_NovRamReadWrite: 0
FB_NovRamReadWriteEx: 2048
FB_ReadAdsTecSysData: 2048
FB_ReadInput_analog: 2048
FB_WriteOutput_analog: 2048
IOF_CAN_Layer2Command: 0
IOF_DeviceReset: 0
IOF_GetBoxAddrByName: 0
IOF_GetBoxAddrByNameEx: 0
IOF_GetBoxCount: 0
IOF_GetBoxNameByAddr: 0
IOF_GetBoxNetId: 0
IOF_GetDeviceCount: 0
IOF_GetDeviceIDByName: 0
IOF_GetDeviceIDs: 0
IOF_GetDeviceInfoByName: 0
IOF_GetDeviceName: 0
IOF_GetDeviceNetId: 0
IOF_GetDeviceType: 0
IOF_LB_BreakLocationTest: 0
IOF_LB_ParityCheck: 0
IOF_LB_ParityCheckWithReset: 0
IOF_SER_DRIVE_Backup: 0
IOF_SER_DRIVE_BackupEx: 2048
IOF_SER_DRIVE_Reset: 0
IOF_SER_GetPhase: 0
IOF_SER_IDN_Read: 0
IOF_SER_IDN_Write: 0
IOF_SER_ResetErr: 0
IOF_SER_SaveFlash: 0
IOF_SER_SetPhase: 0
SCIT_ActivateConfiguration: 0
SCIT_AlarmStop: 0
SCIT_ConfDevErrAll: 0
SCIT_ControlActiveConfiguration: 0
SCIT_DeactivateConfiguration: 0
SCIT_GetErrorInfo: 0
SCIT_StartDataTransfer: 0
SCIT_StopDataTransfer: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
TcMath.lib 23.9.04 15:15:30
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 7
F_GetVersionTcMath: 0
FLOOR: 2048
FRAC: 2048
LMOD: 2048
LTRUNC: 2048
MODABS: 2048
MODTURNS: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcMC.lib 27.7.15 08:51:38
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 64
F_GetIndexGroup: 2048
F_GetVersionTcMC: 2048
FB_MoveGeneric: 2048
FB_NewPosAndVeloGeneric: 2048
FB_ReadCharacteristicValues: 2048
FB_ReadWriteParameter: 2048
FB_SystemJog: 2048
MC_AbortSuperposition: 2048
MC_AbortTrigger: 2048
MC_ChangeDynParam: 2048
MC_ExtSetPointGenDisable: 2048
MC_ExtSetPointGenEnable: 2048
MC_ExtSetPointGenFeed: 2048
MC_GearIn: 0
MC_GearInDyn: 2048
MC_GearInDynCCV: 2048
MC_GearInFloat: 2048
MC_GearInMultiMaster: 2048
MC_GearOut: 0
MC_GearOutExt: 2048
MC_Home: 2048
MC_Jog: 2048
MC_Jog.ActCheckJogEnd: 2048
MC_Jog.ActJogMove: 2048
MC_MoveAbsolute: 2048
MC_MoveAbsoluteOrRestart: 2048
MC_MoveAbsoluteOrRestart.MC_MoveAbsoluteCall: 2048
MC_MoveAbsoluteOrRestart.MC_MoveAbsoluteRestartTrigger: 2048
MC_MoveAbsoluteOrRestart.MC_MoveRestartCall: 2048
MC_MoveModulo: 2048
MC_MoveModulo.MC_MoveModuloCall: 2048
MC_MoveRelative: 2048
MC_MoveSuperImposed: 2048
MC_MoveSuperImposedExt: 2048
MC_MoveVelocity: 2048
MC_NewPos: 2048
MC_NewPosAndVelo: 2048
MC_OrientedStop: 2048
MC_OverrideFilter: 2048
MC_ParametrizedStop: 2048
MC_Power: 0
MC_PowerStepper: 2048
MC_ReadActualPosition: 0
MC_ReadAxisComponents: 2048
MC_ReadAxisError: 0
MC_ReadBoolParameter: 0
MC_ReadParameter: 2048
MC_ReadParameterSet: 2048
MC_ReadStatus: 0
MC_Reset: 0
MC_SetActualPosition: 2048
MC_SetActualPositionOnTheFly: 2048
MC_SetEncoderScalingFactor: 2048
MC_SetOverride: 2048
MC_SetReferenceFlag: 2048
MC_Stop: 0
MC_TouchProbe: 2048
MC_TouchProbe.ActTouchProbeActivate: 2048
MC_TouchProbe.ActTouchProbeMonitorActivity: 2048
MC_TouchProbe.ActTouchProbeMonitorLatchValid: 2048
MC_TouchProbe.ActTouchProbeMonitorPlcEvent: 2048
MC_TouchProbe.ActTouchProbeStartupInit: 2048
MC_WriteBoolParameter: 0
MC_WriteParameter: 2048
NumOfGVLs: 1
Constants: 0
END_LIBRARY

LIBRARY
TcNC.lib 10.10.08 17:55:34
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 61
AXACT: 0
AXACTEX: 0
AXCPL: 0
AXCPLMULTITAB: 0
AXCPLTAB: 0
AXFNC: 0
AxisCamDataQueued: 2048
AxisCamScalingPending: 2048
AxisCamTableQueued: 2048
AxisControlLoopClosed: 2048
AxisDriveDeviceError: 2048
AxisExternalLatchValid: 0
AxisGetOverridePercent: 0
AxisGotNewTargetPosition: 0
AxisHasBeenStopped: 0
AxisHasExtSetPointGen: 0
AxisHasJob: 0
AxisInErrorState: 0
AxisInPositionWindow: 0
AxisInProtectedMode: 0
AxisInPTPMode: 2048
AxisIoDataIsInvalid: 2048
AxisIsAtTargetPosition: 0
AxisIsCalibrated: 0
AxisIsCalibrating: 0
AxisIsCompensating: 0
AxisIsCoupled: 0
AxisIsMoving: 0
AxisIsMovingBackwards: 0
AxisIsMovingEndless: 2048
AxisIsMovingForward: 0
AxisIsNotInTargetPosition: 0
AxisIsNotMoving: 0
AxisIsReady: 0
AxisJobPending: 2048
AxisReachedConstantVelocity: 0
AxisSetAcceptBlockedDriveSignal: 2048
AxisSetControllerEnable: 0
AxisSetFeedEnableMinus: 0
AxisSetFeedEnablePlus: 0
AxisSetOverridePercent: 0
AxisSetReferencingCamSignal: 0
AxisSoftLimitMaxExceeded: 2048
AxisSoftLimitMinExceeded: 2048
AXSCOM: 0
F_GetCompensationElementAt: 2048
F_GetLeftIndex: 2048
F_GetVersionTcNC: 0
F_IsCompensationDirection: 2048
F_LinearInterpolationCompensation: 2048
FB_AxisNewTargPosAndVelo: 0
FB_GetAxisAmsAddr: 2048
FB_PositionCompensation: 2048
FB_RegisterComKL25xx: 2048
FB_RegisterComKL25xx.ActCheckTerminalType: 2048
FB_RegisterComKL25xx.ActNcTerminalMappingIn: 2048
FB_RegisterComKL25xx.ActNcTerminalMappingOut: 2048
FB_RegisterComKL25xx.ActReadNcTerminalProcessImage: 2048
FB_RegisterComKL25xx.ActWriteNcTerminalProcessImage: 2048
FB_WritePositionCorrection: 2048
Get_TcNcUtilities_Version: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

LIBRARY
TcSystem.lib 7.6.16 11:01:22
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 84
ADSCLEAREVENTS: 0
ADSLOGDINT: 0
ADSLOGEVENT: 0
ADSLOGLREAL: 0
ADSLOGSTR: 0
ADSRDDEVINFO: 0
ADSRDSTATE: 0
ADSRDWRT: 0
ADSRDWRTEX: 0
ADSRDWRTIND: 0
ADSRDWRTRES: 0
ADSREAD: 0
ADSREADEX: 0
ADSREADIND: 0
ADSREADRES: 0
ADSWRITE: 0
ADSWRITEIND: 0
ADSWRITERES: 0
ADSWRTCTL: 0
AnalyzeExpression: 2048
AnalyzeExpressionCombined: 2048
AnalyzeExpressionTable: 2048
AppendErrorString: 2048
BAVERSION_TO_DWORD: 2048
CLEARBIT32: 0
CSETBIT32: 0
DRAND: 0
F_CompareFwVersion: 2048
F_CreateAmsNetId: 0
F_CreateIPv4Addr: 2048
F_GetStructMemberAlignment: 2048
F_GetVersionTcSystem: 0
F_IOPortRead: 2048
F_IOPortWrite: 2048
F_ScanAmsNetIds: 2048
F_ScanIPv4AddrIds: 2048
F_SplitPathName: 2048
F_ToASC: 2048
F_ToCHR: 2048
FB_AdsReadWriteList: 2048
FB_BaDeviceIoControl: 2048
FB_BaGenGetVersion: 2048
FB_CreateDir: 2048
FB_EOF: 0
FB_FileClose: 0
FB_FileDelete: 0
FB_FileGets: 0
FB_FileOpen: 0
FB_FilePuts: 0
FB_FileRead: 0
FB_FileRename: 0
FB_FileSeek: 0
FB_FileTell: 0
FB_FileWrite: 0
FB_PcWatchdog: 2048
FB_PcWatchdog_BAPI: 2048
FB_RemoveDir: 2048
FB_SetLedColor_BAPI: 2048
FB_SimpleAdsLogEvent: 2048
FILECLOSE: 0
FILEOPEN: 0
FILEREAD: 0
FILESEEK: 0
FILEWRITE: 0
FW_CallGenericFb: 2048
FW_CallGenericFbEx: 2048
FW_CallGenericFun: 2048
GETBIT32: 0
GETCPUACCOUNT: 0
GETCPUCOUNTER: 0
GETCURTASKINDEX: 0
GETSYSTEMTIME: 0
GETTASKTIME: 2048
LPTSIGNAL: 0
MEMCMP: 0
MEMCPY: 0
MEMMOVE: 0
MEMSET: 0
ROL32: 0
ROR32: 0
SETBIT32: 0
SFCActionControl: 0
SHL32: 0
SHR32: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

LIBRARY
TcUtilities.lib 3.2.16 16:08:58
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 330
ARG_TO_CSVFIELD: 2048
BCD_TO_DEC: 0
BE128_TO_HOST: 2048
BE16_TO_HOST: 2048
BE32_TO_HOST: 2048
BE64_TO_HOST: 2048
BYTE_TO_BINSTR: 2048
BYTE_TO_DECSTR: 2048
BYTE_TO_HEXSTR: 2048
BYTE_TO_LREALEX: 2048
BYTE_TO_OCTSTR: 2048
BYTEARR_TO_MAXSTRING: 2048
CSVFIELD_TO_ARG: 2048
CSVFIELD_TO_STRING: 2048
DATA_TO_HEXSTR: 2048
DCF77_TIME: 2048
DCF77_TIME_EX: 2048
DEC_TO_BCD: 0
DEG_TO_RAD: 0
DINT_TO_DECSTR: 2048
DT_TO_FILETIME: 2048
DT_TO_SYSTEMTIME: 0
DWORD_TO_BINSTR: 2048
DWORD_TO_DECSTR: 2048
DWORD_TO_HEXSTR: 2048
DWORD_TO_LREALEX: 2048
DWORD_TO_OCTSTR: 2048
F_ARGCMP: 2048
F_ARGCPY: 2048
F_ARGIsZero: 2048
F_BIGTYPE: 2048
F_BOOL: 2048
F_BYTE: 0
F_BYTE_TO_CRC16_CCITT: 2048
F_CheckSum16: 0
F_CRC16_CCITT: 0
F_CreateHashTableHnd: 2048
F_CreateLinkedListHnd: 2048
F_DATA_TO_CRC16_CCITT: 2048
F_DINT: 0
F_DWORD: 0
F_FormatArgToStr: 2048
F_GetDayOfMonthEx: 2048
F_GetDayOfWeek: 2048
F_GetDOYOfYearMonthDay: 2048
F_GetFloatRec: 2048
F_GetMaxMonthDays: 2048
F_GetMonthOfDOY: 2048
F_GetVersionTcUtilities: 0
F_GetWeekOfTheYear: 2048
F_HUGE: 2048
F_INT: 0
F_LARGE: 2048
F_LREAL: 0
F_LTrim: 2048
F_PVOID: 2048
F_REAL: 0
F_RTrim: 2048
F_SINT: 0
F_STRING: 0
F_SwapReal: 0
F_SwapRealEx: 2048
F_ToLCase: 2048
F_ToUCase: 2048
F_TranslateFileTimeBias: 2048
F_UDINT: 0
F_UHUGE: 2048
F_UINT: 0
F_ULARGE: 2048
F_USINT: 0
F_WORD: 0
F_YearIsLeapYear: 2048
FB_AddRouteEntry: 2048
FB_AmsLogger: 2048
FB_BasicPID: 0
FB_BufferedTextFileWriter: 2048
FB_BufferedTextFileWriter.A_Reset: 2048
FB_ConnectScopeServer: 2048
FB_CSVMemBufferReader: 2048
FB_CSVMemBufferWriter: 2048
FB_DbgOutputCtrl: 2048
FB_DbgOutputCtrl.A_Log: 2048
FB_DbgOutputCtrl.A_LogHex: 2048
FB_DbgOutputCtrl.A_Reset: 2048
FB_DisconnectScopeServer: 2048
FB_EnumFindFileEntry: 2048
FB_EnumFindFileList: 2048
FB_EnumRouteEntry: 2048
FB_EnumStringNumbers: 2048
FB_FileRingBuffer: 2048
FB_FileRingBuffer.A_AddTail: 2048
FB_FileRingBuffer.A_Close: 2048
FB_FileRingBuffer.A_Create: 2048
FB_FileRingBuffer.A_GetHead: 2048
FB_FileRingBuffer.A_Open: 2048
FB_FileRingBuffer.A_RemoveHead: 2048
FB_FileRingBuffer.A_Reset: 2048
FB_FileTimeToTzSpecificLocalTime: 2048
FB_FileTimeToTzSpecificLocalTime.A_Reset: 2048
FB_FormatString: 0
FB_GetAdaptersInfo: 2048
FB_GetDeviceIdentification: 2048
FB_GetDeviceIdentificationEx: 2048
FB_GetHostAddrByName: 2048
FB_GetHostName: 2048
FB_GetLocalAmsNetId: 2048
FB_GetRouterStatusInfo: 2048
FB_GetTimeZoneInformation: 2048
FB_HashTableCtrl: 2048
FB_HashTableCtrl.A_Add: 2048
FB_HashTableCtrl.A_GetFirst: 2048
FB_HashTableCtrl.A_GetIndexAtPosPtr: 2048
FB_HashTableCtrl.A_GetNext: 2048
FB_HashTableCtrl.A_Lookup: 2048
FB_HashTableCtrl.A_Remove: 2048
FB_HashTableCtrl.A_RemoveAll: 2048
FB_HashTableCtrl.A_RemoveFirst: 2048
FB_HashTableCtrl.A_Reset: 2048
FB_LinkedListCtrl: 2048
FB_LinkedListCtrl.A_AddHeadValue: 2048
FB_LinkedListCtrl.A_AddTailValue: 2048
FB_LinkedListCtrl.A_FindNext: 2048
FB_LinkedListCtrl.A_FindPrev: 2048
FB_LinkedListCtrl.A_GetHead: 2048
FB_LinkedListCtrl.A_GetIndexAtPosPtr: 2048
FB_LinkedListCtrl.A_GetNext: 2048
FB_LinkedListCtrl.A_GetPrev: 2048
FB_LinkedListCtrl.A_GetTail: 2048
FB_LinkedListCtrl.A_RemoveHeadValue: 2048
FB_LinkedListCtrl.A_RemoveTailValue: 2048
FB_LinkedListCtrl.A_RemoveValueAtPosPtr: 2048
FB_LinkedListCtrl.A_Reset: 2048
FB_LinkedListCtrl.A_SetValueAtPosPtr: 2048
FB_LocalSystemTime: 2048
FB_MemBufferMerge: 2048
FB_MemBufferSplit: 2048
FB_MemRingBuffer: 2048
FB_MemRingBuffer.A_AddTail: 2048
FB_MemRingBuffer.A_GetHead: 2048
FB_MemRingBuffer.A_RemoveHead: 2048
FB_MemRingBuffer.A_Reset: 2048
FB_MemRingBufferEx: 2048
FB_MemRingBufferEx.A_AddTail: 2048
FB_MemRingBufferEx.A_FreeHead: 2048
FB_MemRingBufferEx.A_GetFreeSize: 2048
FB_MemRingBufferEx.A_GetHead: 2048
FB_MemRingBufferEx.A_Reset: 2048
FB_MemStackBuffer: 2048
FB_MemStackBuffer.A_Pop: 2048
FB_MemStackBuffer.A_Push: 2048
FB_MemStackBuffer.A_Reset: 2048
FB_MemStackBuffer.A_Top: 2048
FB_RegQueryValue: 0
FB_RegSetValue: 0
FB_RemoveRouteEntry: 2048
FB_ResetScopeServerControl: 2048
FB_SaveScopeServerData: 2048
FB_ScopeServerControl: 2048
FB_SetTimeZoneInformation: 2048
FB_StartScopeServer: 2048
FB_StopScopeServer: 2048
FB_StringRingBuffer: 2048
FB_StringRingBuffer.A_AddTail: 2048
FB_StringRingBuffer.A_GetHead: 2048
FB_StringRingBuffer.A_RemoveHead: 2048
FB_StringRingBuffer.A_Reset: 2048
FB_SystemTimeToTzSpecificLocalTime: 2048
FB_SystemTimeToTzSpecificLocalTime.A_Reset: 2048
FB_TextFileRingBuffer: 2048
FB_TextFileRingBuffer.A_AddTail: 2048
FB_TextFileRingBuffer.A_Close: 2048
FB_TextFileRingBuffer.A_Open: 2048
FB_TextFileRingBuffer.A_Reset: 2048
FB_TranslateLocalTimeToUtcByZoneID: 2048
FB_TranslateLocalTimeToUtcByZoneID.A_Reset: 2048
FB_TranslateUtcToLocalTimeByZoneID: 2048
FB_TranslateUtcToLocalTimeByZoneID.A_Reset: 2048
FB_TzSpecificLocalTimeToFileTime: 2048
FB_TzSpecificLocalTimeToFileTime.A_Reset: 2048
FB_TzSpecificLocalTimeToSystemTime: 2048
FB_TzSpecificLocalTimeToSystemTime.A_Reset: 2048
FB_WritePersistentData: 2048
FILETIME_TO_DT: 2048
FILETIME_TO_SYSTEMTIME: 2048
FIX16_TO_LREAL: 2048
FIX16_TO_WORD: 2048
FIX16Add: 2048
FIX16Align: 2048
FIX16Div: 2048
FIX16Mul: 2048
FIX16Sub: 2048
GetRemotePCInfo: 0
GUID_TO_REGSTRING: 2048
GUID_TO_STRING: 2048
GuidsEqualByVal: 2048
HEXASCNIBBLE_TO_BYTE: 2048
HEXCHRNIBBLE_TO_BYTE: 2048
HEXSTR_TO_DATA: 2048
HOST_TO_BE128: 2048
HOST_TO_BE16: 2048
HOST_TO_BE32: 2048
HOST_TO_BE64: 2048
INT64_TO_LREAL: 2048
Int64Add64: 2048
Int64Add64Ex: 2048
Int64Cmp64: 2048
Int64Div64Ex: 2048
Int64IsZero: 2048
Int64Negate: 2048
Int64Not: 2048
Int64Sub64: 2048
IsFinite: 2048
LARGE_INTEGER: 2048
LARGE_TO_ULARGE: 2048
LREAL_TO_FIX16: 2048
LREAL_TO_FMTSTR: 2048
LREAL_TO_INT64: 2048
LREAL_TO_UINT64: 2048
MAXSTRING_TO_BYTEARR: 2048
NT_AbortShutdown: 0
NT_GetTime: 0
NT_Reboot: 0
NT_SetLocalTime: 2048
NT_SetTimeToRTCTime: 0
NT_Shutdown: 0
NT_StartProcess: 0
OTSTRUCT_TO_TIME: 0
PBOOL_TO_BOOL: 2048
PBYTE_TO_BYTE: 2048
PDATE_TO_DATE: 2048
PDINT_TO_DINT: 2048
PDT_TO_DT: 2048
PDWORD_TO_DWORD: 2048
PHUGE_TO_HUGE: 2048
PINT_TO_INT: 2048
PLARGE_TO_LARGE: 2048
PLC_ReadSymInfo: 0
PLC_ReadSymInfoByName: 0
PLC_ReadSymInfoByNameEx: 0
PLC_Reset: 0
PLC_Start: 0
PLC_Stop: 0
PLREAL_TO_LREAL: 2048
PMAXSTRING_TO_MAXSTRING: 2048
PREAL_TO_REAL: 2048
Profiler: 0
PSINT_TO_SINT: 2048
PSTRING_TO_STRING: 2048
PTIME_TO_TIME: 2048
PTOD_TO_TOD: 2048
PUDINT_TO_UDINT: 2048
PUHUGE_TO_UHUGE: 2048
PUINT64_TO_UINT64: 2048
PUINT_TO_UINT: 2048
PULARGE_TO_ULARGE: 2048
PUSINT_TO_USINT: 2048
PVOID_TO_BINSTR: 2048
PVOID_TO_DECSTR: 2048
PVOID_TO_HEXSTR: 2048
PVOID_TO_OCTSTR: 2048
PVOID_TO_STRING: 2048
PWORD_TO_WORD: 2048
RAD_TO_DEG: 0
REGSTRING_TO_GUID: 2048
ROUTETRANSPORT_TO_STRING: 2048
RTC: 2048
RTC_EX: 2048
RTC_EX2: 2048
ScopeASCIIExport: 0
ScopeExit: 2048
ScopeGetRecordLen: 0
ScopeGetState: 0
ScopeLoadFile: 0
ScopeManualTrigger: 0
ScopeSaveAs: 2048
ScopeSetOffline: 0
ScopeSetOnline: 0
ScopeSetRecordLen: 0
ScopeViewExport: 0
STRING_TO_CSVFIELD: 2048
STRING_TO_GUID: 2048
STRING_TO_PVOID: 2048
STRING_TO_SYSTEMTIME: 2048
STRING_TO_UINT64: 2048
SYSTEMTIME_TO_DT: 0
SYSTEMTIME_TO_FILETIME: 2048
SYSTEMTIME_TO_STRING: 2048
TC_Config: 2048
TC_CpuUsage: 0
TC_Restart: 0
TC_Stop: 0
TC_SysLatency: 0
TIME_TO_OTSTRUCT: 0
UDINT_TO_LREALEX: 2048
UInt32x32To64: 2048
UINT64_TO_LREAL: 2048
UINT64_TO_STRING: 2048
UInt64Add64: 2048
UInt64Add64Ex: 2048
UInt64And: 2048
UInt64Cmp64: 2048
UInt64Div16Ex: 2048
UInt64Div64: 2048
UInt64Div64Ex: 2048
UInt64isZero: 2048
UInt64Limit: 2048
UInt64Max: 2048
UInt64Min: 2048
UInt64Mod64: 2048
UInt64Mul64: 2048
UInt64Mul64Ex: 2048
UInt64Not: 2048
UInt64Or: 2048
UInt64Rol: 2048
UInt64Ror: 2048
UInt64Shl: 2048
UInt64Shr: 2048
UInt64Sub64: 2048
UInt64Xor: 2048
UINT_TO_LREALEX: 2048
ULARGE_INTEGER: 2048
ULARGE_TO_LARGE: 2048
USINT_TO_LREALEX: 2048
WORD_TO_BINSTR: 2048
WORD_TO_DECSTR: 2048
WORD_TO_FIX16: 2048
WORD_TO_HEXSTR: 2048
WORD_TO_LREALEX: 2048
WORD_TO_OCTSTR: 2048
WritePersistentData: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

PLC_CONFIGURATION
_ELEMENT 15700
_ELEMENT_END
PLC_END


RESOURCE

TASK Standard (PRIORITY := 0, INTERVAL := T#5ms);
PRG_STARTUP();
PRG_VISU();
PRG_PROCESS();
PRG_STATION();
PRG_HW_GENERAL();
PRG_HW_STATION();
PRG_TWINSAFE();
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK

TASK Ctrl_Panel (PRIORITY := 1, INTERVAL := T#100ms);
PRG_USB_IO_PANEL();
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK

END_RESOURCE
